<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="https://www.w3.org/2005/Atom" xml:lang="en">
<title type="text">John <em>A</em> <strong>De Goes</strong></title>
<subtitle type="text">ramblings of a geek</subtitle>
<generator uri="https://github.com/mojombo/jekyll">Jekyll</generator>
<link rel="self" type="application/atom+xml" href="https://degoes.net/feed.xml" />
<link rel="alternate" type="text/html" href="https://degoes.net" />
<updated>2020-05-05T17:37:21-06:00</updated>
<id>https://degoes.net/</id>
<author>
  <name>John A De Goes</name>
  <uri>https://degoes.net/</uri>
  <email>john@degoes.net</email>
</author>


<entry>
  <title type="html"><![CDATA[Effect Tracking Is Commercially Worthless]]></title>
  <link rel="alternate" type="text/html" href="https://degoes.net/articles/no-effect-tracking" />
  <id>https://degoes.net/articles/no-effect-tracking</id>
  <published>2020-05-03T00:00:00-06:00</published>
  <updated>2020-05-03T00:00:00-06:00</updated>
  <author>
    <name>John A De Goes</name>
    <uri>https://degoes.net</uri>
    <email>john@degoes.net</email>
  </author>
  <content type="html">&lt;p&gt;Effect tracking is not a valid reason to use functional effect systems, because effect tracking is commercially worthless.&lt;/p&gt;

&lt;p&gt;More precisely, companies that pay their software developers to “track effects” will not obtain a return on this investment, but rather, will lose money.&lt;/p&gt;

&lt;p&gt;In this post, I’ll explain why.&lt;/p&gt;

&lt;h2 id=&quot;side-effects&quot;&gt;Side Effects&lt;/h2&gt;

&lt;p&gt;The whole notion of “effects” doesn’t make a lot of sense outside &lt;em&gt;functional programming&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;In functional programming, we try to build our software from deterministic, pure functions. These functions are like the ones most of us learned about in high school:&lt;/p&gt;

&lt;pre&gt;
f(x) = x * x
&lt;/pre&gt;

&lt;p&gt;Such functions are said to be “free of side-effects”, meaning their only effect is combining and transforming inputs to produce an output.&lt;/p&gt;

&lt;p&gt;Pure functions don’t do anything &lt;em&gt;on the side&lt;/em&gt;—they don’t do anything that could be observed from outside the function, like operating system calls or mutating the heap.&lt;/p&gt;

&lt;h2 id=&quot;discovering-purity&quot;&gt;Discovering Purity&lt;/h2&gt;

&lt;p&gt;When developers first discover functional programming, they believe that it’s &lt;em&gt;useless&lt;/em&gt; for real world applications.&lt;/p&gt;

&lt;p&gt;I had the same response when I first heard about programming without procedural statements, assignments, or loops.&lt;/p&gt;

&lt;p&gt;After all, procedures that compute random numbers, call databases, and or invoke web APIs, all perform “side-effects”.&lt;/p&gt;

&lt;p&gt;These procedures are not deterministic, pure functions that just combine and transform inputs to produce outputs. Yet they are the &lt;em&gt;cornerstone&lt;/em&gt; of building applications that solve real business problems.&lt;/p&gt;

&lt;p&gt;Eventually, of course, I discovered that in purely functional languages like Haskell, functions that interact with the outside world all return values of a mysterious &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;IO&lt;/code&gt; data type.&lt;/p&gt;

&lt;p&gt;This discovery feeds a myth that’s pervasive among even experienced Haskell programmers.&lt;/p&gt;

&lt;p&gt;The myth of &lt;em&gt;effect tracking&lt;/em&gt;.&lt;/p&gt;

&lt;h2 id=&quot;effect-tracking&quot;&gt;Effect Tracking&lt;/h2&gt;

&lt;p&gt;It’s extraordinarily common for developers who have encountered Haskell’s &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;IO&lt;/code&gt; data type to explain it as follows:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Impure functions return &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;IO&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;Pure functions don’t return &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;IO&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;According to this explanation, one can determine whether or not a function is effectful merely by examining the return type. The &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;IO&lt;/code&gt; type therefore “tracks” the presence of side-effects… hence, &lt;em&gt;effect tracking&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Consequently, many developers now believe that Haskell uses the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;IO&lt;/code&gt; type to track effects, to mark them as being “impure”—that Haskell’s type system is being recruited to help us ascertain purity.&lt;/p&gt;

&lt;p&gt;There’s just one &lt;em&gt;tiny&lt;/em&gt; little problem with this explanation.&lt;/p&gt;

&lt;p&gt;It’s totally and completely wrong!&lt;/p&gt;

&lt;h2 id=&quot;myth-busting&quot;&gt;Myth Busting&lt;/h2&gt;

&lt;p&gt;In point of fact, a Haskell function that returns &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;IO&lt;/code&gt; &lt;strong&gt;is&lt;/strong&gt; pure: it’s deterministic and entirely free of side-effects, merely transforming and combining inputs to produce an output.&lt;/p&gt;

&lt;p&gt;For example, take the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;putStrLn&lt;/code&gt; function:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-haskell&quot; data-lang=&quot;haskell&quot;&gt;&lt;span class=&quot;n&quot;&gt;putStrLn&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;::&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;IO&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;()&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-scala&quot; data-lang=&quot;scala&quot;&gt;&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;putStrLn&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;line&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;IO&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;IOException&lt;/span&gt;, &lt;span class=&quot;kt&quot;&gt;Unit&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;This function takes a string, and returns an &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;IO&lt;/code&gt; value. It does not actually &lt;em&gt;perform&lt;/em&gt; any effects, and if given the same string, it will return the ‘same’ &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;IO&lt;/code&gt; value. Moreover, the value that it returns is &lt;em&gt;totally immutable&lt;/em&gt;, like all values in Haskell.&lt;/p&gt;

&lt;p&gt;These guarantees hold not just for &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;putStrLn&lt;/code&gt;, but for all functions that return &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;IO&lt;/code&gt; values (unless they cheat by using &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;unsafePerformIO&lt;/code&gt; or similar).&lt;/p&gt;

&lt;p&gt;Stated more forcefully, functions that return &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;IO&lt;/code&gt; values are &lt;em&gt;no different&lt;/em&gt; than functions that do &lt;strong&gt;not&lt;/strong&gt; return &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;IO&lt;/code&gt; values: they are pure, and their type signature does not reveal the presence or absence of side-effects, because there are no side-effects at all.&lt;/p&gt;

&lt;p&gt;Now, eventually one learns that &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;IO&lt;/code&gt; is a data type, whose immutable values &lt;em&gt;model&lt;/em&gt; some sequence of interactions with the outside world (mutable heap, sockets, files, databases, and the like).&lt;/p&gt;

&lt;p&gt;So, even though a function like &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;putStrLn&lt;/code&gt; does not &lt;em&gt;perform&lt;/em&gt; any side-effects, the value it returns &lt;em&gt;describes&lt;/em&gt; a side-effect.&lt;/p&gt;

&lt;p&gt;However, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;IO&lt;/code&gt; is not magical in this regard. Indeed, entirely without &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;IO&lt;/code&gt;, we can easily construct a simple model of interaction with the outside world, like sockets:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-haskell&quot; data-lang=&quot;haskell&quot;&gt;&lt;span class=&quot;kr&quot;&gt;data&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;SocketIO&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; 
  &lt;span class=&quot;kt&quot;&gt;ReadByte&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;Byte&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;SocketIO&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;|&lt;/span&gt;
  &lt;span class=&quot;kt&quot;&gt;WriteByte&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Byte&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;SocketIO&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-scala&quot; data-lang=&quot;scala&quot;&gt;&lt;span class=&quot;k&quot;&gt;sealed&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;trait&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;SocketIO&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;+A&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt;
&lt;span class=&quot;nc&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;case&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;ReadByte&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;A&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;](&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;withByteDo&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Byte&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;SocketIO&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;A&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;])&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;extends&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;SocketIO&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;A&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;case&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;WriteByte&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;A&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;](&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;byte&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Byte&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;andThenDo&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;SocketIO&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;A&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;])&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;extends&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;SocketIO&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;A&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Now one can write functions that return &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;SocketIO&lt;/code&gt; values.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;IO&lt;/code&gt; values are no less pure than &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;SocketIO&lt;/code&gt; values—literally the only distinction between them is that, in Haskell, your main function may return an &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;IO&lt;/code&gt; value, and if it does, the data structure will be translated by the Haskell runtime into the side-effects that it models.&lt;/p&gt;

&lt;p&gt;But we could easily do that ourselves for &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;SocketIO&lt;/code&gt;, by having an interpreter that is built on &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;unsafePerformIO&lt;/code&gt;!&lt;/p&gt;

&lt;h2 id=&quot;effect-tracking-1&quot;&gt;Effect Tracking?&lt;/h2&gt;

&lt;p&gt;So effect tracking—the ability to “track effects” in the type system—is a gigantic misnomer, because the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;IO&lt;/code&gt; type does not track side-effects.&lt;/p&gt;

&lt;p&gt;There are no side-effects in Haskell programs (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;unsafePerformIO&lt;/code&gt; and friends notwithstanding).&lt;/p&gt;

&lt;p&gt;There are only data types, some of which model interaction with the outside world. However, even a list of bytes can model interaction with the outside world. In fact, a binary program is nothing more than a list of bytes, which models interaction with the outside world using machine code instruction sets!&lt;/p&gt;

&lt;p&gt;That said, if we ignore the technical sense in which there is no such thing as “effect tracking” in Haskell, can we say that having “tracked effects” is a good reason to use data types like &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;IO&lt;/code&gt;?&lt;/p&gt;

&lt;p&gt;The answer is no, because effect tracking can be done without &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;IO&lt;/code&gt;!&lt;/p&gt;

&lt;h2 id=&quot;effect-tracked-java&quot;&gt;Effect-Tracked Java™&lt;/h2&gt;

&lt;p&gt;If, by &lt;em&gt;effect tracking&lt;/em&gt;, we mean that we can know, looking only at the signature of a function, whether or not the method models or performs side-effects, then allow me to introduce to you &lt;em&gt;Effect-Tracked Java™&lt;/em&gt;!&lt;/p&gt;

&lt;p&gt;In Effect-Tracked Java™ (a feasible thought experiment for now), every method is annotated with either &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@Pure&lt;/code&gt; or &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@Impure&lt;/code&gt;. For example:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;&lt;span class=&quot;nd&quot;&gt;@Impure&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Config&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;loadAppConfig&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;...&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;nd&quot;&gt;@Pure&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Config&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;mergeConfigs&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;defaults:&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Config&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nl&quot;&gt;priority:&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Config&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;...&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Let’s assume that all the “root” methods in the Java standard library, together with JNI methods, have been ascribed these annotations, which are stored in a data file accessible to our build.&lt;/p&gt;

&lt;p&gt;This information allows a “purity” annotation processor, which we would run as part of our build process, to verify that all our annotations are correct.&lt;/p&gt;

&lt;p&gt;For example, if we call &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;System.currentTimeMillis()&lt;/code&gt; inside a function annotated &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@Pure&lt;/code&gt;,  we will get an error, and we will have to fix the error by changing the annotation to &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@Impure&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Presto, instant effect tracking, without esoteric “monads” or any of that pesky functional programming!&lt;/p&gt;

&lt;p&gt;Further, we don’t have to stop at such coarse-grained effect tracking. If we like, we can allow &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@Impure&lt;/code&gt; annotations to introduce labels, which we could mistakenly call “algebras”.&lt;/p&gt;

&lt;p&gt;This would give us (let’s call it) &lt;em&gt;Tagless-Final Effect-Tracked Java™&lt;/em&gt;, which would look something like this:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;&lt;span class=&quot;nd&quot;&gt;@Impure&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;({&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;FileSystemAlgebra&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;EnvironmentVariablesAlgebra&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;})&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Config&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;loadAppConfig&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;...&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;As before, our annotation processor would enforce correctness. So if we accidentally called &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;System.currentTimeMillis()&lt;/code&gt; inside a function annotated &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@Impure()&lt;/code&gt;, we would be forced to change this annotation to &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@Impure({&quot;ClockAlgebra&quot;})&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;With these “improvements”, we could tell not only which methods are pure and impure, but for the impure methods, we could tell which “algebras” they use—and all of this is tracked statically!&lt;/p&gt;

&lt;p&gt;Have we just discovered a way to radically boost developer productivity for all Java developers everywhere?!?&lt;/p&gt;

&lt;p&gt;Read on for my unexpected and totally surprising answer!&lt;/p&gt;

&lt;h2 id=&quot;worthless-effect-tracking&quot;&gt;Worthless Effect Tracking&lt;/h2&gt;

&lt;p&gt;Effect tracking, whether at the coarse or fine-grained level, is simply not commercially valuable. If it were, not only would there exist popular annotation processors for it, but the Java language itself would probably have the feature.&lt;/p&gt;

&lt;p&gt;Instead, while the feature can be found as one of many features in the &lt;a href=&quot;https://checkerframework.org/manual/#purity-checker&quot;&gt;Checker Framework&lt;/a&gt;, it has no commercial traction.&lt;/p&gt;

&lt;p&gt;Moreover, early versions of PureScript used row types to provide statically-checked and fine-grained “effect tracking”, but the feature was &lt;a href=&quot;https://github.com/purescript-deprecated/purescript-eff&quot;&gt;quickly abandoned&lt;/a&gt;, as it provided no commercial value, but rather slowed down feature development without benefit.&lt;/p&gt;

&lt;p&gt;Contrast these results with lambdas (anonymous functions), which have made their way into every programming language because of the unquestionably positive effects they have on productivity.&lt;/p&gt;

&lt;p&gt;It’s my contention that effect tracking is worthless precisely because if a developer has &lt;em&gt;any&lt;/em&gt; idea about what a function is intended to do, then they already know with a high degree of certainty whether or not the function performs side-effects (assuming, of course, they are taught what it means for something to “perform side-effects”).&lt;/p&gt;

&lt;p&gt;No developer who knows what side-effects are is surprised that &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;System.currentTimeMillis()&lt;/code&gt; performs a side-effect, because they already know what the function is intended to do. Indeed, many language features and best practices (as well as IDE features!) are designed &lt;em&gt;precisely&lt;/em&gt; to give developers a better idea of what functions are supposed to do.&lt;/p&gt;

&lt;p&gt;Given a rudimentary understanding of what a function’s purpose, the purity of the function can be predicted with high probability (violations, like &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;java.net.URL#hashCode/equals&lt;/code&gt;, become legendary!). However, given the purity of a function, this information by itself does not convey any useful information on the function’s purpose.&lt;/p&gt;

&lt;p&gt;Stated simply, effect tracking isn’t incredibly useful in practice, because when it matters (and it doesn’t always matter), we already know roughly what functions do, and therefore, whether or not they perform side-effects.&lt;/p&gt;

&lt;p&gt;Whatever benefit effect tracking would have would be overwhelmed by the cost of ceremony and boilerplate—this is doubly-true for the “fine-grained” variants.&lt;/p&gt;

&lt;p&gt;Moreover, even assuming, evidence to the contrary notwithstanding, that effect tracking &lt;em&gt;was&lt;/em&gt; a killer feature, it could be baked into an IDE without any modifications to a language’s syntax or semantics.&lt;/p&gt;

&lt;p&gt;One could imagine clicking on an “interactions” button next to a function, and seeing what external (and side-effecting) systems each function interacts with. A pure tooling solution like this would have only upside, because it would not require mindless and verbose boilerplate and ceremony.&lt;/p&gt;

&lt;h2 id=&quot;why-io&quot;&gt;Why IO?&lt;/h2&gt;

&lt;p&gt;If effect tracking is commercially useless, then why use &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;IO&lt;/code&gt; data types?&lt;/p&gt;

&lt;p&gt;If you’re in Haskell, you don’t have a choice: if you want to get useful work done, then you will use &lt;em&gt;some&lt;/em&gt; model of interaction with the outside world, and it may as well be &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;IO&lt;/code&gt;, which is industry-proven and adopted extensively.&lt;/p&gt;

&lt;p&gt;If you’re in Scala, however, you &lt;em&gt;do&lt;/em&gt; have a choice: you can write plain vanilla Scala code, and perform side-effects anywhere that you want. Or you can grab one of the functional effect systems like &lt;a href=&quot;https://zio.dev&quot;&gt;ZIO&lt;/a&gt;, and create and compose values that &lt;em&gt;model&lt;/em&gt; side-effects instead.&lt;/p&gt;

&lt;p&gt;The greatest reason to use a functional effect system like ZIO is that it makes side-effects &lt;em&gt;first-class values&lt;/em&gt;. Values are things you can accept and return from functions. You can store them in data structures. You can write your own operators, which accept functional effects, and which transform or combine them in custom ways.&lt;/p&gt;

&lt;p&gt;All of these abilities let you make your own control flow structures and factor out kinds of duplication you can’t avoid when you solve problems using side-effecting code (take a look at some of my talks for examples).&lt;/p&gt;

&lt;p&gt;ZIO goes beyond providing first-class effects, and delivers additional valuable features, including:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Highly-scalable fiber-based runtime&lt;/li&gt;
  &lt;li&gt;Resource-safety across asynchronous and concurrent effects&lt;/li&gt;
  &lt;li&gt;Declarative concurrency without locks and condition variables&lt;/li&gt;
  &lt;li&gt;Easy and safe parallelism&lt;/li&gt;
  &lt;li&gt;Context propagation and dependency injection&lt;/li&gt;
  &lt;li&gt;Execution traces that work across async and concurrent boundaries&lt;/li&gt;
  &lt;li&gt;Fiber-dumps that show the runtime graph of your application&lt;/li&gt;
  &lt;li&gt;Powerful operators that allow you to snap together solutions to complex problems quickly&lt;/li&gt;
  &lt;li&gt;Type-safety and user-friendliness&lt;/li&gt;
  &lt;li&gt;Features for making user-land code fully testable&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The real reason for using ZIO or other functional effect &lt;strong&gt;isn’t&lt;/strong&gt; effect tracking: it’s everything else!&lt;/p&gt;

&lt;h2 id=&quot;summary&quot;&gt;Summary&lt;/h2&gt;

&lt;p&gt;Effect tracking isn’t a good reason to use an &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;IO&lt;/code&gt; like data type, in Scala or any other programming language. That’s because effect tracking (which is actually a misnomer!) isn’t commercially useful.&lt;/p&gt;

&lt;p&gt;If we have a vague idea about what functions do, then we generally have a really good idea about whether they perform side-effects, and compiler-enforced effect tracking would add overhead that wouldn’t pay for itself (assuming our only tangible benefit were “effect tracking”). Also, if we wanted effect tracking, we could always obtain the feature with non-invasive tooling, which could give us the same insight into function interactions without overhead.&lt;/p&gt;

&lt;p&gt;Instead, functional effect systems like ZIO (and Haskell’s &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;IO&lt;/code&gt; data type) let us take side-effects and make them more useful, by turning them into values, which we can transform and compose, solving complex problems with easy and type-safe combinators that simply can’t exist for side-effecting statements.&lt;/p&gt;

&lt;p&gt;Beyond this ability, ZIO in particular gives us new superpowers, like easy and safe concurrency, parallelism, resource handling, dependency injection, diagnostic and debugging information, testability, and type-safety.&lt;/p&gt;

&lt;p&gt;In summary, &lt;em&gt;don’t&lt;/em&gt; use ZIO or IO or any functional effect system for effect tracking, because that benefit alone cannot pay for the cost.&lt;/p&gt;

&lt;p&gt;Instead, if you decide to use functional effect systems, then use them to become a more powerful and productive programmer!&lt;/p&gt;

  &lt;p&gt;&lt;a href=&quot;https://degoes.net/articles/no-effect-tracking&quot;&gt;Effect Tracking Is Commercially Worthless&lt;/a&gt; was originally published by John A De Goes at &lt;a href=&quot;https://degoes.net&quot;&gt;John <em>A</em> <strong>De Goes</strong>&lt;/a&gt; on May 03, 2020.&lt;/p&gt;</content>
</entry>


<entry>
  <title type="html"><![CDATA[A Brief History of ZIO]]></title>
  <link rel="alternate" type="text/html" href="https://degoes.net/articles/zio-history" />
  <id>https://degoes.net/articles/zio-history</id>
  <published>2020-04-15T00:00:00-06:00</published>
  <updated>2020-04-15T00:00:00-06:00</updated>
  <author>
    <name>John A De Goes</name>
    <uri>https://degoes.net</uri>
    <email>john@degoes.net</email>
  </author>
  <content type="html">&lt;p&gt;When I &lt;a href=&quot;https://degoes.net/articles/scalaz8-is-the-future&quot;&gt;started&lt;/a&gt; what would eventually become &lt;a href=&quot;https://zio.dev&quot;&gt;ZIO&lt;/a&gt;, my goal was to give Scala a better asynchronous effect system, one that had some of the high-end features of Haskell’s IO monad, including cancellation of running effects and easy concurrency.&lt;/p&gt;

&lt;p&gt;While developing this effect system, I was &lt;a href=&quot;https://gist.github.com/jdegoes/97459c0045f373f4eaf126998d8f65dc&quot;&gt;teaching&lt;/a&gt; a lot of Scala developers functional programming professionally, covering topics like higher-kinded type classes (the functor hierarchy), monad transformers, free monads, and more. In addition, I was traveling the world speaking to Scala developers everywhere (including non-functional programmers), and listening to their feedback on functional programming, even and especially when hostile.&lt;/p&gt;

&lt;p&gt;What I learned from my teaching experience and conversations with developers would radically change my perspective on the practicality of Haskell-style functional programming in Scala.&lt;/p&gt;

&lt;h2 id=&quot;real-world-feedback&quot;&gt;Real World Feedback&lt;/h2&gt;

&lt;p&gt;While live-coding for students, I realized how painful it was to use monad transformers; and how difficult it was to justify all this machinery to do simple things with state and errors.&lt;/p&gt;

&lt;p&gt;Together with my students, I recoiled in horror so many times at just how much type inference you had to sacrifice for higher-kinded types.&lt;/p&gt;

&lt;p&gt;I struggled to justify to skeptical everyday Scala programmers the tangible benefits that developers get from ‘effect-polymorphism’ beyond just testability.&lt;/p&gt;

&lt;p&gt;I learned, both from my experience and the experience of other developers, just how difficult it is for someone who loves functional programming to sell the benefits to someone who does not love functional programming.&lt;/p&gt;

&lt;p&gt;Through these experiences, I came to believe that if functional Scala continued to be &lt;em&gt;Haskell on the JVM&lt;/em&gt;, it would never be particularly relevant for the broader market of programmers who just want to get stuff done.&lt;/p&gt;

&lt;p&gt;These beliefs started to influence the design of ZIO.&lt;/p&gt;

&lt;h2 id=&quot;zio-evolves&quot;&gt;ZIO Evolves&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;No plan of operations extends with any certainty beyond the first contact with the main hostile force
— Helmuth von Moltke the Elder, 1871&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Confronted with the often painful and unsatisfying reality of doing Haskell in Scala—a reality that drove many a functional programmer from Scala to Haskell (notably my friends Tony Morris, Sam Halliday, Emily Pillmore, and many others)—I decided to adapt:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Having seen countless developers struggle with &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;EitherT&lt;/code&gt;, I thought instead of fixing ZIO’s error type to be &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Throwable&lt;/code&gt;, I could make it polymorphic, and eliminate the poor ergonomics of &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;EitherT&lt;/code&gt;. I was very happy with the result, because not only was it very pleasant to use, but you could see at compile-time which parts of your code can fail and which parts can’t, which I found to be a huge boost to productivity and correctness.&lt;/li&gt;
  &lt;li&gt;After a successful small-scale experiment, my friend and co-contributor &lt;a href=&quot;https://twitter.com/wiemzin&quot;&gt;Wiem Zine Elabidine&lt;/a&gt; and I went through and aggressively refactored ZIO to use declaration-site variance everywhere. It was a massive refactoring, and at the time, it was extremely contentious, resulting in a lot of negative feedback. Scalaz and Cats had a philosophy of &lt;em&gt;variance is bad, always avoid it&lt;/em&gt;. Yet after we completed the refactoring, it immeasurably increased the pleasure of using ZIO. For the first time, everything just inferred beautifully, without type annotations. Since then, I’ve even become obsessed with pushing variance to maximize type inference.&lt;/li&gt;
  &lt;li&gt;I started changing names of data types and operators, breaking with decades old Haskell traditions. For example, I renamed &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;point&lt;/code&gt; / &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;pure&lt;/code&gt; to &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ZIO.succeed&lt;/code&gt;, among many other changes. These changes resulted in a lot of negative feedback from functional programmers, culminating most recently in a lot of negative feedback about &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ZIO.foreach&lt;/code&gt;. My belief is not that jargon is useless (it’s essential among trained professionals), but that piggybacking on top of even imprecise domain knowledge can improve the onboarding experience for new developers.&lt;/li&gt;
  &lt;li&gt;I started changing documentation to emphasize practical pain points that developers face. I came to believe that no developer has a pain point called “lack of purity”. But they do have pain points around asynchronous programming; they have pain points around resource safety; they have pain points around concurrency; they have pain points around testability. ZIO’s current marketing focused emerged when the short pitch was changed from &lt;em&gt;a purely functional IO monad&lt;/em&gt; to &lt;em&gt;a library for async &amp;amp; concurrent programming&lt;/em&gt;.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;At the same time, ZIO-specific features like fibers and a pure (and automatic) cancellation model started influencing the design of Cats Effect, and I strongly argued for many changes in Cats Effect, most of which made the 1.0 release of the library (indeed, 1.0 was radically different because of these discussions!).&lt;/p&gt;

&lt;h2 id=&quot;divergence&quot;&gt;Divergence&lt;/h2&gt;

&lt;p&gt;Typed errors put some distance between the Cats Effect type class hierarchy and ZIO. If you wanted to reason about the error behavior of your programs statically, you could not use the Cats Effect type classes, because the type classes have no support for polymorphic errors.&lt;/p&gt;

&lt;p&gt;In addition, a growing number of combinators on the ZIO effect type—combinators that did not exist in Cats Effect, Cats, or anywhere else—made it increasingly painful to restrict oneself to the subset of features supported by Cats Effect.&lt;/p&gt;

&lt;p&gt;These growing seeds of divergence led to more direct use of ZIO among early adopters.&lt;/p&gt;

&lt;h2 id=&quot;zio-environment&quot;&gt;ZIO Environment&lt;/h2&gt;

&lt;p&gt;Early versions of ZIO only had typed errors. But in late 2018, after struggling in a class with the horrid contortions and complex machinery necessary to test functional programs using final-tagless, I had an idea to exploit contravariance to enable Scala to infer intersecting requirements in the composition of multiple effects.&lt;/p&gt;

&lt;p&gt;I prototyped the solution in about a hundred lines of self-contained code, and in a fit of excitement, shared it with &lt;a href=&quot;https://twitter.com/wiemzin&quot;&gt;Wiem&lt;/a&gt;, exclaiming, “This is gonna change things forever!”. Unfortunately, the prototype required a third type parameter; but on the flip side, it enabled a way of testing effectful programs that inferred flawlessly and didn’t require any type classes, implicits, higher-kinded types, or category theory.&lt;/p&gt;

&lt;p&gt;Over the course of two months, &lt;a href=&quot;https://twitter.com/wiemzin&quot;&gt;Wiem&lt;/a&gt; and I introduced the third “environment” type parameter into the ZIO effect type, in a massive refactoring that spanned thousands of lines of code. This moment was the birth of what we know now as &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ZIO&lt;/code&gt;: an effect type capable of propagating errors and successes upward; and propagating dependencies downward—the two primary needs of every functional program ever written!&lt;/p&gt;

&lt;p&gt;I introduced ZIO environment to make testing functional programs easier, which I had come to believe was the only significant, tangible and sellable benefit of tagless-final. However, I quickly discovered that the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;R&lt;/code&gt; type parameter, combined with primitives already in ZIO (such as &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Ref&lt;/code&gt;), provides a way to model state and writer effects. Thus, there was no need for “MTL” anymore, as the principal transformers (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;StateT&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ReaderT&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;WriterT&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ExceptT&lt;/code&gt;) were already totally subsumed in the ZIO effect type.&lt;/p&gt;

&lt;p&gt;Without explicitly trying, ZIO had become an alternative to MTL and even (optionally) tagless-final: only an alternative with excellent performance (something not possible in Scala with monad transformers), perfect type inference, and minimal knowledge prerequisites.&lt;/p&gt;

&lt;p&gt;ZIO had introduced a different way to do functional programming in Scala. One with no jargon, no type classes, no implicits, no higher-kinded types, and no category theory.&lt;/p&gt;

&lt;h2 id=&quot;zio--cats-effect&quot;&gt;ZIO &amp;amp; Cats Effect&lt;/h2&gt;

&lt;p&gt;Despite these achievements, I did not view ZIO as a “competitor” to Cats Effect. I viewed Cats Effect as being primarily about interop between the different effect types through type classes, and I even argued that Cats IO should be a separate project to avoid conflict of interest.&lt;/p&gt;

&lt;p&gt;I wrote about the &lt;a href=&quot;https://degoes.net/articles/zio-cats-effect&quot;&gt;synergy between the projects&lt;/a&gt; and encouraged people to see ZIO as the &lt;em&gt;best implementation&lt;/em&gt; for the Cats Effect type classes, because ZIO has improved semantics on Cats IO.&lt;/p&gt;

&lt;p&gt;Some of the issues with Cats IO include the following:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;An &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;evalOn&lt;/code&gt; implementation that does not work across async shifts and does not have proper error behavior;&lt;/li&gt;
  &lt;li&gt;A lack of fine-grained control over interruption;&lt;/li&gt;
  &lt;li&gt;The creation of “zombie” fibers that permanently hang any fiber that joins them, nullifying resource safety guarantees;&lt;/li&gt;
  &lt;li&gt;Async effects that resume on the caller’s thread pool;&lt;/li&gt;
  &lt;li&gt;Etc.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Despite the synergy, I was quite concerned at the growing difference in expressive power between ZIO and the Cats Effect type classes.&lt;/p&gt;

&lt;p&gt;On the one hand, ZIO defined an effect type with polymorphic (rather than monomorphic) errors, and with built-in polymorphic context propagation; together with improved semantics around interruption, error handling, shifting, and much more. But the Cats Effect type classes were rigidly locked to monofunctor effect types, and with increasingly dated semantics beset by confusing edge cases.&lt;/p&gt;

&lt;h2 id=&quot;life-after-cats-effect&quot;&gt;Life After Cats Effect&lt;/h2&gt;

&lt;p&gt;To narrow the growing gap between ZIO and the Cats Effect type classes, I volunteered to help design the next version of Cats Effect. Toward this end, I sketched out a complete hierarchy and &lt;a href=&quot;https://github.com/typelevel/cats-effect/issues/321#issuecomment-449030858&quot;&gt;submitted it for feedback&lt;/a&gt;, conservatively aiming only to support typed errors, along with fixes for core semantic issues.&lt;/p&gt;

&lt;p&gt;Ultimately, however, I was &lt;a href=&quot;http://web.archive.org/web/20190905210318/https://gist.github.com/djspiewak/39fcf30fc4480abb5096010886558792&quot;&gt;banned by Typelevel&lt;/a&gt; in an elaborate and bizarre &lt;a href=&quot;https://typelevel.org/blog/2019/09/05/jdg.html&quot;&gt;press release&lt;/a&gt; that was &lt;a href=&quot;https://twitter.com/adamwarski/status/1169664500087304192&quot;&gt;widely&lt;/a&gt; &lt;a href=&quot;https://twitter.com/propensive/status/1170098824242782208&quot;&gt;denounced&lt;/a&gt;—allegedly for ‘annoying’ technical debates about the ideal design of the library. Subsequently, my sketch was rejected, although many elements survived in the successor proposal for CE3.&lt;/p&gt;

&lt;p&gt;The realization that Cats Effect would &lt;strong&gt;never&lt;/strong&gt; catch up to ZIO, together with the massive pains of tagless-final, caused a tectonic shift in the market. Pretty soon, developers were building ZIO-specific libraries.&lt;/p&gt;

&lt;p&gt;Many of the developers building these libraries first learned functional programming through ZIO. Mostly, they built these libraries without central coordination or planning or training. They just picked up ZIO by themselves and started building things they needed for production deployment.&lt;/p&gt;

&lt;p&gt;Over time, it became clear to me that ZIO would have its own ecosystem, with a different focus and approach, and populated by a new and growing group of contributors from outside the historical functional Scala community.&lt;/p&gt;

&lt;h2 id=&quot;zio-today&quot;&gt;ZIO Today&lt;/h2&gt;

&lt;p&gt;Today, ZIO is first and foremost a library to help developers build &lt;em&gt;modern applications&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Modern applications are asynchronous and concurrent, and they shouldn’t leak resources, they shouldn’t deadlock, they shouldn’t have race conditions, they should be easily testable, and they should use the Scala type system to catch bugs before they happen.&lt;/p&gt;

&lt;p&gt;ZIO helps you quickly build very powerful and correct applications by playing to the strengths of Scala.&lt;/p&gt;

&lt;p&gt;Yeah, ZIO happens to be purely functional. Yeah, it’s an alternative to MTL. And yeah, even though it still plays well with Cats Effect libraries, it’s increasingly its own thing with its own community and ecosystem.&lt;/p&gt;

&lt;p&gt;But the big picture is about leveraging both functional programming and all the features of Scala (even the parts historically eschewed by functional programmers!) to make Scala developers really happy and really productive.&lt;/p&gt;

&lt;p&gt;If we do that, the rest is just details.&lt;/p&gt;

  &lt;p&gt;&lt;a href=&quot;https://degoes.net/articles/zio-history&quot;&gt;A Brief History of ZIO&lt;/a&gt; was originally published by John A De Goes at &lt;a href=&quot;https://degoes.net&quot;&gt;John <em>A</em> <strong>De Goes</strong>&lt;/a&gt; on April 15, 2020.&lt;/p&gt;</content>
</entry>


<entry>
  <title type="html"><![CDATA[A Developer's Guide to Surviving the Coronapocalypse]]></title>
  <link rel="alternate" type="text/html" href="https://degoes.net/articles/coronapocalypse" />
  <id>https://degoes.net/articles/coronapocalypse</id>
  <published>2020-04-03T00:00:00-06:00</published>
  <updated>2020-04-03T00:00:00-06:00</updated>
  <author>
    <name>John A De Goes</name>
    <uri>https://degoes.net</uri>
    <email>john@degoes.net</email>
  </author>
  <content type="html">&lt;p&gt;The world has changed unimaginably in the past few weeks.&lt;/p&gt;

&lt;p&gt;Watching a show on Netflix last night, I was struck by how everyday events now seem so completely alien: traveling between countries, eating out at restaurants, using subways without face masks.&lt;/p&gt;

&lt;p&gt;That was the world of a few weeks ago. A world that, with each passing day, becomes an ever-receding memory.&lt;/p&gt;

&lt;p&gt;Without question, the COVID-19 pandemic has radically altered the entire world at a speed no generation has ever witnessed—because the world is more interconnected now than at any time in the history of our species.&lt;/p&gt;

&lt;p&gt;This event will affect everyone on the planet. Including every software developer.&lt;/p&gt;

&lt;p&gt;In addition to heavy costs on human life and health, the pandemic will derail careers and cost many tech jobs, as the largest recession in decades begins taking form.&lt;/p&gt;

&lt;p&gt;In this post, I offer my tips to help developers prepare for what’s coming.&lt;/p&gt;

&lt;h2 id=&quot;the-economic-meltdown&quot;&gt;The Economic Meltdown&lt;/h2&gt;

&lt;p&gt;The economic impact of the pandemic started the instant people altered their spending habits. It intensified greatly as countries shut down flights, established curfews, enforced lockdowns, and ordered non-essential retailers to close shop.&lt;/p&gt;

&lt;p&gt;Unlike tech giants like Apple and Google, small-time retailers don’t have the luxury of hoarding profit that they can use to weather economic storms.&lt;/p&gt;

&lt;p&gt;Instead, retailers have significant liabilities, ranging from lease agreements, to employees, to purchase orders, to business loans. Due to competition, they frequently operate at close to margins, which means they are vulnerable to being crushed by negative swings of any significant magnitude or lasting duration.&lt;/p&gt;

&lt;p&gt;Their options for reacting to economic downturns are limited:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Cost cutting measures (principally layoffs)&lt;/li&gt;
  &lt;li&gt;Delaying payments to suppliers&lt;/li&gt;
  &lt;li&gt;Increasing debt&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Relying too much on any of these tactics results in a death spiral; but worse, with the growing recession, the latter two tactics are becoming less viable.&lt;/p&gt;

&lt;p&gt;Retailers are going to be hit hard, and many of them will &lt;em&gt;never&lt;/em&gt; recover.&lt;/p&gt;

&lt;p&gt;National and international chains selling non-essential goods will be forced to cut costs as revenue plummets, which means some tech workers will lose their jobs.&lt;/p&gt;

&lt;p&gt;However, most smaller retailers don’t employ developers. Does that mean developers will be insulated from the recession?&lt;/p&gt;

&lt;p&gt;Not even remotely! The entire economy is interconnected. What happens to some of us affects all of us.&lt;/p&gt;

&lt;p&gt;Retailers leverage B2B software to run their business (inventory management, supply chain management, point-of-sale software, marketing software, and much more), because they don’t have technical resources themselves. Retailers also spend a lot of money on advertising, which sustains massive portions of the freemium tech economy—ranging from search engines to email providers to mobile games to social networks.&lt;/p&gt;

&lt;p&gt;Retailers pay their employees, who spend some portion of their income on consumer web apps, consumer mobile apps, and various other forms of consumption services powered by the tech industry. As these employees lose their jobs, their disposable income drops, which negatively impacts some consumer tech companies.&lt;/p&gt;

&lt;p&gt;Moreover, as the pandemic has raged on, the impact has gone way beyond just retailers. The travel, services, and hospitality industries have already nose-dived—without hope of a near-term recovery—and these industries count in their number not just tech companies like Airbnb, Yelp, Expedia, and many others, but also innumerable software vendors that facilitate logistics, supply chain management, resource planning, and much more.&lt;/p&gt;

&lt;p&gt;The disruption of retail, travel, hospitality, and services will all impact pure-play tech companies, both directly in the ways described above, and also indirectly, as second-level effects ripple throughout the interconnected economy.&lt;/p&gt;

&lt;p&gt;The full economic impact of the pandemic is hard to predict, but it’s manifestly clear that these changes will lead to the loss of many developer jobs.&lt;/p&gt;

&lt;h2 id=&quot;a-survival-strategy&quot;&gt;A Survival Strategy&lt;/h2&gt;

&lt;p&gt;As others have discussed, one can minimize the impact of a recession by maximizing one’s &lt;em&gt;personal runway&lt;/em&gt;, which involves cost-cutting measures (including, potentially, re-location to areas with a lower cost of living).&lt;/p&gt;

&lt;p&gt;Beyond economic preparation, however, I encourage developers to take an active role in their career development, using one or more of the following tactics:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;strong&gt;Orient&lt;/strong&gt;. Develop a model of the effects of the pandemic on hiring and layoffs in different industries.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Focus&lt;/strong&gt;. Don’t let distraction become a liability during the crisis, but rather, turn focus into an asset.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Adapt&lt;/strong&gt;. Modify your unique value proposition as a software engineer so that you become more valuable to your employer.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Improve&lt;/strong&gt;. Improve in-demand knowledge and skills in an effort to differentiate yourself from others.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Innovate&lt;/strong&gt;. If you are so inclined, use your skills as a software developer to help the world through this time.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Don’t Panic&lt;/strong&gt;. Life is full of setbacks, but where there is life, there is hope.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;I’ll expand on these recommendations in the sections that follow.&lt;/p&gt;

&lt;h2 id=&quot;orient&quot;&gt;Orient&lt;/h2&gt;

&lt;p&gt;The pandemic will affect some industries more than others, and your own career risk partially depends on what type of company you work for and what kind of project you work on.&lt;/p&gt;

&lt;p&gt;Some likely candidates for early downsizing:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Products targeting non-essential box-store retail, restaurant, travel, and hospitality industries;&lt;/li&gt;
  &lt;li&gt;Startups without exceptional metrics;&lt;/li&gt;
  &lt;li&gt;Consulting, outsourcing, and development shops that target primarily non-tech companies (excluding the government);&lt;/li&gt;
  &lt;li&gt;Expansion and speculative products and projects inside every industry; if there aren’t existing customers driving significant revenue, or internal users driving significant value, it’s a candidate for cancellation.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Some industries will actually benefit from the pandemic, and could enjoy accelerated hiring, even while companies in other industries are forced to downsize.&lt;/p&gt;

&lt;p&gt;The following types of companies should benefit:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Companies enabling individuals and companies to shift more day-to-day activities to the cloud. For example, companies that facilitate remote collaboration, online retail, fulfillment, delivery, socializing, and so forth.&lt;/li&gt;
  &lt;li&gt;Low-cost entertainment, such as games and streaming films and shows.&lt;/li&gt;
  &lt;li&gt;Low-cost retailers of essential goods, such as groceries, medicine, household consumables.&lt;/li&gt;
  &lt;li&gt;Personal health and fitness materials and supplies, and survival goods.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Though some companies will be downsizing, others will be hiring more developers, providing a source of new jobs to those who have the right knowledge, skills, and experience.&lt;/p&gt;

&lt;h2 id=&quot;focus&quot;&gt;Focus&lt;/h2&gt;

&lt;p&gt;The pandemic has thrust a justly distracted public into remote work environments that they are not properly equipped to deal with, resulting in lower productivity.&lt;/p&gt;

&lt;p&gt;Further affecting productivity is continuous media coverage of the pandemic, including real-time reports on infection rates, early research into treatments and vaccine developments, celebrity hospitalizations and deaths, and endless memes.&lt;/p&gt;

&lt;p&gt;It’s easy to spend hours a day keeping up with what’s going on. While some information is essential, because it can lead to actions that help you improve or save lives, consuming too much news can impact your work productivity.&lt;/p&gt;

&lt;p&gt;In hard times, managers are sometimes asked to rank employees in order of least essential to most essential. These “kill lists” make it easier to cut costs quickly and precisely in response to slashed budgets and cancelled projects.&lt;/p&gt;

&lt;p&gt;When your company does layoffs—and for many companies, it will be &lt;em&gt;when&lt;/em&gt;, not &lt;em&gt;if&lt;/em&gt;—you probably don’t want to be at the top of the kill list, especially in a recession.&lt;/p&gt;

&lt;p&gt;So stay as informed as you need to be, but also stay focused on your career.&lt;/p&gt;

&lt;h2 id=&quot;adapt&quot;&gt;Adapt&lt;/h2&gt;

&lt;p&gt;Hard times change people and they change companies—everyone becomes more risk averse, less open, and more fiscally conservative.&lt;/p&gt;

&lt;p&gt;While companies &lt;em&gt;always&lt;/em&gt; care about the bottom line, a recession of unknown duration and magnitude means there is intense pressure to &lt;em&gt;do more with fewer resources&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Developers who deeply internalize this imperative and adapt will have more successful careers than those that don’t.&lt;/p&gt;

&lt;p&gt;Here are some tangible ways you can adapt to uncertain times:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;Minimize reinvention&lt;/strong&gt;. Many developers love to build rather than reuse, partially because building results in a better solution, and partially because reusing existing solutions is painful due to learning curves and edge cases. Yet, while a booming economy funded extreme reinvention (some companies invented databases, programming languages, query languages, and far more!), a recession demands a frugal use of developer time, and one way to do that is to reuse as much software as possible. &lt;em&gt;Become good at figuring out how to reuse and adapt existing software for new use cases.&lt;/em&gt;&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Maximize productivity&lt;/strong&gt;. Frameworks that are closer to a business problem can allow higher productivity than a random assortment of libraries; cutting the right corners can accelerate time-to-feedback; proven approaches can be less risky than experimental approaches; static type systems and property checking can reduce the need for voluminous hand-written automated tests. &lt;em&gt;Draw from your strengths to help you and your team deliver more value to the business in less time.&lt;/em&gt;&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Minimize expenses&lt;/strong&gt;. Cloud infrastructure and costly web services can add up to hundreds of thousands or millions, even for relatively small companies. There will be increasing pressure to minimize these costs, and to replace high-priced services with those that have low total cost of ownership. &lt;em&gt;Be proactive about these cost-cutting measures, looking for ways to save your company money.&lt;/em&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;improve&quot;&gt;Improve&lt;/h2&gt;

&lt;p&gt;Even in the best of times, the tech industry changes rapidly. Languages, frameworks, libraries, and technologies all rise and fall.&lt;/p&gt;

&lt;p&gt;Beyond constant technological change, the relevancy of every developer’s knowledge and skills changes continuously. Some knowledge and skills that used to be in-demand (such as debugging ActiveX components running in Internet Explorer) become irrelevant.&lt;/p&gt;

&lt;p&gt;Recessions are hard on everyone, but they are especially hard on developers who stagnate.&lt;/p&gt;

&lt;p&gt;In times like these, push yourself to learn more. Shore up your weak skills. And even if you’re lucky enough to have a great employer, don’t count on your employer to invest in your education, because educational budgets won’t last long in a recession.&lt;/p&gt;

&lt;h2 id=&quot;innovate&quot;&gt;Innovate&lt;/h2&gt;

&lt;p&gt;Necessity, as they say, is the mother of invention, and social and economic challenges open new doors to innovation.&lt;/p&gt;

&lt;p&gt;For the very entrepreneurial, as society attempts to survive the pandemic, and then rebuild around new values and modes of interaction, there will be countless opportunities for innovation at every level.&lt;/p&gt;

&lt;p&gt;In the early days, this includes helping individuals be successful working and living in the cloud, and dealing with the devastation wrought by growing unemployment and the recession; and helping smaller businesses transition into a cloud-first mindset.&lt;/p&gt;

&lt;p&gt;Software developers are makers, and as makers, we have the ability to create software that is part of the solution to these problems.&lt;/p&gt;

&lt;p&gt;Beyond just opportunities for product-level innovation, there will be opportunities in the world of open source. There will be demand for new kinds of technologies, and more productive solutions to pervasive and resource-consuming pains.&lt;/p&gt;

&lt;h2 id=&quot;dont-panic&quot;&gt;Don’t Panic&lt;/h2&gt;

&lt;p&gt;No matter how much any of us prepares, there are no guarantees in life—other than death and taxes.&lt;/p&gt;

&lt;p&gt;If you do lose your job, try not to panic: a lot of changes are coming in the world, but for the foreseeable future, the need for skilled software developers remains constant.&lt;/p&gt;

&lt;p&gt;If you pay attention to demand, and are willing and able to adjust your knowledge and skills in response to the changing environment, you &lt;em&gt;will&lt;/em&gt; find a job.&lt;/p&gt;

&lt;h2 id=&quot;summary&quot;&gt;Summary&lt;/h2&gt;

&lt;p&gt;The pandemic has changed the world forever. These changes are rapidly spreading throughout the interconnected global economy, and while early ripples of a growing recession can be felt now, the worst is still ahead.&lt;/p&gt;

&lt;p&gt;Many startups will not survive, and many developers across even some large tech companies will be laid off—not all at once, but in waves, as financial stress propagates from sector to sector, industry to industry, company to company.&lt;/p&gt;

&lt;p&gt;Aside from being frugal, developers can prepare for these changes by being aware of the global economic picture; by staying focused; by adapting to times of scarcity; by improving their knowledge and skills; and, if so inclined, by innovating in areas that they know well.&lt;/p&gt;

&lt;p&gt;Above all, panicking won’t help anyone. Stay calm. It’s going to be painful, and it’s going to take a while, but eventually the economy &lt;em&gt;will&lt;/em&gt; recover.&lt;/p&gt;

  &lt;p&gt;&lt;a href=&quot;https://degoes.net/articles/coronapocalypse&quot;&gt;A Developer's Guide to Surviving the Coronapocalypse&lt;/a&gt; was originally published by John A De Goes at &lt;a href=&quot;https://degoes.net&quot;&gt;John <em>A</em> <strong>De Goes</strong>&lt;/a&gt; on April 03, 2020.&lt;/p&gt;</content>
</entry>


<entry>
  <title type="html"><![CDATA[A Glossary of Functional Programming]]></title>
  <link rel="alternate" type="text/html" href="https://degoes.net/articles/fp-glossary" />
  <id>https://degoes.net/articles/fp-glossary</id>
  <published>2019-12-22T00:00:00-07:00</published>
  <updated>2019-12-22T00:00:00-07:00</updated>
  <author>
    <name>John A De Goes</name>
    <uri>https://degoes.net</uri>
    <email>john@degoes.net</email>
  </author>
  <content type="html">&lt;p&gt;I’ve taught functional programming for years now, each time experimenting with different ways of teaching core concepts. Over time, I’ve collected and converged on simple (but reasonably precise) pedagogical definitions for a range of functional concepts.&lt;/p&gt;

&lt;p&gt;In this post, I’ll share those definitions with you, in my first ever, &lt;em&gt;Glossary of Functional Programming&lt;/em&gt;. Enjoy!&lt;/p&gt;

&lt;h2 id=&quot;glossary&quot;&gt;Glossary&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;Abstraction&lt;/strong&gt;. An &lt;em&gt;abstraction&lt;/em&gt; is a precise description of the ways in which different data types share common structure. Abstraction allows different data types to participate in &lt;em&gt;generic programming&lt;/em&gt;. In functional programming, abstractions are defined by &lt;em&gt;algebraic structure&lt;/em&gt;, and are usually encoded in a programming language using &lt;em&gt;type classes&lt;/em&gt;. Common examples of abstractions include monoids, functors, and monads.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Ad Hoc Polymorphism&lt;/strong&gt;. &lt;em&gt;Ad hoc polymorphism&lt;/em&gt; is any language feature that allows overloading functions and operators (providing multiple implementations for the same symbol) in such a fashion that the compiler or runtime can automatically select which implementation to call based on the types involved in the function application. Examples of ad hoc polymorphism include method overloading and &lt;em&gt;type classes&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Algebra&lt;/strong&gt;. An &lt;em&gt;algebra&lt;/em&gt; is a set of &lt;em&gt;elements&lt;/em&gt; together with a set of &lt;em&gt;operations&lt;/em&gt; on the elements. The operations of an algebra are defined by &lt;em&gt;algebraic laws&lt;/em&gt;, which give the operations meaning by relating them to each other. For example, addition on integers forms a very simple algebra, where the elements are integers, and the sole operation is addition, which satisfies assocative and commutative laws.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Algebraic Data Type (ADT)&lt;/strong&gt;. An &lt;em&gt;algebraic data type&lt;/em&gt; is any data type composed from &lt;em&gt;product types&lt;/em&gt; (records) and &lt;em&gt;sum types&lt;/em&gt; (enumerations). In functional programming, algebraic data types are used for &lt;em&gt;data modeling&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Algebraic Law&lt;/strong&gt;. An &lt;em&gt;algebraic law&lt;/em&gt; is a &lt;em&gt;universally quantified&lt;/em&gt; statement that asserts a relationship between the &lt;em&gt;operations&lt;/em&gt; of an &lt;em&gt;algebra&lt;/em&gt;. For example, an algebraic law for addition could assert that &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;(a + b) + c&lt;/code&gt; is equal to &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;a + (b + c)&lt;/code&gt; (&lt;em&gt;associativity&lt;/em&gt;). In mainstream programming languages, algebraic laws are usually tested using &lt;em&gt;property-based testing&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Algebraic Structure&lt;/strong&gt;. &lt;em&gt;Algebraic structure&lt;/em&gt; is any &lt;em&gt;structure&lt;/em&gt; that is defined using an &lt;em&gt;algebra&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Applicative&lt;/strong&gt;. An &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Applicative&lt;/code&gt; Functor is an &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Apply&lt;/code&gt; Functor that allows taking a value and converting it into a &lt;em&gt;functional effect&lt;/em&gt; that succeeds with the specified value. Under the view of functors as DSLs, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Applicative&lt;/code&gt; adds a “pure return” statement to the DSL.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Apply&lt;/strong&gt;. An &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Apply&lt;/code&gt; Functor is a Functor that allows zipping two &lt;em&gt;functional effects&lt;/em&gt; together, to get a tuple of their successes. Under the view of functors as DSLs, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Apply&lt;/code&gt; adds a way to combine two programs together into one program, and preserve both successes.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Associativity&lt;/strong&gt;. An &lt;em&gt;associative&lt;/em&gt; operator is a binary operator that, when applied to three values, always results in the same value, regardless of the order in which pairwise values are combined. For example, addition on numbers is associative, because for all numbers &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;a&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;b&lt;/code&gt;, and &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;c&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;(a + b) + c&lt;/code&gt; is equal to &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;a + (b + c)&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Category Theory&lt;/strong&gt;. &lt;em&gt;Category theory&lt;/em&gt; is a branch of mathematics that defines mathematical structure using directed labeled graphs (&lt;em&gt;categories&lt;/em&gt;). An alternative to algebraically-defined structure, category theory is a powerful and precise pattern language for mathematics, computer science, and functional programming. Knowledge of category theory is helpful but not necessary for mastery of applied functional programming.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Commutativity&lt;/strong&gt;. A &lt;em&gt;commutative&lt;/em&gt; operator is a binary operator that produces the same result no matter the order of the operands. For example, addition is commutative because &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;a + b&lt;/code&gt; is equal to &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;b + a&lt;/code&gt;, for all numbers &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;a&lt;/code&gt; and &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;b&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Composable&lt;/strong&gt;. An operator is &lt;em&gt;composable&lt;/em&gt; if it can be applied to its own return value. For example, the addition operator is composable with respect to integers, because it returns another integer, which can then be added to other integers. Similarly, the boolean negation operator is composable, because it is possible to negate a boolean value that has itself been negated. Composability allows a small number of operators (which can be reasoned about simply) to have immense expressive power.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Contravariant Functor&lt;/strong&gt;. A &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Contravariant&lt;/code&gt; Functor is a type class that allows transforming the input type to some &lt;em&gt;functional effect&lt;/em&gt; using a function. Contravariant functors are often formed by polymorphic types that accept input (such as functions, or stages in a pipeline).&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Data Modeling&lt;/strong&gt;. &lt;em&gt;Data modeling&lt;/em&gt; is the act of constructing a data model of domain objects (such as people, products, schedules, etc.). A goal of data modeling in statically-typed functional programming is to construct a data model so precise, it is impossible to construct bad data, a process sometimes called, &lt;em&gt;making illegal states unrepresentable&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Declarative Programming&lt;/strong&gt;. &lt;em&gt;Declarative programming&lt;/em&gt; is a style of programming in which solutions are constructed by specifying goals, rather than specifying the sequential steps necessary to achieve these goals (&lt;em&gt;what&lt;/em&gt; instead of &lt;em&gt;how&lt;/em&gt;). Declarative programming is the opposite of imperative programming. Some languages, such as SQL and Datalog, are inherently declarative; but declarative programming can be practiced in any programming language, typically by defining declarative DSLs atop imperative implementations.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Dependency Injection&lt;/strong&gt;. &lt;em&gt;Dependency injection&lt;/em&gt; refers to a framework, library, language feature, or architectural pattern that facilitates threading dependencies throughout an application, and wiring up those dependencies for different scenarios. Dependency injection is one of the primary architectural needs of large-scale, complex applications.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Dependent Typing&lt;/strong&gt;. &lt;em&gt;Dependent typing&lt;/em&gt; is a method of defining types that permits types to depend on values. For example, in dependently typed programming languages, one can define the type of vectors whose length is equal to some value. Examples of dependently typed programming languages include Idris, Coq, and Agda. Dependently typed programming languages allow proving more properties about programs at compile-time, albeit at increased development cost.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Deterministic&lt;/strong&gt;. A &lt;em&gt;deterministic&lt;/em&gt; procedure returns the same output for the same input.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Domain-Specific Language (DSL)&lt;/strong&gt;. A &lt;em&gt;domain-specific language&lt;/em&gt; (DSL) is a “mini-language” that is designed to solve a certain subproblem in an application. In functional programming, DSLs are generally &lt;em&gt;embedded&lt;/em&gt;, which means users of these DSL use data types and operators, defined in the host language, to construct programs in the DSL.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Effect Rotation&lt;/strong&gt;. &lt;em&gt;Effect rotation&lt;/em&gt; refers to the construction of highly polymorphic data types (typically &lt;em&gt;indexed monads&lt;/em&gt;) that simultaneously support multiple &lt;em&gt;functional effects&lt;/em&gt;. Each effect supported by the data type is represented with a different type parameter, and each effect may be introduced or eliminated using certain operations. Effect rotation provides much of the benefit of monad transformers, but with substantially improved performance, and in some languages like Scala, significantly better type inference.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Existential Quantification&lt;/strong&gt;. &lt;em&gt;Existential quantification&lt;/em&gt; asserts that a statement holds for some choice of a given variable. For example, the value &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;list: List[_]&lt;/code&gt; is existentially quantified over the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;List&lt;/code&gt; type parameter, asserting that there exists some (unknown) type that describes the type of elements in the list, without specifying what this type is.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Existential Type&lt;/strong&gt;. An &lt;em&gt;existential type&lt;/em&gt; is a specific, definite type, which is unknown to code interacting with the type. In programming languages, existential types are used to “forget” information that need not be carried around in type parameters. In Scala, abstract type members are always existential types.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Expression&lt;/strong&gt;. An &lt;em&gt;expression&lt;/em&gt; is a value constructed from the application of functions or operators to other values. The parameters to the functions or operators are called the &lt;em&gt;terms&lt;/em&gt; of the expression. For example, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;a + b&lt;/code&gt; is an expression, which computes the result of adding the term &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;a&lt;/code&gt; to the term &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;b&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;F-Algebra&lt;/strong&gt;. An F-algebra is a generalization of algebraic structure that comes from category theory, which makes it possible to represent algebraic laws without universal quantification, using only morphisms. In functional programming, F-algebras appear more directly as interpreters for both tagless-final and free monadic programs (&lt;em&gt;natural transformations&lt;/em&gt;), and as algebras and coalgebras in recursion schemes.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;First-Class&lt;/strong&gt;. &lt;em&gt;First-class&lt;/em&gt; constructs are those which can be created, manipulated, and abstracted over using the most powerful machinery a language exposes for these tasks. For most programming language, &lt;em&gt;first-class&lt;/em&gt; means the construct is a &lt;em&gt;value&lt;/em&gt;. First-class constructs give programmers much more power than second-class constructs. Some constructs which are not first-class can nonetheless be &lt;em&gt;reified&lt;/em&gt; to obtain some of the benefits of being first-class.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Flow analysis&lt;/strong&gt;. Type-directed &lt;em&gt;flow analysis&lt;/em&gt; is a process whereby the flow of information in the declaration of a data type or a function is analyzed using type information alone. Performing flow analysis can yield useful information about the implementation of polymorphic declarations. For example, for a function &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;def foo[A](a: A): A&lt;/code&gt; (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;foo :: a -&amp;gt; a&lt;/code&gt;), one can tell using flow analysis that the output of the function must have come from its single input parameter, because there is no other way for the function to return a value of the polymorphic type.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Free Structure&lt;/strong&gt;. A &lt;em&gt;free structure&lt;/em&gt; is a data structure that &lt;em&gt;reifies&lt;/em&gt; operations of some algebra into a tree-like data structure. Later, the data structure can be traversed, and the operations applied to concrete values—a process called &lt;em&gt;interpretation&lt;/em&gt; of the free structure. An example free structure is &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;List&lt;/code&gt; (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;[]&lt;/code&gt;), which is a free monoid for any type &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;A&lt;/code&gt;; that is, for any type &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;A&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;List[A]&lt;/code&gt; (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;[a]&lt;/code&gt;) provides both a neutral value (the empty list) and an append operation (list concatenation). Another example is &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Free&lt;/code&gt;, which provides a free monad for any type constructor &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;F[_]&lt;/code&gt; (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;f : * -&amp;gt; *&lt;/code&gt;).&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Function&lt;/strong&gt;. A mathematical &lt;em&gt;function&lt;/em&gt; &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;f : A =&amp;gt; B&lt;/code&gt; (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;f :: a -&amp;gt; b&lt;/code&gt;) associates every value in a set &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;A&lt;/code&gt; (called the &lt;em&gt;domain&lt;/em&gt;) with a single value in a set &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;B&lt;/code&gt; (called the &lt;em&gt;codomain&lt;/em&gt;). For a given function, this mapping is static (it does not change). In programming languages, the domains and codomains of value-level functions are types, and all such functions are &lt;em&gt;total&lt;/em&gt; (they map every input to some output), &lt;em&gt;deterministic&lt;/em&gt; (they map the same input to the same output), and &lt;em&gt;pure&lt;/em&gt; (they only map inputs to outputs).&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Functional Effect&lt;/strong&gt;. A &lt;em&gt;functional effect&lt;/em&gt; is an immutable data type that describes (or &lt;em&gt;models&lt;/em&gt;) the computation of one or more values, where the computation may require an additional feature like optionality, logging, access to context (like configuration), errors, state, or input/output. Using effect-specific operations, functional effects can be transformed and composed to model solutions to complex problems out of solutions to smaller problems. The ways of constructing a functional effect, together with the operations on effects of that type, form a DSL, whose capabilities are dictated by the constructors and operations. Frequently, functional effects are &lt;em&gt;run&lt;/em&gt; or &lt;em&gt;interpreted&lt;/em&gt; into plain values or into other functional effects. Common functional effects include &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Option&lt;/code&gt; (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Maybe&lt;/code&gt;), which models missing values; &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Either&lt;/code&gt;, which models failure; and &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ZIO&lt;/code&gt; (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;IO&lt;/code&gt;), which models side-effects, including asynchronous side-effects.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Functional Programming&lt;/strong&gt;. &lt;em&gt;Functional programming&lt;/em&gt; is a style of programming in which solutions are constructed by defining and applying (mathematical) &lt;em&gt;functions&lt;/em&gt;. Many programs are not “purely” functional, but contain parts that are written in a functional style, as well as parts that are written in a procedural style. Functional programming can be practiced in statically-typed as well as untyped programming languages.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Functional-Imperative&lt;/strong&gt;. &lt;em&gt;Functional-imperative&lt;/em&gt; is a hybrid style of programming that uses higher-order functions to embed an imperative model of computation inside functional code. Functional-imperative style relies on &lt;em&gt;monads&lt;/em&gt; or an equally powerful abstraction to represent the stateful sequentiality of imperative computations.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Functor&lt;/strong&gt;. A &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Functor&lt;/code&gt; is a type class that allows &lt;em&gt;mapping&lt;/em&gt; the success value of some &lt;em&gt;functional effect&lt;/em&gt; using a function. Every functor can be regarded as a type of DSL, where the terms in the functor sum type correspond to different instructions in the DSL. Under this view of functors as DSLs, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Functor&lt;/code&gt; provides a way to change the success value of a DSL “program” into some other success value, by applying a specified function.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Generalized Algebraic Data Type (GADTs)&lt;/strong&gt;. &lt;em&gt;Generalized algebraic data types&lt;/em&gt; are polymorphic ADTs whose component types may introduce existential types or impose type equality constraints on specific type parameters. GADTs enable easier modeling and use of type-safe DSLs.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Generic Programming&lt;/strong&gt;. &lt;em&gt;Generic programming&lt;/em&gt; is a style of programming that uses &lt;em&gt;polymorphism&lt;/em&gt; to “forget” irrelevant details about data types, which allows code to be used across many different data types that share common structure. Generic programming can be thought of as defining a “template” that is then specialized to concrete types.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Global Reasoning&lt;/strong&gt;. &lt;em&gt;Global reasoning&lt;/em&gt; is a property of some code wherein the correctness of the code cannot be inferred without considering prior application state or all possible inputs.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Higher-Kinded Types&lt;/strong&gt;. &lt;em&gt;Higher-kinded types&lt;/em&gt;, more precisely called &lt;em&gt;higher-kinded generics&lt;/em&gt;, is a language feature in which type parameters may have a kind higher than &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;*&lt;/code&gt;. The two most mainstream languages with higher-kinded types are &lt;em&gt;Scala&lt;/em&gt; and &lt;em&gt;Haskell&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Higher-Order&lt;/strong&gt;. &lt;em&gt;Higher-order&lt;/em&gt; refers to higher-order functions, which are functions that accept functions as input, or return functions as output. For example, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;map&lt;/code&gt; on a list is a higher-order function, because it accepts a function as one of its parameters; similarly, the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Monad&lt;/code&gt; type class is a higher-order type class, because the kind of its type parameter is &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;(* =&amp;gt; *) =&amp;gt; *&lt;/code&gt;, which is a higher-order type-level function.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Homomorphism&lt;/strong&gt;. &lt;em&gt;Homomorphisms&lt;/em&gt; are a special type of function &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;f : A =&amp;gt; B&lt;/code&gt; that preserve a given &lt;em&gt;algebraic structure&lt;/em&gt;. For example, the square function (which returns its input multiplied by itself) is a semigroup homomorphism, because it preserves, for example, the multiplicative semigroup.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Imperative Programming&lt;/strong&gt;. &lt;em&gt;Imperative programming&lt;/em&gt; is a style of programming in which solutions are constructed from step-by-step instructions, where later instructions can depend on the result of previous instructions. In procedural programming, imperative programming is typically done with side-effecting statements, whereas in functional programming, imperative programming is typically done with &lt;em&gt;monads&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Indexed Monad&lt;/strong&gt;. An &lt;em&gt;indexed monad&lt;/em&gt; is a generalization of &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Monad&lt;/code&gt; for highly polymorphic data types having multiple type parameters, which form ordinary &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Monad&lt;/code&gt; instances for any possible choice of the extra type parameters. Indexed monads allow increased type precision, and allow operations that cannot be expressed with non-indexed monads. Examples of indexed monads included indexed state and &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;RIO&lt;/code&gt; (in Haskell), and &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ZIO&lt;/code&gt; (in Scala).&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Indirection&lt;/strong&gt;. &lt;em&gt;Indirection&lt;/em&gt; is any programming language feature (interfaces, type classes, records of functions, module definitions) that allows multiple implementations of some required functionality to be defined and provided to code that requires these capabilities. Indirection facilitates testability, code reuse, and modularity, both in functional programming, and in other paradigms.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Isomorphism&lt;/strong&gt;. An &lt;em&gt;isomorphism&lt;/em&gt; is an equivalence between two data types that have the same information. An isomorphism is defined by two functions: one to translate from the first data type to the second; and one to translate from the second data type to the first. These functions must satisfy “roundtrip” laws in order for them to form an isomorphism, which demonstrate the two representations contain the same information. In functional programming, many things are considered equal &lt;em&gt;up to isomorphism&lt;/em&gt;. For example, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;(A, Unit)&lt;/code&gt; and &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;A&lt;/code&gt; are &lt;em&gt;equal up to isomorphism&lt;/em&gt;, meaning these two different types have the same information.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Kind&lt;/strong&gt;. A &lt;em&gt;kind&lt;/em&gt; describes the structure of a type or type constructor. Monomorphic types like &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Float&lt;/code&gt; and &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Boolean&lt;/code&gt;, which take no type parameters, belong to the set of all types, which is denoted &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;*&lt;/code&gt; (“star”). Type constructors like &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;List&lt;/code&gt; (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;[]&lt;/code&gt;) and &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Option&lt;/code&gt; (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Maybe&lt;/code&gt;) belong to the set of all type constructors that take one type and return one type, which is denoted &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;* =&amp;gt; *&lt;/code&gt; (“star to star”). All kinds higher than &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;*&lt;/code&gt; are type-level functions, which accept types (or type constructors) and return types. For example, if you give the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;List&lt;/code&gt; type constructor the type &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Boolean&lt;/code&gt;, then you get back the type representing lists of boolean values. The terminology and notation of kinds allow us to talk about the ways in which different types and type constructors are similar or distinct.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Lambda&lt;/strong&gt;. A &lt;em&gt;lambda&lt;/em&gt; is an anonymous function, which is a function value that has no name. Because lambdas are values, lambdas may be passed to functions, and returned from functions. All languages that support functional programming provide a way to encode lambdas.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Lambda Calculus&lt;/strong&gt;. The &lt;em&gt;lambda calculus&lt;/em&gt; is a way of expressing arbitrary computation using only &lt;em&gt;lambdas&lt;/em&gt;. The lambda calculus is an alternative to Turing machines and other calculi of computation, and gives meaning to the term &lt;em&gt;functional programming&lt;/em&gt;. There are many different formulations of the lambda calculus, not just one.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Lenses&lt;/strong&gt;. &lt;em&gt;Lenses&lt;/em&gt; are &lt;em&gt;optics&lt;/em&gt; that allow getting and setting terms in &lt;em&gt;product types&lt;/em&gt;. For example, a lens could allow getting and setting the &lt;em&gt;name&lt;/em&gt; field inside objects of type &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Person&lt;/code&gt;. In the functional context, &lt;em&gt;setting&lt;/em&gt; a term in a product means creating a new modified product, given the new value for the term, and the old product value.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Liskov Substitution Principle&lt;/strong&gt;. The &lt;em&gt;Liskov substitution principle&lt;/em&gt; says that if a function accepts an input of type &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;A&lt;/code&gt;, then it should be valid to pass the function any subtype of &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;A&lt;/code&gt;, without altering the correctness of the function. Similarly, for a function returning an output of type &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;B&lt;/code&gt;, it should be valid for the function to return a subtype of &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;B&lt;/code&gt;. The Liskov substitution principle enables principled reasoning about subtyping.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Local Reasoning&lt;/strong&gt;. &lt;em&gt;Local reasoning&lt;/em&gt; is a property of some code wherein the correctness of the code can be inferred locally under specified assumptions, without considering prior application state or all possible inputs.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Map&lt;/strong&gt;. To &lt;em&gt;map&lt;/em&gt; over a polymorphic data type is to change one type parameter into another type, by specifying a way to transform values of that type. For example, a list of integers can be mapped into a list of strings, by specifying a way to transform an integer into a string. To be well-defined, and to constitute a valid &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Functor&lt;/code&gt;, mapping over any polymorphic data type with an identity function must yield something that is equal to the original value.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Minimal&lt;/strong&gt;. A set of operators is &lt;em&gt;minimal&lt;/em&gt; if there exist no smaller set of orthogonal operators that has the same expressive power.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Modular&lt;/strong&gt;. A factoring of a solution to a problem is &lt;em&gt;modular&lt;/em&gt; when it has been divided into independent concerns called &lt;em&gt;modules&lt;/em&gt;, such that each module knows no more than necessary about other modules. Modularity helps tame the complexity of large-scale software development.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Monad&lt;/strong&gt;. A &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Monad&lt;/code&gt; is an &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Applicative&lt;/code&gt; Functor that allows combining a first &lt;em&gt;functional effect&lt;/em&gt;, together with a function that takes the success value of the first effect and returns a second effect (&lt;em&gt;continuation&lt;/em&gt;). Monads represent the essence of imperative programming: do a first thing, and then do this second thing, which depends on the value computed by the first thing. Under the view of functors as DSLs, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Monad&lt;/code&gt; adds sequential “statements”, where subsequent statements depend on previous ones.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Monad Transformer&lt;/strong&gt;. A &lt;em&gt;monad transformer&lt;/em&gt; is a data type that adds one functional effect atop any other functional effect. For example, the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;OptionT&lt;/code&gt; (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;MaybeT&lt;/code&gt;) monad transformer adds the effect of optionality to any other functional effect. A monad transformer, when “stacked” atop a monad, itself forms a monad, which allows building up large stacks of monad transformers, each layer adding some desired functional effect. Monad transformers have significant performance overhead in languages like Scala. An alternative to monad transformers is &lt;em&gt;effect rotation&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Monoid&lt;/strong&gt;. A monoid is a semigroup equipped with a &lt;em&gt;neutral element&lt;/em&gt; (often called &lt;em&gt;zero&lt;/em&gt;), such that appending the neutral element to any other element (on either side) returns that same element unchanged.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Monomorphic&lt;/strong&gt;. &lt;em&gt;Monomorphic&lt;/em&gt; is the opposite of &lt;em&gt;polymorphic&lt;/em&gt;, and refers to a function that takes no type parameters (instead, all of its inputs are concrete types), or a data type that takes no type parameters (rather, it defined entirely with concrete types).&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Natural Transformation&lt;/strong&gt;. A &lt;em&gt;natural transformation&lt;/em&gt; is any polymorphic function between &lt;em&gt;Functors&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Nominal Typing&lt;/strong&gt;. &lt;em&gt;Nominal typing&lt;/em&gt; is a method of defining types solely based on their names. Two nominal types are equal if and only if they have the same fully-qualified name. Nominal typing stands in contrast to &lt;em&gt;structural typing&lt;/em&gt;, in which two types that have different names but the same structure are regarded as the same.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Onion Architecture&lt;/strong&gt;. &lt;em&gt;Onion architecture&lt;/em&gt; is a method of architecting programs that involves gradually translating business logic into lower-layer levels, until at the edges of the application, logic is translated into system calls. Applications written in the onion architecture bear similarities with multi-staged compilers, where every layer of the onion contains DSLs that are “compiled” into other DSLs.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Optics&lt;/strong&gt;. &lt;em&gt;Optics&lt;/em&gt; are &lt;em&gt;values&lt;/em&gt; that allow getting and setting smaller parts of a larger data structure, in a purely functional way. In the functional context, &lt;em&gt;setting&lt;/em&gt; means to produce a new copy from an old copy, with some modification applied. Optics allow zooming into small parts of very large structures, and making pinpoint modifications, without having to deal with all the boilerplate involved in deconstructing and reconstructing every level of the data structure.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Orthogonal&lt;/strong&gt;. Roughly speaking, a set of operators is &lt;em&gt;orthogonal&lt;/em&gt; when no operator performs the function of any other operator. This is the functional programming analogue of &lt;em&gt;Single Responsibility Principle&lt;/em&gt; (SRP). More precisely, a set of operators &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;S&lt;/code&gt; is &lt;em&gt;orthogonal&lt;/em&gt; if there exists no other factoring of the operators &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;S1&lt;/code&gt; such that any operator in &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;S&lt;/code&gt; can be expressed as a composition of two or more operators in &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;S1&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Parametric Polymorphism&lt;/strong&gt;. Sometimes called &lt;em&gt;generics&lt;/em&gt;, &lt;em&gt;parametric polymorphism&lt;/em&gt; is a feature of some programming languages that allows &lt;em&gt;universally quantifying&lt;/em&gt; a function or a data type over one or more type parameters. Such &lt;em&gt;polymorphic functions&lt;/em&gt; and &lt;em&gt;polymorphic data types&lt;/em&gt; are said to be &lt;em&gt;parameterized&lt;/em&gt; by their type parameters. Parametric polymorphism allows the creation of generic code, which works across many different data types, and generic data types, like collections. Parametrically polymorphic code must behave uniformly across all choice of type parameters, which allows a powerful way of reasoning about such code called &lt;em&gt;parametric reasoning&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Parametric Reasoning&lt;/strong&gt;. &lt;em&gt;Parametric reasoning&lt;/em&gt; is a type of reasoning that enables one to state facts about an implementation of a polymorphic function or polymorphic data type based only on type signatures. Parametric reasoning is typically accomplished using &lt;em&gt;flow analysis&lt;/em&gt; on polymorphic declarations.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Partial Function&lt;/strong&gt;. A &lt;em&gt;partial function&lt;/em&gt; is a function that is only defined for a subset of its domain. Partial functions can be modeled as total functions by expanding the codomain to include at least one new value, which indicates the function does not handle some input.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Polymorphism&lt;/strong&gt;. &lt;em&gt;Polymorphism&lt;/em&gt; is a feature of programming languages that allows a variable or function to take on many different forms. Common types of polymorphism include &lt;em&gt;parametric polymorphism&lt;/em&gt;, &lt;em&gt;subtype polymorphism&lt;/em&gt;, and &lt;em&gt;ad hoc polymorphism&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Prisms&lt;/strong&gt;. &lt;em&gt;Prisms&lt;/em&gt; are &lt;em&gt;optics&lt;/em&gt; that allow getting and setting terms in &lt;em&gt;sum types&lt;/em&gt;. For example, a prism could allow getting and setting the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Left&lt;/code&gt; term inside objects of type &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Either[A, B]&lt;/code&gt; (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Either a b&lt;/code&gt;). In the functional context, &lt;em&gt;setting&lt;/em&gt; a term in a sum means creating a new sum, given the new value for the term.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Procedures&lt;/strong&gt;. In programming languages, &lt;em&gt;procedures&lt;/em&gt; are named entities that contain ordered sets of instructions for a machine to perform. Usually called &lt;em&gt;functions&lt;/em&gt;, &lt;em&gt;procedures&lt;/em&gt;, or &lt;em&gt;subroutines&lt;/em&gt; in common parlance, procedures are not necessarily &lt;em&gt;functions&lt;/em&gt; in the mathematical sense of the word, although all mathematical functions on values constitute valid procedures.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Procedural Programming&lt;/strong&gt;. &lt;em&gt;Procedural programming&lt;/em&gt; is a style of programming in which solutions are constructed from the construction and invocation of procedures. All procedural programming is &lt;em&gt;imperative&lt;/em&gt; in nature, although not all imperative programming is &lt;em&gt;procedural&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Product Type&lt;/strong&gt;. A &lt;em&gt;product type&lt;/em&gt; is the composition of &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;n&lt;/code&gt; types, referred to as the &lt;em&gt;terms&lt;/em&gt; of the product, together into a new type, such that a value of the product type contains a value from each of its terms. Structs, classes, records, and tuples are all examples of product types. A table is also an example of a product type, because each row in a table contains a value from each of its columns.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Profunctor&lt;/strong&gt;. A &lt;em&gt;profunctor&lt;/em&gt; is type class defined over type constructors of two type parameters that describes polymorphic data types that form a &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Functor&lt;/code&gt; in one type parameter, and a &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Contravariant&lt;/code&gt; Functor in the other type parameter. Functions are examples of profunctors, which can be mapped on the output channel, and contramapped on the input channel. Profunctors can be thought of as a generalization of functions, which accept input and produce output, but most profunctors are not functions.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Projection&lt;/strong&gt;. A &lt;em&gt;projection&lt;/em&gt; is a “lossy” mapping from one set to another set, such that if applied again to the output of itself, returns an equivalent result. An example is pulling the &lt;em&gt;age&lt;/em&gt; field out of a &lt;em&gt;Person&lt;/em&gt;, in which case repeated application produces the same &lt;em&gt;age&lt;/em&gt; field. All extractions of terms from product types can be regarded as projections.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Property-based Testing&lt;/strong&gt;. &lt;em&gt;Property-based testing&lt;/em&gt; is a method of testing &lt;em&gt;algebraic laws&lt;/em&gt; by pseudo-randomly generating example values, and testing to see if the laws are satisfied. For example, property-testing could generate many integers &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;a&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;b&lt;/code&gt;, and &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;c&lt;/code&gt; to check if &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;(a + b) + c&lt;/code&gt; is equal to &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;a + (b + c)&lt;/code&gt;. Property-based testing cannot &lt;em&gt;prove&lt;/em&gt; laws, but it can disprove them, as well as ensure there are no trivial law violations.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Pure&lt;/strong&gt;. A &lt;em&gt;pure&lt;/em&gt; procedure combines inputs into an output, and does not interact with the world outside the function in any way that can be observed. All pure procedures are &lt;em&gt;deterministic&lt;/em&gt;, but not all &lt;em&gt;deterministic&lt;/em&gt; procedures are pure.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Record&lt;/strong&gt;. A &lt;em&gt;record&lt;/em&gt; contains &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;n&lt;/code&gt; fields, each accessed with some &lt;em&gt;label&lt;/em&gt;, called the &lt;em&gt;name&lt;/em&gt; of the field, and each with some associated type. All records are product types, although not all product types are records (for example, terms of tuples are accessed by ordinal values, not names).&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Recursive Data&lt;/strong&gt;. &lt;em&gt;Recursive data&lt;/em&gt; is any data type that appears as a value somewhere inside the data type. Common examples of recursive data include linked-lists and trees.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Recursive Functions&lt;/strong&gt;. &lt;em&gt;Recursive functions&lt;/em&gt; are functions that call themselves. In functional programming, recursive functions allow iteration, like processing elements in a list or accepting socket connections.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Recursion Schemes&lt;/strong&gt;. &lt;em&gt;Recursions schemes&lt;/em&gt; refers to any of the many different ways to traverse recursive data types, such as folding (catamorphisms) or unfolding (anamorphisms). Typically &lt;em&gt;recursion schemes&lt;/em&gt; refers to the use of fixed-point data types to factor out recursion from data types, and minimize the boilerplate involved in creating different recursion schemes for different recursive data types. However, fundamentally, any recursive data type can be constructed, deconstructed, and transformed in any of the different schemes.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Referential Transparency&lt;/strong&gt;. &lt;em&gt;Referential transparency&lt;/em&gt; is a property of functional programs in which any expression may be replaced by the value it computes without changing the behavior of the program. Referential transparency allows refactoring programs without changing their behavior, and is necessary (but not sufficient) for &lt;em&gt;local reasoning&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Reified&lt;/strong&gt;. A &lt;em&gt;reified&lt;/em&gt; construct is some non-value construct (such as a type, a field, or a package) that has been represented as a value. For example, reified generics store the type of generic type parameters as values at runtime. Similarly, lenses are a type of reified field, which provide a way to treat a field of a record as a first-class value, which can be passed around, stored, and transformed.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Semigroup&lt;/strong&gt;. A &lt;em&gt;semigroup&lt;/em&gt; is a type class with a single binary operator, often called &lt;em&gt;append&lt;/em&gt; or &lt;em&gt;combine&lt;/em&gt;, that is &lt;em&gt;assocative&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Side-Effect&lt;/strong&gt;. A &lt;em&gt;side-effect&lt;/em&gt; occurs when evaluation of an expression does anything more than computing a value. Side-effects are interactions that can be observed from outside a procedure or expression. Common side-effects include database access, file access, network access, system calls, modifying mutable memory, or calling procedures that do any of the above.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;State&lt;/strong&gt;. &lt;em&gt;State&lt;/em&gt; refers to any data that is used to iteratively process information, either in a loop, or using recursion.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Structural Typing&lt;/strong&gt;. &lt;em&gt;Structural typing&lt;/em&gt; is a method of defining types solely based on their structure. Two structural types are equal if and only if they have the same structure. Structural typing stands in contrast to &lt;em&gt;nominal typing&lt;/em&gt;, in which two types that have the same structure are regarded as different if they have different names.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Structure&lt;/strong&gt;. The &lt;em&gt;structure&lt;/em&gt; of a data type is the set of statements we know to be true about the data type. Parametrically polymorphic types (as well as &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Any&lt;/code&gt; in Scala) have &lt;em&gt;no&lt;/em&gt; structure, but we can add structure by requiring these types have &lt;em&gt;instances&lt;/em&gt; for one or more &lt;em&gt;type classes&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Subtyping&lt;/strong&gt;. &lt;em&gt;Subtyping&lt;/em&gt; is a method of defining types that permits “subset” relations, where one type is defined to be a subset or superset of another type. For example, all dogs are animals, and a type system with subtyping can recognize the fact that a &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Dog&lt;/code&gt; type is a subset of an &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Animal&lt;/code&gt; type.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Sum Type&lt;/strong&gt;. A &lt;em&gt;sum type&lt;/em&gt; is the composition of &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;n&lt;/code&gt; types together in an enumeration type, where each case of the enumeration is referred to as a &lt;em&gt;term&lt;/em&gt; in the sum type. A value from a sum type contains a value from exactly one of its terms. For example, a value of a &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Suite&lt;/code&gt; enumeration is either &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Hearts&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Diamonds&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Spades&lt;/code&gt;, or &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Clubs&lt;/code&gt;. In Scala 2.x, enumerations are emulated with &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;sealed trait&lt;/code&gt;, where the terms of the sum type are subtypes of the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;sealed trait&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Tagless-Final&lt;/strong&gt;. &lt;em&gt;Tagless-final&lt;/em&gt; refers to a way of encoding the interpretation of a DSL using parametric polymorphism. In tagless-final, code written in a DSL is polymorphic in the data type used for interpretation. This polymorphic code is interpreted in different ways by instantiating it to concrete evaluation types. In Scala, &lt;em&gt;tagless-final&lt;/em&gt; refers almost exclusively to using &lt;em&gt;indirection&lt;/em&gt; to provide ad hoc operations across polymorphic effect types.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Total&lt;/strong&gt;. A &lt;em&gt;total&lt;/em&gt; procedure returns an output for every input. Total procedures, unlike partial procedures, always terminate, and they never throw exceptions.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Traversals&lt;/strong&gt;. &lt;em&gt;Traversals&lt;/em&gt; are &lt;em&gt;optics&lt;/em&gt; that allow getting and setting elements in collection-like data structures.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Type&lt;/strong&gt;. A &lt;em&gt;type&lt;/em&gt; is information that exists at compile-time, stored in the computer’s memory as the program is compiling. Types are used by the compiler to describe the structure of variables and functions, to ensure programs are well-defined and consistent. Informally, a type can be regarded as a mathematical set of values; the type &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Boolean&lt;/code&gt;, for example, contains the values &lt;em&gt;true&lt;/em&gt; and &lt;em&gt;false&lt;/em&gt;. To ascribe a variable a type in a programming language is to assert the value is a member of the set described by the type, and the act of constructing such a value can be regarded as a proof that the assertion is correct.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Type Class&lt;/strong&gt;. A &lt;em&gt;type class&lt;/em&gt; is a language-level encoding of an &lt;em&gt;abstraction&lt;/em&gt;. Type classes can be viewed as functions from some type to an &lt;em&gt;algebraic structure&lt;/em&gt; for that type. For example, an &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Ord&lt;/code&gt; type class might encode the algebraic structure of total ordering, and might allow us to access ordering operations for types that have this algebraic structure.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Type Constructors&lt;/strong&gt;. A &lt;em&gt;type constructor&lt;/em&gt; is a type that is itself parameterized by other types. To construct a type, the type constructor must be &lt;em&gt;fully applied&lt;/em&gt; to all of its parameters, which then results in a type. For example, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;List&lt;/code&gt; (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;[]&lt;/code&gt;) is a type constructor. Given a type, such as &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Int&lt;/code&gt; (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Integer&lt;/code&gt;), then “passing” that type to the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;List&lt;/code&gt; type constructor then constructs a type: namely, the type of lists with that specified element type. The structure of a type constructor is described by its &lt;em&gt;kind&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Universal Quantification&lt;/strong&gt;. &lt;em&gt;Universal quantification&lt;/em&gt; asserts that a statement holds for all possible choices of a given variable. All &lt;em&gt;parametrically polymorphic&lt;/em&gt; functions and data types universally quantify over their type parameters, asserting the function or data type has an implementation for all possible choices of the type parameters. For example, the function &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;def empty[A]: List[A]&lt;/code&gt; (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;empty :: [a]&lt;/code&gt;) universally quantifies over the type parameter &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;A&lt;/code&gt;, asserting that for any element type, the function can produce a list of that element type (namely, the empty list).&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Universal Type&lt;/strong&gt;. A &lt;em&gt;universal type&lt;/em&gt; is any type variable used in &lt;em&gt;univeral quantification&lt;/em&gt;. In programming languages, universal types are introduced by &lt;em&gt;parametrically polymorphic&lt;/em&gt; function and data type declarations.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Value&lt;/strong&gt;. A &lt;em&gt;value&lt;/em&gt; is information that exists at runtime, stored in the computer’s memory as the program is executing. Values are used to hold and transmit information within a program, and across process boundaries, to the operating system, file system, network, and beyond. In programming languages, values are constructed from literals or from &lt;em&gt;expressions&lt;/em&gt;.&lt;/p&gt;

&lt;h2 id=&quot;faq&quot;&gt;FAQ&lt;/h2&gt;

&lt;p&gt;&lt;em&gt;Question&lt;/em&gt;: Can you define some other term that I find confusing?&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Answer&lt;/em&gt;: Sure, send it on and I’ll add it to the glossary!&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Question&lt;/em&gt;: Wikipedia doesn’t agree with your definitions.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Answer&lt;/em&gt;: Oh no!&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Question&lt;/em&gt;: I don’t agree with your definitions.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Answer&lt;/em&gt;: Ok.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Question&lt;/em&gt;: Change your definitions to what I want!&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Answer&lt;/em&gt;: Nope. But if you have ideas to improve these definitions, please share your feedback!&lt;/p&gt;

  &lt;p&gt;&lt;a href=&quot;https://degoes.net/articles/fp-glossary&quot;&gt;A Glossary of Functional Programming&lt;/a&gt; was originally published by John A De Goes at &lt;a href=&quot;https://degoes.net&quot;&gt;John <em>A</em> <strong>De Goes</strong>&lt;/a&gt; on December 22, 2019.&lt;/p&gt;</content>
</entry>


<entry>
  <title type="html"><![CDATA[The False Hope of Managing Effects with Tagless-Final in Scala]]></title>
  <link rel="alternate" type="text/html" href="https://degoes.net/articles/tagless-horror" />
  <id>https://degoes.net/articles/tagless-horror</id>
  <published>2019-06-18T00:00:00-06:00</published>
  <updated>2019-06-18T00:00:00-06:00</updated>
  <author>
    <name>John A De Goes</name>
    <uri>https://degoes.net</uri>
    <email>john@degoes.net</email>
  </author>
  <content type="html">&lt;p&gt;Tagless-final is a technique originally used to &lt;a href=&quot;https://okmij.org/ftp/tagless-final/index.html&quot;&gt;embed domain-specific languages&lt;/a&gt; into a host language, without the use of Generalized Algebraic Data Types.&lt;/p&gt;

&lt;p&gt;In the Haskell community, &lt;em&gt;tagless-final&lt;/em&gt; still refers to a way of creating polymorphic programs in a custom DSL that are interpreted by instantiating them to a concrete data type. In the Scala community, however, tagless-final is used almost exclusively for monadic, effectful DSLs. Usage of the term in Scala is closest to what Haskeller’s mean by &lt;em&gt;MTL-style&lt;/em&gt;, but without the algebraic laws that govern MTL type classes.&lt;/p&gt;

&lt;p&gt;In Scala, tagless-final has become almost synonymous with types of kind &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;* -&amp;gt; *&lt;/code&gt;, leading to the infamous &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;F[_]&lt;/code&gt; higher-kinded type parameter that is so pervasively associated with the phrase &lt;em&gt;tagless-final&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;In this post, I will argue that the many claims made about tagless-final in Scala are not &lt;em&gt;entirely&lt;/em&gt; true, and that the actual benefits of tagless-final come mostly from &lt;em&gt;discipline&lt;/em&gt;, not from so-called &lt;em&gt;effect polymorphism&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;After this detailed analysis, I will conclude the post by providing a list of concrete recommendations for developers who are building functional Scala libraries and applications.&lt;/p&gt;

&lt;h2 id=&quot;tagless-final-101&quot;&gt;Tagless-Final 101&lt;/h2&gt;

&lt;p&gt;In Scala, tagless-final involves creating &lt;em&gt;type classes&lt;/em&gt;, which describe capabilities of a generic effect &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;F[_]&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Note: There is an alternate, and (I’d argue) superior encoding of tagless-final that involves not type classes, but effect-polymorphic interfaces, which are passed as ordinary parameters; but this alternate encoding doesn’t substantially change my arguments, so I won’t discuss it here.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;For example, we can create the following type class to describe console-related capabilities of some effect &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;F[_]&lt;/code&gt;:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-scala&quot; data-lang=&quot;scala&quot;&gt;&lt;span class=&quot;k&quot;&gt;trait&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Console&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;F&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;_&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;putStrLn&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;line&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;F&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;Unit&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt; 
  &lt;span class=&quot;k&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;getStrLn&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;F&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Or, we could create the following type class to describe persistence capabilities for &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;User&lt;/code&gt; objects:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-scala&quot; data-lang=&quot;scala&quot;&gt;&lt;span class=&quot;k&quot;&gt;trait&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;UserRepository&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;F&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;_&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;getUserById&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;id&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;UserID&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;F&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;User&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt;

  &lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;getUserProfile&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;user&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;User&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;F&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;UserProfile&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt; 

  &lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;updateUserProfile&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;user&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;User&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;profile&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;UserProfile&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;F&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;Unit&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;These type classes allow us to create methods that are &lt;em&gt;polymorphic&lt;/em&gt; in the effect type &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;F[_]&lt;/code&gt;, but which have access to required capabilities. For example, we could describe a program that uses the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Console&lt;/code&gt; interface as follows:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-scala&quot; data-lang=&quot;scala&quot;&gt;&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;consoleProgram&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;F&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;_&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Console&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;F&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;Unit&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;=&lt;/span&gt; 
  &lt;span class=&quot;n&quot;&gt;implicitly&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;Console&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;F&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]].&lt;/span&gt;&lt;span class=&quot;py&quot;&gt;putStrLn&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Hello World!&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Combined with type classes like &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Monad&lt;/code&gt; (which allows chaining effects), we can build entire programs using the tagless-final approach:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-scala&quot; data-lang=&quot;scala&quot;&gt;&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;consoleProgram&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;F&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;_&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Console:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Monad&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;F&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;console&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;implicitly&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;Console&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;F&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]]&lt;/span&gt;

  &lt;span class=&quot;k&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;console._&lt;/span&gt;

  &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;_&lt;/span&gt;     &lt;span class=&quot;k&quot;&gt;&amp;lt;-&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;putStrLn&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;What is your name?&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;name&lt;/span&gt;  &lt;span class=&quot;k&quot;&gt;&amp;lt;-&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;getStrLn&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;_&lt;/span&gt;     &lt;span class=&quot;k&quot;&gt;&amp;lt;-&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;putStrLn&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Hello, $name, good to meet you!&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;yield&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;name&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Because such programs are polymorphic in the effect type &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;F[_]&lt;/code&gt;, we can &lt;em&gt;instantiate&lt;/em&gt; these polymorphic programs to any concrete effect type that provides whatever they require.&lt;/p&gt;

&lt;p&gt;For example, if we are using ZIO &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Task&lt;/code&gt; (a type alias for &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ZIO[Any, Throwable, A]&lt;/code&gt;), we can instantiate our program to this concrete effect type with the following code snippet:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-scala&quot; data-lang=&quot;scala&quot;&gt;&lt;span class=&quot;k&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;taskProgram&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Task&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;consoleProgram&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;Task&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Typically, the &lt;em&gt;instantiation&lt;/em&gt; of a polymorphic tagless-final value to a concrete effect type is deferred as long as possible, preferrably to the entry points of the application or test suite.&lt;/p&gt;

&lt;p&gt;With this introduction, let’s talk about the reasons you might want to use tagless-final…the &lt;em&gt;pitch&lt;/em&gt; for the tagless-final technique, if you will.&lt;/p&gt;

&lt;h2 id=&quot;the-pitch-for-tagless-final&quot;&gt;The Pitch for Tagless-Final&lt;/h2&gt;

&lt;p&gt;Tagless-final has a seductive pitch that appeals to every aspiring functional programmer.&lt;/p&gt;

&lt;p&gt;In the functional programming community, we are taught (with good reason) that monomorphic code can’t be reused much, and leads to more bugs.&lt;/p&gt;

&lt;p&gt;We are taught that generic code not only enables reuse, but it pushes more information into the types, where the compiler can help us verify and maintain correctness.&lt;/p&gt;

&lt;p&gt;We are taught the &lt;em&gt;principle of least power&lt;/em&gt;, which tells us that our functions should require as little as necessary to do their job.&lt;/p&gt;

&lt;p&gt;I have helped develop, motivate, and teach these and other principles in my &lt;em&gt;Functional Scala&lt;/em&gt; workshops, helping train new generations of Scala developers in the functional way of thinking and developing software.&lt;/p&gt;

&lt;p&gt;In this context, functional programmers are &lt;em&gt;primed&lt;/em&gt; for the tagless-final pitch; I know this, because I have &lt;em&gt;given&lt;/em&gt; the tagless-final pitch, and even helped &lt;em&gt;craft&lt;/em&gt; its modern day incarnation.&lt;/p&gt;

&lt;p&gt;In one video, I unintentionally convinced &lt;a href=&quot;https://www.youtube.com/watch?v=sxudIMiOo68&quot;&gt;several companies to adopt tagless-final&lt;/a&gt;, despite an explicit disclaimer stating the techniques would be overkill for many applications!&lt;/p&gt;

&lt;p&gt;In the next few sections, I’m going to give you this pitch, and try to convince you that tagless-final is the best thing ever. Moreover, I’m going to use only arguments that have an element of truth.&lt;/p&gt;

&lt;p&gt;Ready? Here we go!&lt;/p&gt;

&lt;h3 id=&quot;1-effect-type-indirection&quot;&gt;1. Effect Type Indirection&lt;/h3&gt;

&lt;p&gt;As of this writing, there are &lt;a href=&quot;/articles/zio-cats-effect&quot;&gt;several mainstream effect types&lt;/a&gt;, including ZIO, Monix, and Cats IO, all of which ship with &lt;a href=&quot;https://github.com/typelevel/cats-effect&quot;&gt;Cats Effect&lt;/a&gt; instances, and which can be used more or less interchangeably in libraries like FS2, Doobie, and http4s.&lt;/p&gt;

&lt;p&gt;Tagless-final lets you insulate your code from the decision of &lt;em&gt;which&lt;/em&gt; effect type to use. Rather than pick one of these concrete implementations, using tagless-final lets you write &lt;em&gt;effect type-agnostic&lt;/em&gt; code, which can be &lt;em&gt;instantiated&lt;/em&gt; to any concrete effect type that provides Cats Effect instances.&lt;/p&gt;

&lt;p&gt;For example, our preceding console program can just as easily be instantiated to Cats IO:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-scala&quot; data-lang=&quot;scala&quot;&gt;&lt;span class=&quot;k&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;ioProgram&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;consoleProgram&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;cats.effect.IO&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;With tagless-final, you can defer the decision of which effect type to use &lt;em&gt;indefinitely&lt;/em&gt; (or at least, to the edge of your program), isolating your application from changes in an evolving ecosystem.&lt;/p&gt;

&lt;p&gt;Tagless-final lets you future-proof your code!&lt;/p&gt;

&lt;h3 id=&quot;2-effect-testability&quot;&gt;2. Effect Testability&lt;/h3&gt;

&lt;p&gt;Tagless-final, because it provides a strong layer of indirection between your application, and the concrete effect type that models effects, enables your code to be fully testable.&lt;/p&gt;

&lt;p&gt;In the preceding console implementation, it is easy to define a test instance of the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Console&lt;/code&gt; type class:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-scala&quot; data-lang=&quot;scala&quot;&gt;&lt;span class=&quot;k&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;case&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;ConsoleData&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;input&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;List&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;],&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;output&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;List&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;])&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;case&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;ConsoleTest&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;A&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;](&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;run&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;ConsoleData&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;ConsoleData&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;A&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;))&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;object&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;ConsoleTest&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;implicit&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;ConsoleConsoleTest&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Console&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;ConsoleTest&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Console&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;ConsoleTest&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt; 
    &lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;putStrLn&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;line&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;ConsoleTest&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;Unit&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;=&lt;/span&gt; 
      &lt;span class=&quot;nc&quot;&gt;ConsoleTest&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;data&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;py&quot;&gt;copy&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;output&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;line&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;::&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;py&quot;&gt;output&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;),&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;()))&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;getStrLn&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;ConsoleTest&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;=&lt;/span&gt;
      &lt;span class=&quot;nc&quot;&gt;ConsoleTest&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;data&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;py&quot;&gt;copy&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;input&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;py&quot;&gt;input&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;py&quot;&gt;drop&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)),&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;py&quot;&gt;input&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;py&quot;&gt;head&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;))&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Now, assuming we define an appropriate &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Monad&lt;/code&gt; instance for our data type (which is easy to do!), we can instantiate our polymorphic &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;consoleProgram&lt;/code&gt; to the new type:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-scala&quot; data-lang=&quot;scala&quot;&gt;&lt;span class=&quot;k&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;testProgram&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;consoleProgram&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;ConsoleTest&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Tada! We can now unit test our console program with fast, deterministic unit tests, thereby reaping the full testability benefits of pure functional programming.&lt;/p&gt;

&lt;h3 id=&quot;3-effect-parametric-reasoning&quot;&gt;3. Effect Parametric Reasoning&lt;/h3&gt;

&lt;p&gt;&lt;em&gt;Parametric reasoning&lt;/em&gt; in statically-typed functional programming circles refers to the ability for us to reason generically about the implementation of a polymorphic function merely by looking at its type.&lt;/p&gt;

&lt;p&gt;For example, there is one possible implementation of the following function:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-scala&quot; data-lang=&quot;scala&quot;&gt;&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;identity&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;A&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;](&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;A&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;A&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;???&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;(Assuming no reflection, exceptions, or use of &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;null&lt;/code&gt;.)&lt;/p&gt;

&lt;p&gt;Parametric reasoning allows us to save time when we are studying code. We can look at the types of a function, and even if we don’t know the exact implementation, we can place &lt;em&gt;bounds&lt;/em&gt; on what the function can do.&lt;/p&gt;

&lt;p&gt;Parametric reasoning lets us more quickly and more reliably understand code bases, which is critical for safe maintenance of those code bases in response to new and changing business requirements.&lt;/p&gt;

&lt;p&gt;Moreover, parametric reasoning can reduce the need for unit testing: whatever is guaranteed by the type, does not need to be tested by unit tests. Types prove universal properties across all values, so they are strictly more powerful than tests, which prove existential properties across a few values.&lt;/p&gt;

&lt;p&gt;Since tagless-final is an example of (higher-kinded) parametric polymorphism, we can leverrage parametric polymorphism for effect types too.&lt;/p&gt;

&lt;p&gt;For example, take the following code snippet:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-scala&quot; data-lang=&quot;scala&quot;&gt;&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;consoleProgram&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;F&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;_&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Console:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Applicative&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;F&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;???&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Although we don’t know what the implementation of this function is without looking, we know that it requires &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;F[_]&lt;/code&gt; to provide both &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Console&lt;/code&gt; and &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Applicative&lt;/code&gt; instances.&lt;/p&gt;

&lt;p&gt;Because &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;F[_]&lt;/code&gt; is only &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Applicative&lt;/code&gt; and not &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Monad&lt;/code&gt;, we know that although &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;consoleProgram&lt;/code&gt; can have a sequential chain of console effects, no subsequent effect can depend on the runtime value of a predecessor effect (that capability would require &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;bind&lt;/code&gt; from &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Monad&lt;/code&gt;).&lt;/p&gt;

&lt;p&gt;We would not be surprised if we saw the implementation were as follows:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-scala&quot; data-lang=&quot;scala&quot;&gt;&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;consoleProgram&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;F&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;_&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Console:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Applicative&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;F&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;console&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;implicitly&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;Console&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;F&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]]&lt;/span&gt;

  &lt;span class=&quot;k&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;console._&lt;/span&gt;

  &lt;span class=&quot;nf&quot;&gt;putStrLn&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;What is your name?&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;getStrLn&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;By constraining the capabilities of the data type &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;F[_]&lt;/code&gt;, tagless-final lets us reason about our effectful programs parametrically, which lets us spend less time studying code, and less time writing unit tests.&lt;/p&gt;

&lt;h3 id=&quot;the-closer&quot;&gt;The Closer&lt;/h3&gt;

&lt;p&gt;As we have seen, tagless-final is an incredible asset to functional Scala programmers everwhere.&lt;/p&gt;

&lt;p&gt;Not only does it enable abstraction over effects, so programmers can change their mind about which effect type to use, but the technique gives us full testability of effectful programs, and helps us reason about our effectful programs in new ways, which can reduce the need for studying code and cut down on unit tests.&lt;/p&gt;

&lt;h2 id=&quot;the-fine-print&quot;&gt;The Fine Print&lt;/h2&gt;

&lt;p&gt;Sold yet on tagless-final? I am!!! Well, &lt;em&gt;somewhat&lt;/em&gt;, anyway.&lt;/p&gt;

&lt;p&gt;There’s an element of truth in &lt;em&gt;every&lt;/em&gt; argument that I’ve made. Although as you might suspect, a more nuanced, sophisticated look reveals a less positive picture of tagless-final.&lt;/p&gt;

&lt;p&gt;Let’s take a look at all the fine print in the next few sections.&lt;/p&gt;

&lt;h3 id=&quot;1-premature-indirection&quot;&gt;1. Premature Indirection&lt;/h3&gt;

&lt;p&gt;It is absolutely true that adding a layer of indirection over an effect type can reduce the cost of switching to a different effect type, assuming similar underlying semantics.&lt;/p&gt;

&lt;p&gt;It is also true that adding a layer of indirection over Spark, Akka https, Slick, or a database-specific dialect of SQL, might reduce the cost of switching to different technologies.&lt;/p&gt;

&lt;p&gt;In my experience, however, the attempt to proactively add layers of indirection without a clear business mandate to do so, simply to mitigate the &lt;em&gt;possible&lt;/em&gt; cost of future change, is an example of &lt;em&gt;premature indirection&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Premature indirection rarely pays for itself.&lt;/p&gt;

&lt;p&gt;In most cases, overall application costs would be &lt;em&gt;substantially lower&lt;/em&gt; picking a specific technology, and then, if needs change, simply refactoring the code to a new technology.&lt;/p&gt;

&lt;p&gt;The cost of refactoring from one effect type to another is not related to the cost of changing types from &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;IO[_]&lt;/code&gt; to &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Task[_]&lt;/code&gt;, or swapping one set of methods for another. Rather, it is related to the &lt;em&gt;semantic&lt;/em&gt; differences between operations on these effect types. Yet a layer of indirection helps us only when semantic differences are relatively small. If they are small, then the cost of refactoring is relatively low.&lt;/p&gt;

&lt;p&gt;A refactoring from one effect type to another only needs to happen once, and only if actually necessary (which it might not be). But the cost of coding to a layer of indirection has to be paid indefinitely, and it must be paid regardless of whether or not the indirection will ever be used.&lt;/p&gt;

&lt;p&gt;Beyond the cost of coding to an indirection layer that may never be used, there are substantial &lt;em&gt;opportunity costs&lt;/em&gt; to premature indirection. In the case of ZIO, for example, the core effect type has hundreds of additional operations that are not available on a polymorphic &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;F[_]&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;These methods, like many additional methods on Monix Task, are discoverable by IDEs; their types guide users to correct solutions; they have great inline Scaladoc; error messages are concrete and actionable; and type-inference is nearly flawless.&lt;/p&gt;

&lt;p&gt;If you &lt;em&gt;commit to not committing&lt;/em&gt;, you’re stuck with the weakest &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;F[_]&lt;/code&gt;, which means much of the power of an effect system remains inaccessible. The frustration of knowing a method is right &lt;em&gt;there&lt;/em&gt;, but just out of reach, has prompted many to introduce custom type classes designed to access specific features of the underlying effect type.&lt;/p&gt;

&lt;p&gt;The opportunity cost is even greater for ZIO than Monix, because ZIO features polymorphic reader and error effects, which provide new operations and allow parametric reasoning about dependencies and error handling, and which are currently unsupported in Cats Effect (the leading library for effect indirection).&lt;/p&gt;

&lt;p&gt;In my opinion, only library authors have a compelling argument for effect type indirection. In order to maximize market share (which is critical for the adoption, retention, and growth of open source libraries), they need to support all major effect types, or risk losing market share to the libraries that do.&lt;/p&gt;

&lt;p&gt;While this is a compelling argument for open source libraries, it is completely inapplicable to the closed source applications that make up the majority of Scala software development.&lt;/p&gt;

&lt;h3 id=&quot;2-untestable-effects&quot;&gt;2. Untestable Effects&lt;/h3&gt;

&lt;p&gt;Tagless-final provides a &lt;em&gt;path&lt;/em&gt; to testability, but tagless-final programs are not &lt;em&gt;inherently&lt;/em&gt; testable. In fact, they are testable &lt;em&gt;only to the degree their tagless-final type classes are testable&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;For example, while we can create a testable version of the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Console&lt;/code&gt; type class, many others, including popular type classes in the tagless-final community, are inherently &lt;em&gt;untestable&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;The majority of applications written in the tagless-final style make heavy use of a type class in Cats Effect called &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Sync&lt;/code&gt;, or its more powerful versions, including &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Async&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;LiftIO&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Concurrent&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Effect&lt;/code&gt; and &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ConcurrentEffect&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;These type classes are designed to capture side-effects—for example, random number generation, API calls, and database queries. Any code that utilizes these type classes, or others like them, cannot be unit tested even in theory, because it interacts with partial, non-deterministic, and side-effecting code.&lt;/p&gt;

&lt;p&gt;While such code can be tested with integration and system tests, &lt;em&gt;any code at all&lt;/em&gt; can be tested with integration and system tests, including the worst possible procedural code!&lt;/p&gt;

&lt;p&gt;Ultimately, the testability of tagless-final programs requires they &lt;em&gt;code to an interface, not an implementation&lt;/em&gt;. Yet, if applications follow this principle, they can be tested even &lt;em&gt;without&lt;/em&gt; tagless-final!&lt;/p&gt;

&lt;p&gt;Here is a monomorphic version of the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Console&lt;/code&gt; type class, for example:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-scala&quot; data-lang=&quot;scala&quot;&gt;&lt;span class=&quot;k&quot;&gt;trait&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Console&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;putStrLn&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;line&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Task&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;Unit&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt; 
  &lt;span class=&quot;k&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;getStrLn&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Task&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;If your program uses this interface to perform console input/output, then it can be tested, even with a monomorphic effect type. The key insight is that your program must be &lt;em&gt;written to an interface&lt;/em&gt;, rather than a concrete implementation. Unfortunately, numerous widely-used tagless-final interfaces (like &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Sync&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Async&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;LiftIO&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Concurrent&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Effect&lt;/code&gt;, and &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ConcurrentEffect&lt;/code&gt;) encourage you to code to an &lt;em&gt;implementation&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Using tagless-final doesn’t provide any inherent benefits to testability. The testability of your application is completely orthogonal to its use of tagless-final, and comes down to whether or not you follow best practices—which you can do &lt;em&gt;with&lt;/em&gt; or &lt;em&gt;without&lt;/em&gt; tagless-final.&lt;/p&gt;

&lt;h3 id=&quot;3-no-effect-polymorphic-reasoning&quot;&gt;3. No Effect Polymorphic Reasoning&lt;/h3&gt;

&lt;p&gt;The most insidious claim that tagless-final makes is that it provides &lt;em&gt;effect polymorphic reasoning&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;According to this claim—which is not entirely without merit—we can look at a polymorphic function signature, and know the effects it performs merely by examining constraints.&lt;/p&gt;

&lt;p&gt;Previously, we looked at the following example:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-scala&quot; data-lang=&quot;scala&quot;&gt;&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;consoleProgram&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;F&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;_&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Console:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Applicative&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;F&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;???&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;I argued we could know something about what this function does by observing its use of &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Applicative&lt;/code&gt; and &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Console&lt;/code&gt;. In theory, these constraints provides us the ability to &lt;em&gt;partially&lt;/em&gt; understand the behavior of the function without examining the implementation.&lt;/p&gt;

&lt;p&gt;Unfortunately, this argument rests on a premise that is &lt;em&gt;false&lt;/em&gt;. Namely, it rests on the premise that implicit parameters somehow &lt;em&gt;constrain&lt;/em&gt; the side-effects executed or modeled by the function.&lt;/p&gt;

&lt;p&gt;Scala does not track side-effects, no matter how much we wish otherwise. We can perform console effects anywhere, even without the provided &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Console[F]&lt;/code&gt;, as shown in the following snippet:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-scala&quot; data-lang=&quot;scala&quot;&gt;&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;consoleProgram&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;F&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;_&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Applicative&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;F&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;nf&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;What is your name?&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;name&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;scala&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;py&quot;&gt;io&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;py&quot;&gt;StdIn&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;py&quot;&gt;readLine&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt;
  &lt;span class=&quot;nc&quot;&gt;Applicative&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;F&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;].&lt;/span&gt;&lt;span class=&quot;py&quot;&gt;pure&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Not only can we perform any effects anywhere inside the body of the method without even so much as a compiler warning, but we can embed these effects into any &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Applicative&lt;/code&gt; functor, even one with a strict definition of &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;pure&lt;/code&gt; / &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;point&lt;/code&gt;:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-scala&quot; data-lang=&quot;scala&quot;&gt;&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;consoleProgram&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;F&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;_&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Applicative&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;F&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;=&lt;/span&gt;
  &lt;span class=&quot;nc&quot;&gt;Applicative&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;F&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;].&lt;/span&gt;&lt;span class=&quot;py&quot;&gt;pure&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(()).&lt;/span&gt;&lt;span class=&quot;py&quot;&gt;map&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;_&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;=&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;_&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;What is your name?&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;nv&quot;&gt;scala&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;py&quot;&gt;io&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;py&quot;&gt;StdIn&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;py&quot;&gt;readLine&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;This is legal, type-safe Scala code, and variations of this code appear pervasively in real world Scala. Not even the most aggressive IntelliJ IDEA lint settings will report any problems with this code snippet (except perhaps a warning about the use of higher-kinded types).&lt;/p&gt;

&lt;p&gt;In tagless-final, “constraints”—parameter values like &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Applicative[F]&lt;/code&gt; or &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Console[F]&lt;/code&gt;—do not actually constrain, they &lt;em&gt;unconstrain&lt;/em&gt;, giving us more ways of constructing values. And in Scala, because side-effects are already &lt;em&gt;totally unconstrained&lt;/em&gt;, adding more values to parameter lists doesn’t change anything.&lt;/p&gt;

&lt;p&gt;Stated more forcefully and for Scala code, &lt;strong&gt;effect parametric reasoning is a lie&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;Now, as highly-skilled and highly-disciplined functional programmers, we can agree amongst ourselves to reject merging such code into our projects. We can inspect every line of code in our application to ensure that side-effects are captured only in “appropriate” places, where we all agree on some definition of &lt;em&gt;appropriate&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;A social contract, powered by good-will, skill, discipline, and indoctrination of new hires, can be quite useful. Nearly &lt;em&gt;all&lt;/em&gt; best practices are social contracts, and they undoubtedly help us write better code. But social contracts should not be confused with compile-time constraints.&lt;/p&gt;

&lt;p&gt;If we &lt;em&gt;assume&lt;/em&gt; a working social contract to restrict side-effects in Scala, then we can assume restrictions on the effects in the preceding definition of &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;consoleProgram&lt;/code&gt;, but these restrictions do not come from effect polymorphism (which does not exist in a language without effect tracking!). Rather, the restrictions come from diligence and discipline in enforcing the social contract—the line-by-line review of every new pull request.&lt;/p&gt;

&lt;p&gt;If we are going to rely on a social contract to give us reasoning benefits, however, then we should consider other social contracts, such as &lt;em&gt;always code to an interface, not an implementation&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Other social contracts can give us the exact same “reasoning benefits”, but with potentially better ergonomics. Stated differently, “reasoning benefits” is not a reason to prefer tagless-final over any other approach, because those benefits derive only from discipline (not from effect polymorphism), and discipline works for other approaches too.&lt;/p&gt;

&lt;p&gt;These are hard limits on &lt;em&gt;effect parametric polymorphism&lt;/em&gt; in Scala, which—short of inventing a compiler plug-in that overlays a new, effect-tracked language onto Scala—cannot be circumvented.&lt;/p&gt;

&lt;h3 id=&quot;4-sync-bloat&quot;&gt;4. Sync Bloat&lt;/h3&gt;

&lt;p&gt;Even if we ignore the fact that effect parametric polymorphism doesn’t exist in Scala (reasoning benefits come from discipline, not from tagless-final), we have a major problem that I term &lt;em&gt;sync bloat&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;In Scala, the Cats Effect type class hierarchy provides many type classes that are &lt;em&gt;explicitly designed&lt;/em&gt; to capture side-effecting code. These type classes include &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Sync&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Async&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;LiftIO&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Concurrent&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Effect&lt;/code&gt;, and &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ConcurrentEffect&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Methods that require one of these type classes can literally do &lt;em&gt;anything&lt;/em&gt; they wants, without constraints, even assuming a working social contract. These methods nullify the power of discipline, depriving us of any benefits to reasoning and testability, resulting in opaque blobs of side-effecting, untestable procedural code.&lt;/p&gt;

&lt;p&gt;Nearly all tagless-final code (including some of the &lt;a href=&quot;https://github.com/slamdata/quasar/search?q=Sync&amp;amp;unscoped_q=Sync&quot;&gt;best open source functional Scala I know of&lt;/a&gt;) makes liberal use of these type classes, freely embedding side-effects in numerous methods sprawled across the code base.&lt;/p&gt;

&lt;p&gt;In a perfect world, perhaps programmers would create hundreds or thousands of fine-grained, testable type classes to represent separate concerns. But in the real world, the vast majority of programmers using tagless-final (even high-skilled, expert-level functional programmers!) are not doing this. Instead, they’re requiring type classes like &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Sync&lt;/code&gt; that encourage embedding arbitrary side-effects everywhere.&lt;/p&gt;

&lt;p&gt;The pervasive phenomenon of &lt;em&gt;sync bloat&lt;/em&gt; means that even if we have a working social contract, powered by discipline and diligence, we &lt;em&gt;still&lt;/em&gt; aren’t gaining any benefits of effect parametricity.&lt;/p&gt;

&lt;h3 id=&quot;5-fake-abstraction&quot;&gt;5. Fake Abstraction&lt;/h3&gt;

&lt;p&gt;As I teach in &lt;em&gt;Functional Scala&lt;/em&gt;, abstractions are sets of operations that satisfy algebraic laws, encoded using type classes. Abstractions allow us to describe common structure across a range of distinct data types.&lt;/p&gt;

&lt;p&gt;Abstraction is the means by which we can write &lt;em&gt;principled&lt;/em&gt; polymorphic code.&lt;/p&gt;

&lt;p&gt;Without lawful operations, there is no abstraction, only layers of indirection masquerading as abstraction.&lt;/p&gt;

&lt;p&gt;As practiced in Scala, tagless-final encourages a form of &lt;em&gt;fake abstraction&lt;/em&gt;. To see this, let’s take a closer look at the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Console[F]&lt;/code&gt; type class defined previously:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-scala&quot; data-lang=&quot;scala&quot;&gt;&lt;span class=&quot;k&quot;&gt;trait&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Console&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;F&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;_&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;putStrLn&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;line&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;F&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;Unit&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt; 
  &lt;span class=&quot;k&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;getStrLn&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;F&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;This trait has two operations, called &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;putStrLn&lt;/code&gt; and &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;getStrLn&lt;/code&gt;. We can provide implementations of these two different operations for many different data types.&lt;/p&gt;

&lt;p&gt;Unfortunately, these operations satisfy no algebraic laws—none whatsoever! This means when we are writing polymorphic code, we have no way to reason generically about &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;putStrLn&lt;/code&gt; and &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;getStrLn&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;For all we know, these operations could be launching threads, creating or deleting files, running a large number of individual side-effects in sequence, and so on.&lt;/p&gt;

&lt;p&gt;This contrasts quite dramatically with type classes like &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Ord&lt;/code&gt;, which we can use to build a generic sorting algorithm that will &lt;em&gt;always&lt;/em&gt; be correct if the algebraic laws of &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Ord&lt;/code&gt; are satisfied for the element type (&lt;em&gt;this&lt;/em&gt; is principled functional programming).&lt;/p&gt;

&lt;p&gt;The implications of this are profound. Consider the following type signature:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-scala&quot; data-lang=&quot;scala&quot;&gt;&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;consoleProgram&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;F&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;_&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Console:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Applicative&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;F&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;???&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Because &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Console[F]&lt;/code&gt; is lawless, we cannot reason generically about the side-effects modeled by the returned &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;F[Unit]&lt;/code&gt;. These side-effects are unconstrained precisely because there are no algebraic laws that govern the operations provided to us by &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Console[F]&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Two different implementations of &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Console[F]&lt;/code&gt; could do totally different things, without breaking any laws, so we cannot actually reason &lt;em&gt;generically&lt;/em&gt; about the correctness of code using &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Console[F]&lt;/code&gt;. Our code may be correct for some &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Console[F]&lt;/code&gt;, and incorrect for other &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Console[F]&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Keep in mind that &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Console[F]&lt;/code&gt; is just a toy example. A realistic tagless-final type class would be far larger and more complex, containing numerous operations, which are ad hoc, unlawful, and impossible to reason about generically. If we write code using this type class, it will be highly coupled to unspecified implementation details.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Real&lt;/em&gt; generic reasoning applies only to &lt;em&gt;real&lt;/em&gt; abstractions, like &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Monoid&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Monad&lt;/code&gt;, and type classes from functional programming. The moment we introduce ad hoc, unspecified, implementation-specific operations like &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;putStrLn&lt;/code&gt; or &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;getStrLn&lt;/code&gt;, we can no longer reason generically about the behavior of our code in any principled way.&lt;/p&gt;

&lt;p&gt;What this means is that even if we grant that Scala has effect parametric polymorphism (which it doesn’t!), and even if we assume that developers won’t use type classes like &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Sync&lt;/code&gt; (which they will!), the ad hoc nature of tagless-final type classes means we don’t actually have &lt;em&gt;useful generic reasoning&lt;/em&gt; across these type classes.&lt;/p&gt;

&lt;p&gt;If only &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Applicative[F]&lt;/code&gt; is required, we can tell that &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;bind&lt;/code&gt; is not used, but we cannot tell how many individual side-effects are chained together to make up a single operation like &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;putStrLn&lt;/code&gt;. The limited reasoning we can do is &lt;em&gt;useless&lt;/em&gt; (a parlor trick, at best!), precisely because of all the reasoning we &lt;em&gt;cannot&lt;/em&gt; do.&lt;/p&gt;

&lt;p&gt;Does &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;putStrLn&lt;/code&gt; print a line of text to a console? Or does it launch a multithreaded &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;main&lt;/code&gt; function with the whole application? Who knows. The types and laws don’t tell you anything.&lt;/p&gt;

&lt;p&gt;Adding &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Console[F]&lt;/code&gt; to a type signatue is at best a prayer that whoever gives us a &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Console[F]&lt;/code&gt; will abide by an unspecified contract that has something to do with console input/output and will make our “generic” code work correctly.&lt;/p&gt;

&lt;p&gt;Polymorphic code that we can reason about generically is an awesome benefit of statically-typed functional programming. But generic reasoning requires abstractions, which must always have algebraic laws. The moment we create fake abstractions (operations without laws), we aren’t doing principled functional programming anymore.&lt;/p&gt;

&lt;h2 id=&quot;the-tagless-final-hit-list&quot;&gt;The Tagless-Final Hit List&lt;/h2&gt;

&lt;p&gt;Tagless-final in Scala doesn’t entirely live up to the hype, as I’ve argued in this post:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;strong&gt;Premature Indirection&lt;/strong&gt;. For applications, using tagless-final to guard against the possibility of changing effect types is usually &lt;em&gt;overengineering&lt;/em&gt; (premature indirection). Your application doesn’t add indirection layers for Akka Streams, Slick, Future, or even the dialect of SQL you’re using—because in most cases, the cost of building and maintaining that layer of indirection is &lt;em&gt;unending&lt;/em&gt;. In the case of tagless-final effects, you also deprive yourself of many lawful operations and added type safety.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Untestable Effects&lt;/strong&gt;. Many popular tagless-final type classes encourage capturing side-effects. Even if we are disciplined and diligent, these type classes destroy our ability to reason about and unit test applications built using them. In the end, testability is not a property of tagless-final code; testability requires you code to an interface, which you can do with or without tagless-final.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;No Effect Parametric Polymorphism&lt;/strong&gt;. Scala doesn’t constrain side-effects, and implicit parameters don’t change this. If you want to &lt;em&gt;constrain&lt;/em&gt; side-effects, you need a &lt;em&gt;social contract&lt;/em&gt;, enforced by discipline and diligence. In this case, reasoning benefits (such as they are) come only from painstaking review of every line of code, not from effect polymorphism. Yet other approaches that require discipline, like ensuring programmers only code to an interface, can provide similar benefits, but without the drawbacks of tagless-final.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Sync Bloat&lt;/strong&gt;. In Scala, real world tagless-final code tends not to use custom type classes, but rather, a few type classes that allow the unrestricted capture of side-effects. These &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Sync&lt;/code&gt; code bases do not confer any benefits to reasoning or testability, even if we are disciplined and diligent during code review. They combine the ceremony and boilerplate of tagless-final with the untestable, unreasonable nature of the worst procedural code.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Fake Abstraction&lt;/strong&gt;. Reasoning about generic code requires abstractions, which come equipped with algebraic laws. Algebraic laws precisely define common structure across different data types, and they let us reason generically about the correctness of polymorphic code. Yet most tagless-final type classes do not have any laws. Any code that uses “fake abstractions” is not actually generic, but instead, is closely wedded to unspecified implementation details.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Beyond just not living up to the hype, tagless-final has a number of serious drawbacks:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Tagless-final has significant pedagogical costs, because of the huge number of concepts it requires a team to master (parametric polymorphism, higher-kinded types, higher-kinded parametric polymorphism, type classes, higher-kinded type classes, the functor hierarchy, etc.).&lt;/li&gt;
  &lt;li&gt;Tagless-final has significant institutional costs, because of the level of ceremony and boilerplate involved (type classes, type class instances, instance summoners, syntax extensions, higher-kinded implicit parameter lists, non-inferrable types, compiler plug-ins, etc.).&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;I’ve &lt;a href=&quot;/articles/zio-environment&quot;&gt;talked about these drawbacks&lt;/a&gt; at length in the past, and I encourage readers to investigate for themselves the drawbacks of tagless-final in Scala.&lt;/p&gt;

&lt;h2 id=&quot;objections&quot;&gt;Objections&lt;/h2&gt;

&lt;p&gt;Some functional programmers, when presented with these drawbacks, immediately counter with the objection that &lt;em&gt;other approaches&lt;/em&gt; (including the &lt;a href=&quot;/articles/zio-environment&quot;&gt;reader monad&lt;/a&gt;) can’t constrain side-effects in Scala, either.&lt;/p&gt;

&lt;p&gt;This is true, but also entirely beside the point.&lt;/p&gt;

&lt;p&gt;There are &lt;em&gt;zero&lt;/em&gt; approaches to statically constraining effects in Scala, because Scala cannot statically constrain effects. This means that when comparing two different approaches to managing effects in Scala, there is no dimension for “constraining effects”.&lt;/p&gt;

&lt;p&gt;You can combine tagless-final with manual inspection of every line of code in an application, to ensure it satisfies the social contract that side-effects will only be executed and captured in “approved” places. This combination, which is powered by discipline (not effect polymorphism), provides both testability and reasoning benefits.&lt;/p&gt;

&lt;p&gt;Similarly, you can combine the reader monad with manual inspection of every line of code in an application, to ensure it satisfies a social contract that logic will be written to interfaces, not implementations. As with tagless final, this combination is powered by discipline, and provides both testability and reasoning benefits.&lt;/p&gt;

&lt;p&gt;Both tagless-final and the reader monad (and many other approaches) can indeed provide “guarantees” about effects, but it’s not really the &lt;em&gt;techniques&lt;/em&gt; that are providing the guarantees, but the &lt;em&gt;programmers&lt;/em&gt; who are manually reviewing and merging every line of code. These “guarantees” come from discipline, not from the Scala compiler.&lt;/p&gt;

&lt;p&gt;Take the following snippet of tagless-final:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-scala&quot; data-lang=&quot;scala&quot;&gt;&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;console&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;F&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;_&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Monad:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Console&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;F&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;Unit&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;???&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;The only way we “know” this function does not interact with databases or perform random number generation or do anything else is if we or our colleagues have inspected every line of code, and manually certified that it doesn’t break our social contract about where side-effects can be run and modeled.&lt;/p&gt;

&lt;p&gt;The compiler doesn’t provide any assistance with this, and this “knowledge” is not related to effect polymorphism.&lt;/p&gt;

&lt;p&gt;Similarly, take the following snippet of monomorphic code:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-scala&quot; data-lang=&quot;scala&quot;&gt;&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;console&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Console&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Task&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;Unit&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;???&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;The only way we “know” this function does not interact with the database or perform random number generation or do anything else is if we or our colleagues have inspected every line of code, and manually certified that it doesn’t break our social contract about coding to interfaces, and not to implementations.&lt;/p&gt;

&lt;p&gt;As with taglesss-final, the compiler doesn’t provide any assistance. Both these approaches and others to reasoning about side-effects come down to social contracts, powered by discipline and vigilence.&lt;/p&gt;

&lt;p&gt;Another vague objection I have heard is that tagless-final is somehow more principled than other approaches, or that it somehow lends itself better to designing composable functional APIs.&lt;/p&gt;

&lt;p&gt;In reality, principled, composable, functional code has everything to do with whether the operations of your domain satisfy algebraic laws. As practiced in Scala, tagless-final has no relation to principled functional programming.&lt;/p&gt;

&lt;p&gt;The use of higher-kinded parametric polymorphism may provide an illusion of “rigor”, but it’s just a thin veneer on what is typically unprincipled imperative code. All the effect type polymorphism in the world can’t change this.&lt;/p&gt;

&lt;h2 id=&quot;recommendations&quot;&gt;Recommendations&lt;/h2&gt;

&lt;p&gt;In light of this analysis of tagless-final, I have some concrete recommendations for different situations:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;strong&gt;Stay the Course&lt;/strong&gt;. If you’re in a small, stable, high-skilled team that’s already using and benefiting from tagless-final due to a working social contract, then &lt;em&gt;keep using tagless-final&lt;/em&gt;. Long-time functional programmers may “forget” how to program procedurally and instinctively confine themselves to a functional subset of Scala, which makes enforcement of the contract easier. Consider abandoning tagless-final (or building a compiler plug-in) if the team starts scaling.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Build a Library&lt;/strong&gt;. If you’re building an open source library that doesn’t take advantage of effect-specific features, then use an existing layer of indirection, such as Cats Effect. Or if you want to keep dependencies small, create a tiny layer of indirection for just the features you need. This layer may not help you reason about or test code, but it will help you support the full functional Scala market, which will improve adoption of your library.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Ditch Tagless-Final&lt;/strong&gt;. In all other cases, I recommend picking a concrete effect type (ZIO, Cats IO, or Monix). If you decide to switch later, you’ll pay a one-time cost for the (straightforward) refactor. Encourage coding to &lt;em&gt;interfaces&lt;/em&gt;, not implementations. This social contract doesn’t scale either, but at least many Java developers are already indoctrinated in the practice. This will give you testability, it can be done incrementally, and it can give you the same (discipline-powered) reasoning benefits as tagless-final, if employed to the same extent.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Minimize Effectful Code&lt;/strong&gt;. Consider minimizing effectful code. Look for real abstractions in your domain, which are equipped with algebraic laws that help you reason generically about polymorphic code. Prefer declarative code instead of imperative (monadic) code. Don’t presume your &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;State&lt;/code&gt; monad code is any better than its &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;IO&lt;/code&gt; equivalent (it’s not). Prefer data types whose operations have denotational semantics.&lt;/li&gt;
&lt;/ol&gt;

&lt;h1 id=&quot;summary&quot;&gt;Summary&lt;/h1&gt;

&lt;p&gt;Tagless-final has a brilliant sales pitch. It promises to future-proof our code to changes in concrete effect types. It promises us testability. It promises us the ability to reason about effects using parametric polymorphism.&lt;/p&gt;

&lt;p&gt;Unfortunately, the reality of tagless-final doesn’t live up to the hype:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Tagless-final does insulate us from an effect type, but that’s a maintenance burden and deprives us of useful principled operations and type-safety.&lt;/li&gt;
  &lt;li&gt;Tagless-final doesn’t provide us any testability, per se, and many common type classes prevent testability; it’s only coding to an interface that provides us with testability, which can be done with or without tagless-final.&lt;/li&gt;
  &lt;li&gt;Tagless-final doesn’t constrain effects, since Scala has no way to restrict side-effects; type signatures alone cannot tell us which side-effects are executed or modeled by a method.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Beyond these drawbacks, real world tagless-final is littered with &lt;em&gt;sync bloat&lt;/em&gt;, which can’t help us with unit testing or reasoning even if we are disciplined and diligent about restricting side-effects.&lt;/p&gt;

&lt;p&gt;Further, since most tagless-final type classes are completely lawless, we can’t reason generically about code that uses them. True generic reasoning requires &lt;em&gt;abstractions&lt;/em&gt;, defined by lawful sets of operations, and tagless-final doesn’t give us abstractions, only collections of ad hoc operations with unspecified semantics.&lt;/p&gt;

&lt;p&gt;Tagless-final, far from being a pancea to managing functional effects, imposes great pedagogical and institutional costs. Many claim the technique renders Scala code bases impenetrable and unmaintainable. While an exaggeration, there is no question that the learning curve for tagless-final is steep, and the ergonomics of the technique are poor.&lt;/p&gt;

&lt;p&gt;Ultimately, in my opinion, the benefits of tagless-final do not pay for the costs—at least not in most cases, and not with the current Scala compiler and tooling.&lt;/p&gt;

&lt;p&gt;Small, stable teams that are already using tagless-final with a working social contract should probably keep using tagless-final, at least if they have found the benefits to outweigh the costs (and some teams have).&lt;/p&gt;

&lt;p&gt;Developers of open source libraries can surely benefit from a layer of indirection around effect types, because even though indirection may not help with reasoning or testability, it can increase addressable market share.&lt;/p&gt;

&lt;p&gt;Finally, other teams should probably avoid using tagless-final for managing effects, and embrace the age-old best practice of &lt;em&gt;coding to an interface&lt;/em&gt;. While still just a social contract that relies on discipline, the practice is widely known, doesn’t require any fancy training, and can be used with more ergonomic approaches to testability and reasoning, including traditional dependency injection, module-oriented programming, and the reader monad.&lt;/p&gt;


  &lt;p&gt;&lt;a href=&quot;https://degoes.net/articles/tagless-horror&quot;&gt;The False Hope of Managing Effects with Tagless-Final in Scala&lt;/a&gt; was originally published by John A De Goes at &lt;a href=&quot;https://degoes.net&quot;&gt;John <em>A</em> <strong>De Goes</strong>&lt;/a&gt; on June 18, 2019.&lt;/p&gt;</content>
</entry>


<entry>
  <title type="html"><![CDATA[Why I'm Stepping Back from Scalaz]]></title>
  <link rel="alternate" type="text/html" href="https://degoes.net/articles/zio-solo" />
  <id>https://degoes.net/articles/zio-solo</id>
  <published>2019-05-28T00:00:00-06:00</published>
  <updated>2019-05-28T00:00:00-06:00</updated>
  <author>
    <name>John A De Goes</name>
    <uri>https://degoes.net</uri>
    <email>john@degoes.net</email>
  </author>
  <content type="html">&lt;p&gt;Many of my readers know I have promoted and contributed to &lt;a href=&quot;https://github.com/scalaz/&quot;&gt;Scalaz&lt;/a&gt; for a little over two years now.&lt;/p&gt;

&lt;p&gt;After many wonderful collaborations with some of the most talented Scala developers I know, I have decided to step back from Scalaz, and pull &lt;a href=&quot;https://github.com/scalaz/scalaz-zio&quot;&gt;ZIO&lt;/a&gt;, my most significant work, into a separate organization—one that is not associated with Scalaz in any way.&lt;/p&gt;

&lt;p&gt;I hope this post make it clear why I am doing this, and what it means for the future of functional programming in Scala.&lt;/p&gt;

&lt;h2 id=&quot;community-build-controversy&quot;&gt;Community Build Controversy&lt;/h2&gt;

&lt;p&gt;As most of the functional Scala community knows by now, all projects in the Scalaz organization, as well as some that depend on Scalaz, were &lt;a href=&quot;https://github.com/scala/community-builds/commit/be8d3f07832c78044a65d3840a9338dc05943af7&quot;&gt;recently removed from the Scala community build&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;The community build is used as a regression suite for the Scalac compiler, and helps ensure that changes to the compiler do not break innovative or widely-used libraries in the Scala ecosystem.&lt;/p&gt;

&lt;p&gt;When I was made aware of this event, I &lt;a href=&quot;https://github.com/scala/community-builds/issues/896&quot;&gt;requested more information&lt;/a&gt; and asked for a reversal.&lt;/p&gt;

&lt;p&gt;When it became clear to me there would be no reversal or official explanation, I made a &lt;a href=&quot;https://contributors.scala-lang.org/t/coc-compatible-community-builds/3097/240?u=jdegoes&quot;&gt;final statement&lt;/a&gt;, which expressed my disappointment and desire for better community stewardship, even while assuming good-faith all around.&lt;/p&gt;

&lt;p&gt;Ultimately, some good came out of the discussions:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;The build is now more faithfully rebranded as the &lt;a href=&quot;https://github.com/scala/community-builds/commit/df5a1c44f7e69f26737d09ffcefbc387c8bb1b97&quot;&gt;Lightbend build&lt;/a&gt;;&lt;/li&gt;
  &lt;li&gt;It is clear that which projects are included is entirely at the &lt;a href=&quot;https://github.com/scala/community-builds/wiki/Eligibility/_compare/2d2b7e7e77f0d305452cd62fd5b27437eefc8571&quot;&gt;discretion of Lightbend employees&lt;/a&gt;, without input from the community.&lt;/li&gt;
  &lt;li&gt;There is a chance that ZIO (which did not depend on Scalaz, but lived inside the Scalaz organization), will eventually make it back into the Lightbend build, helping protect against compiler regression.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;While not the outcome I hoped for, these steps do represent progress toward more transparency, and I would hope only the Lightbend project be relocated to the &lt;a href=&quot;https://github.com/lightbend&quot;&gt;Lightbend organization&lt;/a&gt; at some point in the future, to better convey the fact the build does not reflect what the Scala community uses or necessarily wishes to include in the build.&lt;/p&gt;

&lt;h2 id=&quot;the-birth-of-zio&quot;&gt;The Birth of ZIO&lt;/h2&gt;

&lt;p&gt;ZIO is a library for asynchronous and concurrent programming in Scala. While not dependent on Scalaz, the library has been hosted inside the Scalaz organization on Github, and has therefore been affected by the decision to remove all Scalaz projects from the Lightbend build.&lt;/p&gt;

&lt;p&gt;ZIO was hosted inside Scalaz for historical reasons.&lt;/p&gt;

&lt;p&gt;In early 2017, Vincent Marquez, a friend of mine and fellow functional Scala developer, asked me if I would be willing to contribute to the next version of Scalaz (Scalaz 8), which had a long tradition of pushing the boundaries of functional programming in Scala.&lt;/p&gt;

&lt;p&gt;I said yes, and began looking for something interesting to work on.&lt;/p&gt;

&lt;p&gt;For many years, I’ve been interested in how functional programming can improve asynchronous and concurrent programming. Having written several versions of &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Future&lt;/code&gt;, in several programming languages, and having authored the first version of &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Aff&lt;/code&gt; (the de facto asynchronous effect system for PureScript), working on the next-generation Scalaz effect system seemed like a good fit.&lt;/p&gt;

&lt;p&gt;So I signed up to work on the &lt;em&gt;Scalaz 8 IO monad&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;I had heretical ideas about how such an effect type should be designed: I wanted built-in concurrency powered by fibers; I wanted resource-safety with iron-clad guarantees; I wanted fine-grained interruption (termed &lt;em&gt;async exceptions&lt;/em&gt; in Haskell); and I wanted performance to radically improve on last-generation effect types.&lt;/p&gt;

&lt;p&gt;While my ideas were extremely controversial at the time, I presented my work at Scala IO 2017 and Scale by the Bay 2017, and the reception was so overwhelmingly positive that it went on to permanently change the direction of the Cats IO data type and Cats Effect type class hierarchy.&lt;/p&gt;

&lt;p&gt;Development of the Scalaz 8 effect system proceeded quickly, much faster than development of Scalaz 8 itself. Meanwhile, both Scalaz 7.x and Cats developers were interested in using the effect system even while still early in development. The demand was so high that other developers pulled the effect type out into a standalone project called &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ioeffect&lt;/code&gt;—which happened in about 24 hours and without any help from me.&lt;/p&gt;

&lt;p&gt;When this happened, it became clear to me the best way to help the entire functional Scala community was to pull the effect system out of Scalaz 8, and make it a proper standalone project, without any dependencies on Scalaz or Cats, but with full support for both libraries in separate modules.&lt;/p&gt;

&lt;p&gt;On June 11, 2018, &lt;em&gt;ZIO&lt;/em&gt; was officially born.&lt;/p&gt;

&lt;h2 id=&quot;zio-drifts-from-scalaz&quot;&gt;ZIO Drifts from Scalaz&lt;/h2&gt;

&lt;p&gt;Over the coming months, ZIO got its own chat room on Gitter, its own set of contributors (most of whom did not use Scalaz, and some of whom used Cats!), and its own unique culture—which is overwhelmingly positive, supportive, and focused on mentoring and growing Scala developers.&lt;/p&gt;

&lt;p&gt;ZIO was becoming its own thing, independent of Scalaz, even while it lived on within the same organization.&lt;/p&gt;

&lt;h2 id=&quot;the-scalaz-connection&quot;&gt;The Scalaz Connection&lt;/h2&gt;

&lt;p&gt;Having contributed to Scalaz, and worked (mostly on ZIO) within the Scalaz organization for more than two years, I can say unreservedly there are some amazing things about the Scalaz community.&lt;/p&gt;

&lt;p&gt;Firstly, many of the &lt;em&gt;people&lt;/em&gt; who work on Scalaz are very gifted, selfless individuals, who prize community service above all else. For example, Kenji Yoshida, Tomas Mikula, and others.&lt;/p&gt;

&lt;p&gt;Secondly, there is a culture of technical excellence in Scalaz. Technical discussions are encouraged, even if they are critical. Contributors understand that &lt;em&gt;they are not their code&lt;/em&gt;, and they welcome suggestions to improve their work.&lt;/p&gt;

&lt;p&gt;Yet regardless of these cultural highlights, it is impossible to ignore the controversial history of the project. And at the center of this controversy is the project’s founder, &lt;em&gt;Tony Morris&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Tony Morris is a long-time functional programmer, an accomplished teacher who has donated countless hours to developers, patiently teaching them everything from the elementary to the advanced (I remember him writing 50 lines of code to explain to me how &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;List&lt;/code&gt; is a free monoid!).&lt;/p&gt;

&lt;p&gt;Yet, while many (including myself) will attest to Tony’s generous assistance and mentorship over the years, there are others who have been offended or hurt by Tony’s communication style, or have found his relentless critiques of Scala to be emotionally draining.&lt;/p&gt;

&lt;p&gt;I have witnessed Tony insult others on a number of occassions—not just critique their work, mind you, but engage in ad hominem. While, as far as I have seen, this was always in response to (more subtle and socially sanctioned) ad hominem, it does not mitigate the very real hurt caused by Tony’s actions.&lt;/p&gt;

&lt;p&gt;The effects of this over time are twofold:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Scalaz &lt;em&gt;proper&lt;/em&gt; contributors are not easily offended and are much more direct (&lt;em&gt;selection bias&lt;/em&gt;);&lt;/li&gt;
  &lt;li&gt;A few people refuse to interact with the Scalaz project because they have been hurt or are afraid of being hurt.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Tony Morris is not the only person to scare developers away from Scala communities, of course. Some developers publicly refuse to contribute to Typelevel projects (and others, privately, so I am told), citing the actions of Lars Hupel or—before they “stepped down” from Typelevel—the actions of Travis Brown and Stew O’Connor, who still show up in the chat rooms and comment on project issues.&lt;/p&gt;

&lt;p&gt;I’m not privy to everything, but as far as I can tell, Tony’s actions have been more publicly visible than those of Lars, Travis, or Stew, and have led to more public backlash.&lt;/p&gt;

&lt;h2 id=&quot;modern-day-scalaz&quot;&gt;Modern Day Scalaz&lt;/h2&gt;

&lt;p&gt;With the Scalaz mentorship program I led last year, the organization saw a huge influx of new contributors, who knew nothing about the history of the project or Tony’s communication style.&lt;/p&gt;

&lt;p&gt;Most of the new contributors now work in the ZIO project, which is isolated from the main Scalaz project, but there are other Scalaz projects that work in their own silos (Parsers, Schema, etc.).&lt;/p&gt;

&lt;p&gt;Although Tony Morris stopped contributing to Scalaz years ago (after he gave up on Scala), his ghost still haunts the halls of Scalaz to this day.&lt;/p&gt;

&lt;p&gt;Tony is no longer present in the day-to-day, but he still shows up occassionally in the Scalaz chat room. Very rarely, he comments on issues in the Scalaz project. And, as he will likely do for many years to come, Tony continues to heavily criticize Scala on technical grounds.&lt;/p&gt;

&lt;p&gt;For better or worse, the project founded by Tony Morris will probably always be associated with Tony Morris.&lt;/p&gt;

&lt;h2 id=&quot;zio--scalaz&quot;&gt;ZIO != Scalaz&lt;/h2&gt;

&lt;p&gt;I believe that every project and every community needs to be judged based on its own merits, and with the community build controversy, it has become clear to me this is not happening right now.&lt;/p&gt;

&lt;p&gt;ZIO is not Scalaz, and I am not Tony Morris.&lt;/p&gt;

&lt;p&gt;Many first-time contributors and users of ZIO have stated in public or in private that ZIO has one of the friendliest, most welcoming, and most supportive environments of &lt;em&gt;any&lt;/em&gt; open source community.&lt;/p&gt;

&lt;p&gt;The project has attracted more than a hundred diverse contributors from all around the world, some of whom chose ZIO to be their first contribution to the world of open source software.&lt;/p&gt;

&lt;p&gt;I strongly believe that ad hominem will never help, but will make every situation worse. I believe that rather than trade barbs, leaders of a community should turn the other cheek (which may not be &lt;em&gt;fair&lt;/em&gt; but it is &lt;em&gt;noble&lt;/em&gt;), using empathy and nonviolent communication to heal and bind together.&lt;/p&gt;

&lt;p&gt;It is not up to me to force my own personal communication philosophy on the open source projects of others. But it &lt;em&gt;is&lt;/em&gt; up to me to follow my own path, and create the kind of communities I want to see in this world.&lt;/p&gt;

&lt;p&gt;So in that spirit, and for both social as well as technical reasons, on April 29th I announced that ZIO would be leaving the Scalaz organization, and moving to a new &lt;a href=&quot;https://github.com/zio&quot;&gt;ZIO&lt;/a&gt; organization on Github.&lt;/p&gt;

&lt;p&gt;This is a brand new start for an exciting young project that will henceforth be judged on its own merits, for its own culture.&lt;/p&gt;

&lt;h2 id=&quot;life-after-scalaz&quot;&gt;Life After Scalaz&lt;/h2&gt;

&lt;p&gt;With ZIO moving outside of Scalaz, I hope to continue to build upon the culture we have created, mentoring new generations of functional Scala developers, and building an environment where everyone feels supported and empowered to become the best version of themselves.&lt;/p&gt;

&lt;p&gt;I hope also to retain the many positive aspects of the Scalaz culture, such as a commitment to technical excellence, and a willingness to hear technical critiques and act on them without ego (easier said than done!).&lt;/p&gt;

&lt;p&gt;I hope to continue the Scalaz tradition of questioning dogma.&lt;/p&gt;

&lt;p&gt;For example, unlike many of my functional Scala comrades, I believe the key to making functional programming in Scala feel natural is to embrace all of Scala’s features, including subtyping, intersection types, and variance (without compromising purity); and to reject many Haskellisms, such as monad transformers, which have poor ergonomics and performance in Scala.&lt;/p&gt;

&lt;p&gt;I believe that functional Scala programmers need to roll up their sleeves and help make Scala even better at functional programming, rather than criticize from the side-lines (something I have been guilty of myself!).&lt;/p&gt;

&lt;p&gt;I do not anticipate contributing significantly to the current versions of Scalaz or Cats. Rather, I hope, and will encourage, a unification between Cats and Scalaz—a single base of contributors all collectively working toward making functional Scala wildly successful in industry.&lt;/p&gt;

&lt;p&gt;As you might suspect, I have a few (heretical) ideas about what a unified architecture could look like, and I think it quite likely these ideas will materialize, in an appropriate way, and at a suitable time.&lt;/p&gt;

&lt;h2 id=&quot;closing-thoughts&quot;&gt;Closing Thoughts&lt;/h2&gt;

&lt;p&gt;I’m very grateful for the chance to participate in the development of the Scalaz library—a great library that first made functional programming in Scala viable.&lt;/p&gt;

&lt;p&gt;I’m grateful that many of the relationships I’ve made in the Scalaz community will continue to live on, even as I step back from the project to focus on the new ZIO organization, and surrounding ecosystem.&lt;/p&gt;

&lt;p&gt;I wish both Scalaz and Cats contributors the best of luck helping programmers derive value from functional programming. And I want to express my sincere hope that we find a way to bring together the whole functional Scala community, with a culture that’s positive, inclusive, supportive, and professional.&lt;/p&gt;

&lt;p&gt;With work and a little luck, I believe that we can heal past hurt, mend trust, build bridges not walls, and end up doing something amazing that will be remembered for a generation of programmers.&lt;/p&gt;

&lt;p&gt;See you all online at &lt;a href=&quot;https://twitter.com/jdegoes&quot;&gt;@jdegoes&lt;/a&gt; or in the new &lt;a href=&quot;https://gitter.im/zio/core&quot;&gt;ZIO Chat Room&lt;/a&gt;!&lt;/p&gt;

&lt;p&gt;&lt;em&gt;&lt;strong&gt;Addendum&lt;/strong&gt;: I want to make it clear that Tony Morris and I have been and remain friends, and that despite different goals and philosophies, I highly respect his expertise and contributions to functional programming, and I welcome his positive contributions to any conferences, events, or projects I’m involved with, subject to the same criteria as anyone else. I also acknowledge in writing this post that it is an incomplete picture, and if you’re interested in the full story of why Tony communicates in the way he does, you should talk to Tony.&lt;/em&gt;&lt;/p&gt;

  &lt;p&gt;&lt;a href=&quot;https://degoes.net/articles/zio-solo&quot;&gt;Why I'm Stepping Back from Scalaz&lt;/a&gt; was originally published by John A De Goes at &lt;a href=&quot;https://degoes.net&quot;&gt;John <em>A</em> <strong>De Goes</strong>&lt;/a&gt; on May 28, 2019.&lt;/p&gt;</content>
</entry>


<entry>
  <title type="html"><![CDATA[Type Classes: When To Use Them, When To Avoid Them]]></title>
  <link rel="alternate" type="text/html" href="https://degoes.net/articles/when-to-typeclass" />
  <id>https://degoes.net/articles/when-to-typeclass</id>
  <published>2019-04-20T00:00:00-06:00</published>
  <updated>2019-04-20T00:00:00-06:00</updated>
  <author>
    <name>John A De Goes</name>
    <uri>https://degoes.net</uri>
    <email>john@degoes.net</email>
  </author>
  <content type="html">&lt;p&gt;Type classes are a powerful tool for abstraction in functional programming. But they are poorly understood, and often abused.&lt;/p&gt;

&lt;p&gt;In this post, I want to explain what a type class is—in a way that will be &lt;em&gt;quite&lt;/em&gt; foreign to most readers—and offer my own personal recommendations on when you should use type classes to solve a problem, and when you should avoid them.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Note: This post assumes you already know how to create and use type classes.&lt;/em&gt;&lt;/p&gt;

&lt;h2 id=&quot;type-class-101&quot;&gt;Type Class 101&lt;/h2&gt;

&lt;p&gt;In the simplest possible case, a &lt;em&gt;type class&lt;/em&gt; is a function from a type to a set of lawful operations on values of that type.&lt;/p&gt;

&lt;p&gt;Let’s take this definition apart, one piece at a time:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;em&gt;A type class is a function …&lt;/em&gt;. This is not a function in the &lt;em&gt;programming language&lt;/em&gt; sense of the word, but rather, a function in the &lt;em&gt;mathematical&lt;/em&gt; sense of the word. We give a type class some type, like &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Int&lt;/code&gt;, and we get back something (just &lt;em&gt;one&lt;/em&gt; something). Moreover, when we give the type class the &lt;em&gt;same&lt;/em&gt; type, we get back the &lt;em&gt;same&lt;/em&gt; thing. How this function is encoded varies depending on the capabilities of the host language. For example, Scala and Haskell have quite different mechanisms for representing type classes.&lt;/li&gt;
  &lt;li&gt;&lt;em&gt;…from a type…&lt;/em&gt;. Technically, type classes can have multiple parameters, not just one; and technically, they may not be &lt;em&gt;types&lt;/em&gt;, but rather, &lt;em&gt;type constructors&lt;/em&gt;. But in the common case, type classes are functions that take one type. Some languages, like Java or Kotlin, don’t have higher-kinded type parameters.&lt;/li&gt;
  &lt;li&gt;&lt;em&gt;…to a set…&lt;/em&gt;. Like &lt;em&gt;function&lt;/em&gt; above, this is not a &lt;em&gt;programming language&lt;/em&gt; set, but rather, a &lt;em&gt;mathematical&lt;/em&gt; set. Each operation in the set is unique (there are no duplicates). Like with “function” above, how the set is encoded varies depending on the programming language.&lt;/li&gt;
  &lt;li&gt;&lt;em&gt;…of lawful operations…&lt;/em&gt;.  The operations provided by the type class are governed by laws. Laws are rather like unit tests, except they apply in &lt;em&gt;all&lt;/em&gt; cases, not just &lt;em&gt;some&lt;/em&gt; cases. A few programming languages (like Idris) can express laws in a way the compiler will enforce, but most programming languages rely on manual use of property-checking to verify laws are satisfied as part of a test suite.&lt;/li&gt;
  &lt;li&gt;&lt;em&gt;…on values of that type&lt;/em&gt;. The operations provided by the type class are all operations on &lt;em&gt;values&lt;/em&gt; that have the type described in (2).&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;A type class &lt;em&gt;instance&lt;/em&gt;, on the other hand, is a &lt;em&gt;piecewise definition&lt;/em&gt; of the type class function for a given type. The type class function is not defined for &lt;em&gt;all&lt;/em&gt; types, but only for &lt;em&gt;some&lt;/em&gt; types, and those definitions are described by type class &lt;em&gt;instances&lt;/em&gt;. A type class is not defined for a given type when there does not exist an instance of the type class for that type. On the other hand, if a type class is defined for some type, then the instance provides the definition of the operations for that type.&lt;/p&gt;

&lt;p&gt;Type classes compliment &lt;em&gt;parametric polymorphism&lt;/em&gt;. Parametric polymorphism allows us to create data structures and functions that are &lt;em&gt;polymorphic&lt;/em&gt; in a type &lt;em&gt;parameter&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Parametric polymorphism serves two useful functions:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;It allows us to create reusable data structures and functions, which can be used across not just a single (monomorphic) type, but across lots of types;&lt;/li&gt;
  &lt;li&gt;It allows us to throw away information that is not relevant to a problem, constraining possible solutions, and improving guarantees of correctness.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;In the following code, we write &lt;em&gt;parametrically polymorphic&lt;/em&gt; code that accesses the 2nd element of a tuple:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-scala&quot; data-lang=&quot;scala&quot;&gt;&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;snd&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;A&lt;/span&gt;, &lt;span class=&quot;kt&quot;&gt;B&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;](&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tuple&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;A&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;B&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;))&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;B&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;tuple&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;py&quot;&gt;_2&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-haskell&quot; data-lang=&quot;haskell&quot;&gt;&lt;span class=&quot;n&quot;&gt;snd&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;::&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;snd&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kr&quot;&gt;_&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;This code can work for all types &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;A&lt;/code&gt; and &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;B&lt;/code&gt;, and can therefore work for all tuples of arity 2. It is very resuable, and doesn’t know more about the types than it needs to.&lt;/p&gt;

&lt;p&gt;While parametric polymorphism allows us to &lt;em&gt;throw away&lt;/em&gt; structure, to make code more reusable and constraint implementations, sometimes it throws away &lt;em&gt;too much&lt;/em&gt; structure to solve a given problem. In the above definition of &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;snd&lt;/code&gt;, the function does not know &lt;em&gt;anything&lt;/em&gt; about the types &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;A&lt;/code&gt; and &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;B&lt;/code&gt;, which is fine for this problem, but which is not fine for most problems.&lt;/p&gt;

&lt;p&gt;Most polymorphic functions will require &lt;em&gt;some&lt;/em&gt; structure from a type: they will need the ability to do &lt;em&gt;something&lt;/em&gt; with values of that type. For example, they might need to combine them, compare them, iterate over them, or construct them.&lt;/p&gt;

&lt;p&gt;To add structure to a type, to give us some &lt;em&gt;operations&lt;/em&gt;, we use type classes. Type classes, being functions from types to a set of lawful operations on values of those types, give us the ability to operate with values of some unknown type. Although we may not know what the type is, thanks to type classes, we have enough structure to generically solve our problem.&lt;/p&gt;

&lt;p&gt;The final piece of the puzzle is called a &lt;em&gt;type class constraint&lt;/em&gt;. Type class constraints are the mechanism by which a language allows us to &lt;em&gt;statically require&lt;/em&gt; that some polymorphic type have an &lt;em&gt;instance&lt;/em&gt; for a given type class.&lt;/p&gt;

&lt;h3 id=&quot;example&quot;&gt;Example&lt;/h3&gt;

&lt;p&gt;In the following example, we define a type class called &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Ord&lt;/code&gt;, which provides a single lawful operation for some type &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;A&lt;/code&gt;.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-scala&quot; data-lang=&quot;scala&quot;&gt;&lt;span class=&quot;k&quot;&gt;sealed&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;trait&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Ordering&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;object&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Ordering&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;object&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;LT&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;extends&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Ordering&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;object&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;EQ&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;extends&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Ordering&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;object&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;GT&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;extends&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Ordering&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;trait&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Ord&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;A&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;compare&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;l&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;A&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;r&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;A&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Ordering&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;object&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Ord&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;A&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;apply&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;A&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;](&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;implicit&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;A&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Ord&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;A&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;])&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Ord&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;A&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;A&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-haskell&quot; data-lang=&quot;haskell&quot;&gt;&lt;span class=&quot;kr&quot;&gt;data&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Ordering&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;LT&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;EQ&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;GT&lt;/span&gt;
&lt;span class=&quot;kr&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Ord&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;kr&quot;&gt;where&lt;/span&gt; 
  &lt;span class=&quot;n&quot;&gt;compare&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;::&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Ordering&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;In Scala, if we wish to obtain the operation for some type &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;A&lt;/code&gt;, let’s say &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Int&lt;/code&gt;, we utilize the expression &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Ord[Int]&lt;/code&gt;, which gives us the &lt;em&gt;instance&lt;/em&gt; for the type &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Int&lt;/code&gt;. If such an instance has not been defined, then we will get a compile-time error.&lt;/p&gt;

&lt;p&gt;Similarly, in Scala, if we wish to add a &lt;em&gt;constraint&lt;/em&gt; on some parametric parameter, we can use context bounds, which are how constraints are encoded in Scala:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-scala&quot; data-lang=&quot;scala&quot;&gt;&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;sort&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;A:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Ord&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;](&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;list&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;List&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;A&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;])&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;List&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;A&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;])&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;In Haskell, if we wish to obtain the operation for some type &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;A&lt;/code&gt;, let’s say &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;String&lt;/code&gt;, we cannot call the type class function directly, because instances are not first-class values in Haskell. However, we can use the type class operation, and Haskell will automatically “call” the type class function to retrieve the instance for that type. If such an instance has not been defined, we will get a compile-time error.&lt;/p&gt;

&lt;p&gt;In Haskell, if we wish to add a constraint, we use a type class constraint:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-scala&quot; data-lang=&quot;scala&quot;&gt;&lt;span class=&quot;n&quot;&gt;sort&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;::&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Ord&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;In both of these examples, the use of parametric polymorphism allows us to throw away irrelevant details, making our sort function more generic, and constraining possible implementations, leading to stronger guarantees on correctness.&lt;/p&gt;

&lt;p&gt;With this background out of the way, let’s talk about when to use type classes, and more importantly, when to &lt;em&gt;not&lt;/em&gt; use them!&lt;/p&gt;

&lt;h2 id=&quot;type-class-best-practices&quot;&gt;Type Class Best Practices&lt;/h2&gt;

&lt;p&gt;The purpose of type classes is to add &lt;em&gt;structure&lt;/em&gt; to polymorphic types—just enough structure to allow us to solve our problem, but not more structure than necessary, so we can benefit from maximum code reuse, and maximally constrain our implementation.&lt;/p&gt;

&lt;p&gt;The word &lt;em&gt;structure&lt;/em&gt; is critically important. By &lt;em&gt;structure&lt;/em&gt;, I mean &lt;em&gt;algebraic structure&lt;/em&gt;: the operations that a type class provides us with satisfy some properties (the &lt;em&gt;laws&lt;/em&gt;) across &lt;em&gt;all types&lt;/em&gt; for which there is an instance.&lt;/p&gt;

&lt;p&gt;Without a notion of &lt;em&gt;structure&lt;/em&gt;, we cannot know the meaning of generic code. In the previous example of &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;sort&lt;/code&gt;, our polymorphic function requires the ability too totally order the elements of the list it is sorting. Without a notion of &lt;em&gt;total order&lt;/em&gt;, embedded into the laws of the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Ord&lt;/code&gt; type class, we cannot meaningfully define what it is to “sort” elements.&lt;/p&gt;

&lt;p&gt;Structure allows &lt;em&gt;abstraction&lt;/em&gt;: we can write code that is generic across a range of different types &lt;em&gt;precisely&lt;/em&gt; because we can &lt;em&gt;define&lt;/em&gt; the ways in which those types are similar. In the case of sorting, we can abstract over the element type, because we can define what it means to compare elements of a given type. Although &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Int&lt;/code&gt; and &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;String&lt;/code&gt; are quite different, they both posess enough structure to provide a total ordering.&lt;/p&gt;

&lt;p&gt;Abstraction is &lt;em&gt;not&lt;/em&gt; the same as &lt;em&gt;indirection&lt;/em&gt;. &lt;em&gt;Indirection&lt;/em&gt; provides a layer of insulation between our code and concrete data types, and is useful for testability and modularity.&lt;/p&gt;

&lt;p&gt;Indirection is not necessarily governed by laws (algebraic or otherwise). In object-oriented programming languages, interfaces are often used to provide &lt;em&gt;indirection&lt;/em&gt;, where it is sometimes mistakenly called &lt;em&gt;abstraction&lt;/em&gt;. In functional programming languages, records of functions or modules can be used to provide indirection.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;The structure that type classes provide is the foundation for writing well-defined generic code; without structure, there is no abstraction—only indirection.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;This leads to my rule of when to use type classes:&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;Consider using type classes whenever you can identify enough common structure across a range of data types that is by itself wholly sufficient for writing well-defined generic code across these data types&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Conversely, if you cannot identify common structure (through a set of well-defined algebraic laws), then you cannot write well-defined generic code across different data types. This is a strong sign that what you really want is &lt;em&gt;indirection&lt;/em&gt;, not abstraction.&lt;/p&gt;

&lt;p&gt;This leads to my rule of when &lt;strong&gt;not&lt;/strong&gt; to use type classes:&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;Consider using indirection whenever you cannot identify enough common structure across a range of data types that is wholly sufficient for writing well-defined generic code&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Now sometimes we can define structure across a range of data types, but that structure is not wholly sufficient for writing generic code.&lt;/p&gt;

&lt;p&gt;An example is the algebraic structure called &lt;em&gt;magma&lt;/em&gt;. A &lt;em&gt;magma&lt;/em&gt; provides an composition operation with &lt;em&gt;closure&lt;/em&gt; (that i8s, if you compose two values of the same type, you get back another value of the same type). This is less structure than a semigroup, because semigroups also provide a guarantee of &lt;em&gt;associativity&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;The guarantee of closure is so weak, that we cannot write much (if any) generic code that only requires this guarantee. In fact, closure is so weak, no laws are necessary to express: a parametrically polymorphic type system provides us this guarantee “for free”.&lt;/p&gt;

&lt;p&gt;This is why it is so critically important that the structure provided by the type class be sufficiently strong that useful generic code is possible.&lt;/p&gt;

&lt;p&gt;If you are looking at some structure that is sufficiently rare so as to permit very few useful instances for a given type, then there’s a good chance that a type class will allow you to write generically useful code. Conversely, if you are looking at some structure that permits infinitely many equally useful instances, then there’s a good chance having a type class will not allow you to write generically useful code.&lt;/p&gt;

&lt;p&gt;I consider these best practices for when to use and when not to use type classes. However, in the next section, I want to provide some practical reasons for following this advice, as well as show you what to do when type classes aren’t a good fit.&lt;/p&gt;

&lt;h2 id=&quot;the-power-of-values&quot;&gt;The Power of Values&lt;/h2&gt;

&lt;p&gt;Type classes provide a means of accessing structure as a function of type.&lt;/p&gt;

&lt;p&gt;As I have defined them, anyway, a type class has a &lt;em&gt;single&lt;/em&gt; instance for any type. If for any reason a type class had &lt;em&gt;multiple&lt;/em&gt; instances for a given type, then this would imply that type classes are &lt;em&gt;not&lt;/em&gt; functions—at least, not &lt;em&gt;functions&lt;/em&gt; in the mathematical sense of the word, because they would map the same type to &lt;em&gt;different&lt;/em&gt; sets of operations.&lt;/p&gt;

&lt;p&gt;Such non-determinism would mean that any given type would no longer map to a unique set of operations. It would further imply that we could not know, just looking at a concrete type, what set of operations a type class would give us access to.&lt;/p&gt;

&lt;p&gt;Indeed, one of the chief problems of introducing non-determinism into my definition of a type class is that simple refactorings, like moving a function from one file to another, can change the runtime behavior of your program—a fact that Scala developers know all too well, thanks to their exposure to &lt;em&gt;implicit abuse&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Ensuring that type classes are &lt;em&gt;globally coherent&lt;/em&gt; gives us the ability to clearly and easily understand how our program will behave, and to preserve this behavior in the presence of refactoring, without having to be cautious.&lt;/p&gt;

&lt;p&gt;Yet, while global coherence (&lt;em&gt;determinism&lt;/em&gt; of the type class function) is important for reasoning and refactoring, there is something distinctly anti-modular about type classes. Type classes are, after all, &lt;em&gt;global&lt;/em&gt;, &lt;em&gt;piecewise&lt;/em&gt; defined functions from types to sets of operations.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Global&lt;/em&gt; definitions are opposed to &lt;em&gt;local&lt;/em&gt; definitions, and &lt;em&gt;local, compositional definitions&lt;/em&gt; are the foundation of &lt;em&gt;modularity&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Herein lies the fundamental tradeoff of type classes: type classes provide global (anti-modular), type-directed reasoning that stems from the very algebraic structure of the types in question; while modules and their weaker variants (records of functions), provide local (modular), value-directed reasoning that stems from the makeup of the values themselves.&lt;/p&gt;

&lt;p&gt;Although the battle between type classes and modules goes back for decades, there is no real competition, because while type classes are a natural fit for algebraic structure, modules (or records of functions) are a natural fit for indirection.&lt;/p&gt;

&lt;p&gt;Indirection gives us loose coupling between pieces of the whole, allowing us to, for example, connect to different types of databases at runtime, accessing them through a uniform interface; allowing us to support local logging, but also remote logging; allowing us to have a local file system, and a remote one; and allowing us to have test implementations, as well as production implementations.&lt;/p&gt;

&lt;p&gt;Type classes give us algebraic structure in the small, and indirection gives us modularity in the large. They do not compete with each other, but rather, compliment each other, and the weaknesses of the one are the strengths of the other.&lt;/p&gt;

&lt;p&gt;Some beautiful properties of modules (and records of functions) include the following:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;Superior Composition&lt;/strong&gt;. We can take values, and compose them with other values, to yield values. While type class composition is possible, it looks and feels awkward because it has to be encoded in a different language than the primary, expression-oriented language that we write most of our code in.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;No Dependence on Type&lt;/strong&gt;. While type classes are functions of types to values, modules are just ordinary values, so for a given type (or set of types), we can have as many different modules as we like. For example, we can have a different database module for each underlying database type (MySQL, PostgreSQL, SQL Server, etc.), not connected to the type of effect we are using or any other type.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Superior Customization&lt;/strong&gt;. We can easily and programmatically mix and match pieces of different modules, for example, drilling into a module and adding instrumentation to a single operation. Optics make these types of customizations trivial, but optics work on data, and type classes are not data.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The benefits of working with ordinary values are tremendous and should not be overlooked. Now it’s also true that type classes have their own benefits. The lure of these benefits is sometimes so strong, it leads to &lt;em&gt;type class abuse&lt;/em&gt;.&lt;/p&gt;

&lt;h2 id=&quot;type-class-abuse&quot;&gt;Type Class Abuse&lt;/h2&gt;

&lt;p&gt;Type class abuse is what happens when we use a type class to represent something that &lt;em&gt;should&lt;/em&gt; be a module (or record of functions).&lt;/p&gt;

&lt;p&gt;Typical symptoms of type class abuse include the following:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;The type class has &lt;em&gt;no laws&lt;/em&gt; that permit well-defined generic use of the type class&lt;/li&gt;
  &lt;li&gt;There are &lt;em&gt;many&lt;/em&gt; possible useful instances of the type class for a given type&lt;/li&gt;
  &lt;li&gt;The type class exists primarily to avoid passing or composing values&lt;/li&gt;
&lt;/ul&gt;


  &lt;p&gt;&lt;a href=&quot;https://degoes.net/articles/when-to-typeclass&quot;&gt;Type Classes: When To Use Them, When To Avoid Them&lt;/a&gt; was originally published by John A De Goes at &lt;a href=&quot;https://degoes.net&quot;&gt;John <em>A</em> <strong>De Goes</strong>&lt;/a&gt; on April 20, 2019.&lt;/p&gt;</content>
</entry>


<entry>
  <title type="html"><![CDATA[ZIO & Cats Effect: A Match Made in Heaven]]></title>
  <link rel="alternate" type="text/html" href="https://degoes.net/articles/zio-cats-effect" />
  <id>https://degoes.net/articles/zio-cats-effect</id>
  <published>2019-04-18T00:00:00-06:00</published>
  <updated>2019-04-18T00:00:00-06:00</updated>
  <author>
    <name>John A De Goes</name>
    <uri>https://degoes.net</uri>
    <email>john@degoes.net</email>
  </author>
  <content type="html">&lt;p&gt;Cats Effect has become the &lt;a href=&quot;https://www.reactive-streams.org&quot;&gt;“Reactive Streams”&lt;/a&gt; of the functional Scala world, enabling a diverse ecosystem of libraries to work together.&lt;/p&gt;

&lt;p&gt;Many great libraries like http4s, FS2, and Doobie are built on the Cats Effect type classes, and effect libraries like &lt;a href=&quot;https://github.com/scalaz/scalaz-zio&quot;&gt;ZIO&lt;/a&gt; and Monix provide instances of these type classes for their effect types.&lt;/p&gt;

&lt;p&gt;Although not without a few drawbacks, many of which will be &lt;a href=&quot;https://github.com/typelevel/cats-effect/issues/321&quot;&gt;rectified in 3.0&lt;/a&gt;, the Cats Effect library is helping many open source contributors economically support the whole functional Scala ecosystem.&lt;/p&gt;

&lt;p&gt;Application developers who use Cats Effect face a far more difficult choice: which of the major effect types they will use to build their applications.&lt;/p&gt;

&lt;p&gt;Application developers have three major choices:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Cats IO, the reference implementation in Cats Effect&lt;/li&gt;
  &lt;li&gt;Monix, with its &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Task&lt;/code&gt; data type and associated reactive machinery&lt;/li&gt;
  &lt;li&gt;More recently, ZIO, with its &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ZIO&lt;/code&gt; data type and concurrent machinery&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;In this post, I’m going to argue that if you are building a Cats Effect application, then ZIO provides a compelling choice, one with design choices and features quite different than the Cats IO reference implementation.&lt;/p&gt;

&lt;p&gt;Without further ado, let’s take a look at my top 12 reasons why ZIO and Cats Effect are a match made in heaven!&lt;/p&gt;

&lt;h1 id=&quot;1-better-mtl--tagless-final&quot;&gt;1. Better MTL / Tagless-Final&lt;/h1&gt;

&lt;p&gt;MTL, which stands for &lt;em&gt;Monad Transformers Library&lt;/em&gt;, is a style of programming where functions are &lt;em&gt;polymorphic&lt;/em&gt; in their effect type, expressing their requirements through &lt;em&gt;type class constraints&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;In Scala, this is often called the &lt;em&gt;tagless-final&lt;/em&gt; style (although they are not exactly the same thing), especially when the type classes have no laws.&lt;/p&gt;

&lt;p&gt;It is well-known that it is impossible to define global instances for such classic MTL type classes as &lt;em&gt;Writer&lt;/em&gt; and &lt;em&gt;State&lt;/em&gt; for effect types like Cats IO.&lt;/p&gt;

&lt;p&gt;The reason is that the instances of these type classes for effect types requires access to mutable state, which cannot be created globally, because the creation of mutable state is effectful.&lt;/p&gt;

&lt;p&gt;For &lt;a href=&quot;/articles/effects-without-transformers&quot;&gt;performance reasons&lt;/a&gt;, however, it’s critical to avoid monad transformers, and provide an implementation of &lt;em&gt;Writer&lt;/em&gt; and &lt;em&gt;State&lt;/em&gt; directly atop the underlying effect type.&lt;/p&gt;

&lt;p&gt;To accomplish this, functional Scala developers use a trick: they effectfully (but purely) create instances at the top level of their program, and then provide them downstream as local implicits:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-scala&quot; data-lang=&quot;scala&quot;&gt;&lt;span class=&quot;nv&quot;&gt;Ref&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;py&quot;&gt;make&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;AppState&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;](&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;initialAppState&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;).&lt;/span&gt;&lt;span class=&quot;py&quot;&gt;flatMap&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ref&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;=&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;implicit&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;monadState&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;MonadState&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;Task&lt;/span&gt;, &lt;span class=&quot;kt&quot;&gt;AppState&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;get&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Task&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;AppState&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;ref&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;py&quot;&gt;get&lt;/span&gt; 

    &lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;set&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;AppState&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Task&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;Unit&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;ref&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;py&quot;&gt;set&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;).&lt;/span&gt;&lt;span class=&quot;py&quot;&gt;unit&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

  &lt;span class=&quot;n&quot;&gt;myProgram&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Although this trick is useful, it is also a hack. In a perfect world, all type class instances would be globally coherent (&lt;em&gt;one instance per type&lt;/em&gt;)—not created locally and effectfully and then magically turned into implicit values to feed downstream methods.&lt;/p&gt;

&lt;p&gt;A remarkable property about MTL / tagless-final is that you can &lt;em&gt;directly&lt;/em&gt; define most instances atop the ZIO data type, by using &lt;a href=&quot;/articles/zio-environment&quot;&gt;ZIO Environment&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Here’s one way to create a global definition of &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;MonadState&lt;/code&gt; for the ZIO data type:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-scala&quot; data-lang=&quot;scala&quot;&gt;&lt;span class=&quot;k&quot;&gt;trait&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;State&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;S&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt;
  &lt;span class=&quot;nc&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;state&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Ref&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;S&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;implicit&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;ZIOMonadState&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;S&lt;/span&gt;, &lt;span class=&quot;kt&quot;&gt;R&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;&amp;lt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;State&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;S&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt;, &lt;span class=&quot;kt&quot;&gt;E&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;MonadState&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;ZIO&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;R&lt;/span&gt;, &lt;span class=&quot;kt&quot;&gt;E&lt;/span&gt;, &lt;span class=&quot;kt&quot;&gt;?&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt;, &lt;span class=&quot;kt&quot;&gt;S&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;=&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;MonadState&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;ZIO&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;R&lt;/span&gt;, &lt;span class=&quot;kt&quot;&gt;E&lt;/span&gt;, &lt;span class=&quot;kt&quot;&gt;?&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt;, &lt;span class=&quot;kt&quot;&gt;S&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;get&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;ZIO&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;R&lt;/span&gt;, &lt;span class=&quot;kt&quot;&gt;E&lt;/span&gt;, &lt;span class=&quot;kt&quot;&gt;S&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;ZIO&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;py&quot;&gt;accessM&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;_&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;py&quot;&gt;state&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;py&quot;&gt;get&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;set&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;S&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;ZIO&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;R&lt;/span&gt;, &lt;span class=&quot;kt&quot;&gt;E&lt;/span&gt;, &lt;span class=&quot;kt&quot;&gt;Unit&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;ZIO&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;py&quot;&gt;accessM&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;_&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;py&quot;&gt;state&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;py&quot;&gt;set&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;).&lt;/span&gt;&lt;span class=&quot;py&quot;&gt;unit&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;This instance is now defined globally for any environment that supports at least &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;State[S]&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Similarly for &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;FunctorListen&lt;/code&gt;, otherwise known as &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;MonadWriter&lt;/code&gt;:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-scala&quot; data-lang=&quot;scala&quot;&gt;&lt;span class=&quot;k&quot;&gt;trait&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Writer&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;W&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt;
  &lt;span class=&quot;nc&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;writer&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Ref&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;W&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;implicit&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;ZIOFunctorListen&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;W:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Semigroup&lt;/span&gt;, &lt;span class=&quot;kt&quot;&gt;R&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;&amp;lt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Writer&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;W&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt;, &lt;span class=&quot;kt&quot;&gt;E&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;FunctorListen&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;ZIO&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;R&lt;/span&gt;, &lt;span class=&quot;kt&quot;&gt;E&lt;/span&gt;, &lt;span class=&quot;kt&quot;&gt;?&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt;, &lt;span class=&quot;kt&quot;&gt;W&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;=&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;FunctorListen&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;ZIO&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;R&lt;/span&gt;, &lt;span class=&quot;kt&quot;&gt;E&lt;/span&gt;, &lt;span class=&quot;kt&quot;&gt;?&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt;, &lt;span class=&quot;kt&quot;&gt;W&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;listen&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;A&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;](&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;fa&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;ZIO&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;R&lt;/span&gt;, &lt;span class=&quot;kt&quot;&gt;E&lt;/span&gt;, &lt;span class=&quot;kt&quot;&gt;A&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;])&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;ZIO&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;R&lt;/span&gt;, &lt;span class=&quot;kt&quot;&gt;E&lt;/span&gt;, &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;A&lt;/span&gt;, &lt;span class=&quot;kt&quot;&gt;W&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)]&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;=&lt;/span&gt; 
      &lt;span class=&quot;nv&quot;&gt;ZIO&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;py&quot;&gt;accessM&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;_&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;py&quot;&gt;state&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;py&quot;&gt;get&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;py&quot;&gt;flatMap&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;w&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;fa&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;py&quot;&gt;map&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;w&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)))&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;tell&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;w&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;W&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;ZIO&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;R&lt;/span&gt;, &lt;span class=&quot;kt&quot;&gt;E&lt;/span&gt;, &lt;span class=&quot;kt&quot;&gt;W&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;=&lt;/span&gt; 
      &lt;span class=&quot;nv&quot;&gt;ZIO&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;py&quot;&gt;accessM&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;_&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;py&quot;&gt;state&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;py&quot;&gt;update&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;_&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;|+|&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;w&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;).&lt;/span&gt;&lt;span class=&quot;py&quot;&gt;unit&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;And of course, we can do the same for &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;MonadError&lt;/code&gt;:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-scala&quot; data-lang=&quot;scala&quot;&gt;&lt;span class=&quot;k&quot;&gt;implicit&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;ZIOMonadError&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;R&lt;/span&gt;, &lt;span class=&quot;kt&quot;&gt;E&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;MonadError&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;ZIO&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;R&lt;/span&gt;, &lt;span class=&quot;kt&quot;&gt;E&lt;/span&gt;, &lt;span class=&quot;kt&quot;&gt;?&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt;, &lt;span class=&quot;kt&quot;&gt;E&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;=&lt;/span&gt; 
  &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;MonadError&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;ZIO&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;R&lt;/span&gt;, &lt;span class=&quot;kt&quot;&gt;E&lt;/span&gt;, &lt;span class=&quot;kt&quot;&gt;?&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt;, &lt;span class=&quot;kt&quot;&gt;E&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;handleErrorWith&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;A&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;](&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;fa&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;ZIO&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;R&lt;/span&gt;, &lt;span class=&quot;kt&quot;&gt;E&lt;/span&gt;, &lt;span class=&quot;kt&quot;&gt;A&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;])(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;E&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;ZIO&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;R&lt;/span&gt;, &lt;span class=&quot;kt&quot;&gt;E&lt;/span&gt;, &lt;span class=&quot;kt&quot;&gt;A&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;])&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;ZIO&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;R&lt;/span&gt;, &lt;span class=&quot;kt&quot;&gt;E&lt;/span&gt;, &lt;span class=&quot;kt&quot;&gt;A&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;=&lt;/span&gt; 
      &lt;span class=&quot;n&quot;&gt;fa&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;catchAll&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;raiseError&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;A&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;](&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;E&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;ZIO&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;R&lt;/span&gt;, &lt;span class=&quot;kt&quot;&gt;E&lt;/span&gt;, &lt;span class=&quot;kt&quot;&gt;A&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;ZIO&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;py&quot;&gt;fail&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;This technique is readily applicable to other type classes, including tagless-final type classes, whose instances may require effectfully-created state (mutable, configuration, etc.), testable effectful functions (combining environmental effects with tagless-final), or anything else that is readily accessible from the environment.&lt;/p&gt;

&lt;p&gt;So if you love using MTL-style, or find the benefits of tagless-final outweigh the costs, then using ZIO lets you easily define &lt;em&gt;global&lt;/em&gt; instances for all your favorite type classes.&lt;/p&gt;

&lt;p&gt;No slow monad transformers, no effectfully created type class instances, no local implicits, and no hacks. Just straight up pure functional programming!&lt;/p&gt;

&lt;h1 id=&quot;2-resource-safety-for-mortals&quot;&gt;2. Resource-Safety for Mortals&lt;/h1&gt;

&lt;p&gt;An early defining feature of ZIO was &lt;em&gt;interruption&lt;/em&gt;, the ability for the ZIO runtime to instantaneously cancel any executing effect, safely cleaning up all resources; and a course-grained version of this feature eventually made its way into Cats IO.&lt;/p&gt;

&lt;p&gt;This feature, called &lt;em&gt;async exceptions&lt;/em&gt; in Haskell, allows composable and efficient timeouts, efficient parallel and race operations, and globally efficient computation.&lt;/p&gt;

&lt;p&gt;While extremely powerful, interruption poses unique challenges for resource safety.&lt;/p&gt;

&lt;p&gt;Programmers are mostly used to mentally tracking failure in their applications, or ZIO uses the type system to help track failure. But interruption is different. An effect composed from many other effects can be interrupted at &lt;em&gt;any&lt;/em&gt; boundary.&lt;/p&gt;

&lt;p&gt;Take the following effect:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-scala&quot; data-lang=&quot;scala&quot;&gt;&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;handle&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;&amp;lt;-&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;openFile&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;file&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;   &lt;span class=&quot;k&quot;&gt;&amp;lt;-&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;readFile&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;handle&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;_&lt;/span&gt;      &lt;span class=&quot;k&quot;&gt;&amp;lt;-&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;closeFile&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;handle&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;yield&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Most programmers would not be surprised that if &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;readFile&lt;/code&gt; failed, then the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;closeFile&lt;/code&gt; would not be executed. Fortunately, effect systems have &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ensuring&lt;/code&gt; (called &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;guarantee&lt;/code&gt; in Cats Effect) that lets you add a finalizer to an effect, similar to &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;finally&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;So the main problem with the above effect can be fixed simply:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-scala&quot; data-lang=&quot;scala&quot;&gt;&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;handle&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;&amp;lt;-&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;openFile&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;file&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;   &lt;span class=&quot;k&quot;&gt;&amp;lt;-&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;readFile&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;handle&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;).&lt;/span&gt;&lt;span class=&quot;py&quot;&gt;ensuring&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;closeFile&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;handle&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;))&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;yield&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;()&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Now the effect is &lt;em&gt;failure-proof&lt;/em&gt;, in the sense that if &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;readFile&lt;/code&gt; fails, then the file will be closed; and if &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;readFile&lt;/code&gt; succeeds, the file will be closed; so in “all” cases, the file will be closed.&lt;/p&gt;

&lt;p&gt;Well, not quite &lt;em&gt;all&lt;/em&gt;. &lt;em&gt;Interruption&lt;/em&gt; means that the executing effect can be terminated anywhere, even &lt;em&gt;between&lt;/em&gt; the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;openFile&lt;/code&gt; and the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;readFile&lt;/code&gt;. If this happens, then the opened resource will not be closed, and a leak will result.&lt;/p&gt;

&lt;p&gt;This pattern of acquiring and releasing a resource is so common, that ZIO introduced a &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;bracket&lt;/code&gt; operator that made its way to Cats Effect 1.0.&lt;/p&gt;

&lt;p&gt;The &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;bracket&lt;/code&gt; operator is &lt;em&gt;interruption-proof&lt;/em&gt;: if the acquire succeeds, then release will be called, no matter what, even if the effect that uses the resource is interrupted. Further, neither the acquire nor release can be interrupted, providing a strong guarantee of resource safety.&lt;/p&gt;

&lt;p&gt;With &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;bracket&lt;/code&gt;, the above example looks like this:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-scala&quot; data-lang=&quot;scala&quot;&gt;&lt;span class=&quot;nf&quot;&gt;openFile&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;file&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;).&lt;/span&gt;&lt;span class=&quot;py&quot;&gt;bracket&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;closeFile&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;_&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;))(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;readFile&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;_&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;))&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Unfortunately, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;bracket&lt;/code&gt; only encapsulates one (particularly common) pattern of resource consumption; there are many others, especially with concurrent data structures, whose acquisition must be &lt;em&gt;interruptible&lt;/em&gt; in order to avoid a different kind of leak.&lt;/p&gt;

&lt;p&gt;In general, when programming with interruption, there are two things we want to do:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Prevent interruption from happening in some region that is otherwise interruptible&lt;/li&gt;
  &lt;li&gt;Allow interruption to happen in some region that is otherwise uninterruptible&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;ZIO has facilities to make both of these very easy. For example, we can implement our own version of &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;bracket&lt;/code&gt; using lower-level features built into ZIO:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-scala&quot; data-lang=&quot;scala&quot;&gt;&lt;span class=&quot;nv&quot;&gt;ZIO&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;py&quot;&gt;uninterruptible&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;    &lt;span class=&quot;k&quot;&gt;&amp;lt;-&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;acquire&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;exit&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;&amp;lt;-&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;ZIO&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;py&quot;&gt;interruptible&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;use&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)).&lt;/span&gt;&lt;span class=&quot;py&quot;&gt;run&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;py&quot;&gt;flatMap&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;exit&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;release&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;exit&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;).&lt;/span&gt;&lt;span class=&quot;py&quot;&gt;const&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;exit&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;))&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;    &lt;span class=&quot;k&quot;&gt;&amp;lt;-&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;ZIO&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;py&quot;&gt;done&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;exit&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;yield&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;In this code, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;use(a)&lt;/code&gt; is the only part that can be interrupted, and the surrounding code takes care to execute &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;release&lt;/code&gt; in any case.&lt;/p&gt;

&lt;p&gt;Interruptibility can be arbitrarily checked, turned off, or turned on, and only &lt;em&gt;two&lt;/em&gt; primitive operations are necessary (all others are derived from these).&lt;/p&gt;

&lt;p&gt;This compositional, full-featured model of interruptibility allows not just a clean implementation of &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;bracket&lt;/code&gt;, but clean implementations of other scenarios in resource handling, which carefully balance the tradeoffs inherit in interruptibility.&lt;/p&gt;

&lt;p&gt;Cats IO chose to provide only a &lt;em&gt;single&lt;/em&gt; operation to manage interruptibility: a combinator called &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;uncancelable&lt;/code&gt;. This makes a whole region uninterruptible. However, by itself the operation is of limited use, and can easily lead to code that wastes resources or deadlocks.&lt;/p&gt;

&lt;p&gt;While it turns out that one can define an operator that provides more control over interruption atop Cats IO, the (quite clever!) &lt;a href=&quot;https://github.com/SystemFw/playground/blob/d84aebb5fc1d2ccc4328afdca7ec8e923ef5a288/src/main/scala/Playground.scala&quot;&gt;implementation by Fabio Labella&lt;/a&gt; is insanely complex and not performant.&lt;/p&gt;

&lt;p&gt;ZIO lets anyone write interruption-friendly code, operating at a high-level, with declarative, composable operators, and doesn’t force you to either choose between extreme complexity and poor performance on the one hand, and wasted resources and deadlocks on the other.&lt;/p&gt;

&lt;p&gt;Moreover, although not discussed in this post, the newly-added &lt;a href=&quot;https://www.youtube.com/watch?list=PL8NC5lCgGs6MYG0hR_ZOhQLvtoyThURka&amp;amp;v=d6WWmia0BPM&quot;&gt;Software Transactional Memory&lt;/a&gt; in ZIO lets users declaratively write data structures and code that is automatically asynchronous, concurrent, and safely interruptible.&lt;/p&gt;

&lt;h1 id=&quot;3-guaranteed-finalizers&quot;&gt;3. Guaranteed Finalizers&lt;/h1&gt;

&lt;p&gt;The &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;try&lt;/code&gt; / &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;finally&lt;/code&gt; construct in many programming languages provides us the robust guarantees we need to write synchronous code that doesn’t leak resources.&lt;/p&gt;

&lt;p&gt;In particular, the construct provides the following guarantee:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;If the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;try&lt;/code&gt; block begins execution, then the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;finally&lt;/code&gt; block will begin execution when the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;try&lt;/code&gt; block stops execution&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;This guarantee holds even if:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;There are nested &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;try&lt;/code&gt; / &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;finally&lt;/code&gt; blocks&lt;/li&gt;
  &lt;li&gt;There are errors in the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;try&lt;/code&gt; block&lt;/li&gt;
  &lt;li&gt;There are errors in a nested &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;finally&lt;/code&gt; block&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;ZIO’s &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ensuring&lt;/code&gt; operation can be used exactly like &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;try&lt;/code&gt; / &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;finally&lt;/code&gt;:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-scala&quot; data-lang=&quot;scala&quot;&gt;&lt;span class=&quot;k&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;effect2&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;effect&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;py&quot;&gt;ensuring&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cleanup&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;ZIO provides the following guarantee on &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;effect.ensuring(finalizer)&lt;/code&gt;:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;If &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;effect&lt;/code&gt; begins execution, then &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;finalizer&lt;/code&gt; will begin execution when the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;effect&lt;/code&gt; stops execution&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Like &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;try&lt;/code&gt; / &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;finally&lt;/code&gt;, this guarantee holds even if:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;There are nested &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ensuring&lt;/code&gt; compositions&lt;/li&gt;
  &lt;li&gt;There are errors in &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;effect&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;There are errors in any nested finalizer&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Moreover, the guarantee holds even if the effect is &lt;em&gt;interrupted&lt;/em&gt; (the guarantees on &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;bracket&lt;/code&gt; are similar, and in fact, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;bracket&lt;/code&gt; is implemented on &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ensuring&lt;/code&gt;).&lt;/p&gt;

&lt;p&gt;The Cats IO data type chose a different, weaker guarantee. For &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;effect.guarantee(finalizer)&lt;/code&gt;, the guarantee is weakened as follows:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;If &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;effect&lt;/code&gt; begins execution, then &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;finalizer&lt;/code&gt; will begin execution when the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;effect&lt;/code&gt; stops execution, &lt;strong&gt;unless&lt;/strong&gt; problematic effects are composed into &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;effect&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;This weakening also occurs for the Cats IO implementation of &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;bracket&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;In order to leak resources, it is only necessary to compose, somewhere in the effect of &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;guarantee&lt;/code&gt;, or inside the “use” effect of &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;bracket&lt;/code&gt;, an effect similar to the following:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-scala&quot; data-lang=&quot;scala&quot;&gt;&lt;span class=&quot;c1&quot;&gt;// Assume `interruptedFiber` is some fiber that is already interrupted:
&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;bigTrouble&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;interruptedFiber&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;py&quot;&gt;join&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;When &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;bigTrouble&lt;/code&gt; is so composed into another effect, the effect becomes &lt;em&gt;non-terminating&lt;/em&gt;—neither finalizers installed with &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;guarantee&lt;/code&gt; nor cleanup effects installed with &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;bracket&lt;/code&gt; will be executed, leading to &lt;em&gt;resource leaks&lt;/em&gt; and &lt;em&gt;skipped&lt;/em&gt; finalization.&lt;/p&gt;

&lt;p&gt;For example, the finalizer in the following code will never begin execution:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-scala&quot; data-lang=&quot;scala&quot;&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;IO&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;py&quot;&gt;unit&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;bigTrouble&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;).&lt;/span&gt;&lt;span class=&quot;py&quot;&gt;guarantee&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;IO&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Won't be executed!!!&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)))&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Using local reasoning, it is not possible to know if an effect like &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;bigTrouble&lt;/code&gt; is being composed somewhere in the “use” effect of bracket or inside of a finalizer.&lt;/p&gt;

&lt;p&gt;Therefore, you cannot know if a Cats IO program will leak resources or skip finalization without global program analysis. Global program analysis is a manual, error-prone process that cannot be checked by the compiler, and which must be repeated every time any relevant part of the code changes.&lt;/p&gt;

&lt;p&gt;ZIO has custom implementations of the Cats Effect &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;guarantee&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;guaranteeCase&lt;/code&gt;, and &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;bracket&lt;/code&gt; operations. The implementations use native ZIO semantics (not Cats IO semantics), which allow you to reason locally about resource safety, knowing that in all cases, finalizers &lt;em&gt;will&lt;/em&gt; be run and resources &lt;em&gt;will&lt;/em&gt; be freed.&lt;/p&gt;

&lt;h1 id=&quot;4-stable-shifting&quot;&gt;4. Stable Shifting&lt;/h1&gt;

&lt;p&gt;Cats Effect has an &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;evalOn&lt;/code&gt; method of &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ContextShift&lt;/code&gt;, which allows moving the execution of some code to another execution context.&lt;/p&gt;

&lt;p&gt;This turns out to be quite handy for a number of reasons:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Many client libraries require you to do some work in their thread pool&lt;/li&gt;
  &lt;li&gt;UI libraries require some updates to be done on the UI thread&lt;/li&gt;
  &lt;li&gt;Some effects need to be isolated on thread pools tailored for their specific needs&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;evalOn&lt;/code&gt; operation is designed to execute an effect where it needs to be run, and then hop back to the original execution context. For example:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-scala&quot; data-lang=&quot;scala&quot;&gt;&lt;span class=&quot;nv&quot;&gt;cs&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;py&quot;&gt;evalOn&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;kafkaContext&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;kafkaEffect&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;&lt;em&gt;Note&lt;/em&gt;: Cats IO has a related construct called &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;shift&lt;/code&gt; that allows you to “hop” over to another context without hopping back, but in practice, this behavior is almost never desired, so the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;evalOn&lt;/code&gt; variation is strongly preferred.&lt;/p&gt;

&lt;p&gt;ZIO’s implementation of &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;evalOn&lt;/code&gt; (built on the ZIO primitive &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;lock&lt;/code&gt;) provides a guarantee necessary for local reasoning about where effects are running:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;The effect will always execute on the specified context&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Cats IO chose a different, weaker guarantee:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;The effect will execute on the specified context &lt;strong&gt;until&lt;/strong&gt; the first asynchronous operation or embedded shift&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Using just local reasoning, it is not possible to know if an asynchronous effect (or nested shift) is being composed into the effect being shifted, because asynchronicity is not reflected in types.&lt;/p&gt;

&lt;p&gt;Therefore, as with resource safety, knowing where a Cats IO effect will run requires global program analysis. In practice, and from my experience, users of Cats IO are quite surprised when they use &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;evalOn&lt;/code&gt; with one context, and then later find out that most of the effect has been accidentally executed on some other context.&lt;/p&gt;

&lt;p&gt;ZIO lets you specify where effects should run and trust that will actually happen, in all cases, regardless of how effects are composed with other effects.&lt;/p&gt;

&lt;h1 id=&quot;5-lossless-errors&quot;&gt;5. Lossless Errors&lt;/h1&gt;

&lt;p&gt;Any effect type that supports concurrency, parallelism, or resource safety runs into an immediate problem with a linear error model: in general, errors don’t compose.&lt;/p&gt;

&lt;p&gt;This holds both for &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Throwable&lt;/code&gt;, the fixed error type baked into Cats IO, and for polymorphic error types, which are supported by ZIO.&lt;/p&gt;

&lt;p&gt;All the following situations can lead to multiple errors being produced:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;A finalizer throwing an exception&lt;/li&gt;
  &lt;li&gt;Two (failing) effects being combined in parallel&lt;/li&gt;
  &lt;li&gt;Two (failing) effects being raced&lt;/li&gt;
  &lt;li&gt;An interrupted effect also failing before exiting an uninterruptible section&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Because errors do not compose, ZIO has a data structure called &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Cause[E]&lt;/code&gt;, which provides a free &lt;em&gt;semiring&lt;/em&gt; (an abstraction from abstract algebra, which you can safely ignore if you haven’t heard about before!), which allows lossless composition of sequential and parallel errors for any arbitrary error type.&lt;/p&gt;

&lt;p&gt;During all operations (including cleanup for a failed or interrupted effect), ZIO aggregates errors into the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Cause[E]&lt;/code&gt; data structure, which can be accessed at any time.&lt;/p&gt;

&lt;p&gt;As a result, ZIO never loses any errors: they can all be accessed at the value level, and then logged, inspected, or transformed, as dictated by business requirements.&lt;/p&gt;

&lt;p&gt;Cats IO chose to embrace a lossy error model. Wherever ZIO would compose two errors using &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Cause[E]&lt;/code&gt;, Cats IO “throws” one error away—for example, by calling &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;e.printStackTrace()&lt;/code&gt; on the tossed error.&lt;/p&gt;

&lt;p&gt;For example, the finalizer error in this snippet will be “thrown away”:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-scala&quot; data-lang=&quot;scala&quot;&gt;&lt;span class=&quot;nv&quot;&gt;IO&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;py&quot;&gt;raiseError&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Error&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Error 1&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)).&lt;/span&gt;&lt;span class=&quot;py&quot;&gt;guarantee&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;IO&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;py&quot;&gt;raiseError&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Error&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Error 2&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)))&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;This lossy side-channel error reporting means there is no way to locally detect and respond to the full range of errors that can occur as effects are composed.&lt;/p&gt;

&lt;p&gt;ZIO lets you use any error type you want, including &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Throwable&lt;/code&gt; (or more specific subtypes of &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Throwable&lt;/code&gt;, like &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;IOException&lt;/code&gt; or a custom exception hierarchy), giving you the guarantee that no errors will be lost during composition.&lt;/p&gt;

&lt;h1 id=&quot;6-deadlock-free-async&quot;&gt;6. Deadlock-Free Async&lt;/h1&gt;

&lt;p&gt;Both ZIO and Cats IO provide a constructor that allows one to take callback-based code, and lift it into an effect value.&lt;/p&gt;

&lt;p&gt;This capability is exposed via the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Async&lt;/code&gt; type class in Cats Effect:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-scala&quot; data-lang=&quot;scala&quot;&gt;&lt;span class=&quot;k&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;effect&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Task&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;Data&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;=&lt;/span&gt; 
  &lt;span class=&quot;nc&quot;&gt;Async&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;Task&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;].&lt;/span&gt;&lt;span class=&quot;py&quot;&gt;async&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;k&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;=&amp;gt;&lt;/span&gt; 
    &lt;span class=&quot;nf&quot;&gt;getDataWithCallbacks&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;onSuccess&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;v&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;k&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Right&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;v&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)),&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;onFailure&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;e&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;k&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Left&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;))&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;))&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;This creates an asynchronous effect that, when executed, will suspend until the value is available, and then resume—all transparently to the user of the effect. This property is what makes functional effect systems so pleasing for asynchronous code.&lt;/p&gt;

&lt;p&gt;Notice that as the callback-code is being lifted into the effect, a callback function (here called &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;k&lt;/code&gt;) is invoked. This callback function is provided with the success or error value.&lt;/p&gt;

&lt;p&gt;When this callback function is invoked, execution of the (suspended) effect resumes.&lt;/p&gt;

&lt;p&gt;ZIO provides the guarantee the effect will resume executing on either the runtime’s default thread pool, if the effect has not been locked to a specific context, or on the specific context the effect has been locked to.&lt;/p&gt;

&lt;p&gt;Cats IO chose to resume executing the effect on the thread invoking the callback.&lt;/p&gt;

&lt;p&gt;The difference between these decisions is quite profound. In general, the thread that is invoking the callback does not expect the callback code to continue indefinitely; it expects a short delay before control is returned to the caller.&lt;/p&gt;

&lt;p&gt;ZIO provides the guarantee that control is returned to the caller immediately, which can then resume execution normally.&lt;/p&gt;

&lt;p&gt;On the other hand, Cats IO provides no such guarantee, which means the caller thread invoking the callback may get “stuck” waiting indefinitely for control to be returned to it.&lt;/p&gt;

&lt;p&gt;Early versions of Cats Effect concurrent data structures (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Deferred&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Semaphore&lt;/code&gt;, etc.) resumed effects that did not promptly yield control back to the caller thread. As a result, they had problems with deadlocks and unfair scheduling. While all of these problems have been identified and fixed, they have only been fixed for &lt;em&gt;Cats Effect&lt;/em&gt; concurrent data structures.&lt;/p&gt;

&lt;p&gt;User-land code that uses a similar pattern with Cats IO will run into similar issues, and because of the nondeterminism involved, they may manfiest only occassionally, at runtime, making diagnosing and solving the issues challenging.&lt;/p&gt;

&lt;p&gt;ZIO’s model provides deadlock safety and fairness by default, and forces users to opt into the Cats IO behavior explicitly (by, for example, using &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;unsafeRun&lt;/code&gt; on a &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Promise&lt;/code&gt; that is completed from the resumed asynchronous effect).&lt;/p&gt;

&lt;p&gt;While neither choice is suitable in all cases, and while both ZIO and Cats IO provide enough flexibility to handle all cases (in different ways), the ZIO choice means worry-free use of &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Async&lt;/code&gt;, and pushes problematic code to &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;unsafeRun&lt;/code&gt;, which is already a known deadlock-risk.&lt;/p&gt;

&lt;h1 id=&quot;7-precise-future-interop&quot;&gt;7. Precise Future Interop&lt;/h1&gt;

&lt;p&gt;Dealing with Scala’s &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Future&lt;/code&gt; is a reality for many code bases. ZIO ships with a &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;fromFuture&lt;/code&gt; method that provides a ready-made execution context:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-scala&quot; data-lang=&quot;scala&quot;&gt;&lt;span class=&quot;nv&quot;&gt;ZIO&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;py&quot;&gt;fromFuture&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;implicit&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ec&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;=&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;c1&quot;&gt;// Create some Future using `ec`:
&lt;/span&gt;  &lt;span class=&quot;o&quot;&gt;???&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;When this method is used to lift a &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Future&lt;/code&gt; into an effect, ZIO can manage where the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Future&lt;/code&gt; is executed, and other methods like &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;evalOn&lt;/code&gt; will correctly migrate the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Future&lt;/code&gt; to the appropriate execution context.&lt;/p&gt;

&lt;p&gt;Cats IO chose to accept a &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Future&lt;/code&gt; that has already been constructed with an external &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ExecutionContext&lt;/code&gt;. This means that Cats IO has no way of shifting the execution of an embedded &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Future&lt;/code&gt; to conform with the semantics of &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;evalOn&lt;/code&gt; or &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;shift&lt;/code&gt;. Moreover, it burdens the user of the API to choose an execution context for the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Future&lt;/code&gt;, which means a fixed choice and separate plumbing.&lt;/p&gt;

&lt;p&gt;Since one can always choose to ignore the provided &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ExecutionContext&lt;/code&gt;, the ZIO choice can be seen as a strict generalization of Cats IO capabilities, providing more seamless and precise interop with &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Future&lt;/code&gt; in the common case, but not preventing exceptions to the rule.&lt;/p&gt;

&lt;h1 id=&quot;8-blocking-io&quot;&gt;8. Blocking IO&lt;/h1&gt;

&lt;p&gt;As covered in &lt;a href=&quot;/articles/zio-threads&quot;&gt;Thread Pool Best Practices with ZIO&lt;/a&gt;, server-side applications must have at least two separate thread pools for maximum efficiency:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;A fixed thread pool for CPU / async effects&lt;/li&gt;
  &lt;li&gt;A dynamic, growing thread pool for blocking effects&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;A choice to run all effects on a fixed thread pool will eventually lead to deadlock; while a choice to run all effects on a dynamic, growing thread pool will lead to gross inefficiency.&lt;/p&gt;

&lt;p&gt;On the JVM, ZIO provides two operators that provide direct support for blocking effects:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;The &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;blocking(effect)&lt;/code&gt; operator, which will shift execution of the specified effect to a blocking thread pool, which uses very good settings and can also be configured;&lt;/li&gt;
  &lt;li&gt;The &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;effectBlocking(effect)&lt;/code&gt; operator, which translates side-effectful blocking code into a pure effect, whose interruption will interrupt a lot of blocking code.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;If you have an effect, and you need to make sure it’s executed on a blocking thread pool, then you can wrap it in &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;blocking&lt;/code&gt;. On the other hand, if you are wrapping some side-effectful code that blocks, then you can wrap it in &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;effectBlocking&lt;/code&gt;, and benefit from ZIO’s composable, pervasive, and safe interruption (where possible).&lt;/p&gt;

&lt;p&gt;Cats IO chose to adopt a more minimal core, and delegate such functionality to user-land code. While there are libraries that help provide the functionality of the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;blocking&lt;/code&gt; operator, they are based on &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;evalOn&lt;/code&gt;, and therefore cannot actually guarantee execution on the blocking thread pool.&lt;/p&gt;

&lt;p&gt;Power users may very well want to configure their own custom blocking thread pool (which of course, you can do with ZIO), or create more than these two thread pools (for example, a thread pool for low-latency event dispatching), but these operations provide exactly the desired semantics for the vast majority of cases.&lt;/p&gt;

&lt;h1 id=&quot;9-cost-free-effects&quot;&gt;9. Cost-Free Effects&lt;/h1&gt;

&lt;p&gt;Many functional Scala applications end up using one or both of the following monad transformers:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ReaderT&lt;/code&gt; / &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Kleisli&lt;/code&gt;, which adds the effect of accessing an environment&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;EitherT&lt;/code&gt;, which adds the effect of typed errors (or &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;OptionT&lt;/code&gt;, which is a specialization of &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;EitherT&lt;/code&gt; with &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Unit&lt;/code&gt; as the failure type)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The pattern is so pervasive, whole libraries have been designed around one or the other (for example, &lt;em&gt;http4s&lt;/em&gt; extensively uses &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Kleisli&lt;/code&gt; and &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;OptionT&lt;/code&gt;).&lt;/p&gt;

&lt;p&gt;Using an advanced technique called &lt;a href=&quot;/articles/rotating-effects&quot;&gt;effect rotation&lt;/a&gt;, ZIO provides both the &lt;em&gt;reader&lt;/em&gt; and &lt;em&gt;typed error&lt;/em&gt; capabilities directly in the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ZIO&lt;/code&gt; data type.&lt;/p&gt;

&lt;p&gt;Because not every user will need reader and typed error capabilities, ZIO also provides a variety of type / companion synonyms that cover common cases. For example, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Task[A]&lt;/code&gt; provides only the core primary capability, without reader or typed errors.&lt;/p&gt;

&lt;p&gt;This allows ZIO to provide the two most common (secondary) effects in functional applications without any runtime overhead whatsoever. In addition, supporting these effects directly in ZIO actually &lt;em&gt;reduced&lt;/em&gt; the size of its runtime, allowing simpler code and pulling non-essential functionality out of the microkernel.&lt;/p&gt;

&lt;p&gt;Cats IO chose to provide just a primary effect. This means that users who need reader or typed errors, or just want hack-free implementations of state, writer, and other type classes, will likely find themselves using monad transformers.&lt;/p&gt;

&lt;p&gt;ZIO can be up to 8x faster than Cats IO with an equivalent effect stack. While the impact of effect overhead on application performance will depend on a great many factors, greater performance increases the number of applications for functional Scala, and allows developers to build their applications from fine-grained effects.&lt;/p&gt;

&lt;h1 id=&quot;10-microkernel-architecture&quot;&gt;10. Microkernel Architecture&lt;/h1&gt;

&lt;p&gt;ZIO utilizes a microkernel architecture, which pulls as much functionality as possible out of the runtime system, and into ordinary user-land code, written in pure functional Scala. Indeed, even parts of the microkernel are itself written in pure functional Scala, utilizing an even smaller core for bootstrapping.&lt;/p&gt;

&lt;p&gt;While the original ZIO kernel was roughly 2,000 lines of code, after introducing typed errors and environment, and eliminating redundancy and improving orthogonality, the entire microkernel is now 375 SLOC, in a single file.&lt;/p&gt;

&lt;p&gt;As the complexity of modern effect systems in Scala has grown, so has the potential for bugs. There are very few people in the world who understand how these systems work, and the potential for hidden bugs and edge cases is very high.&lt;/p&gt;

&lt;p&gt;Personally, I am a fan of microkernel effect systems for the following reasons:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;The smaller code can be more easily inspected for correctness&lt;/li&gt;
  &lt;li&gt;There are fewer places for bugs and edge-cases to hide&lt;/li&gt;
  &lt;li&gt;It is cheaper, faster, and safer to respond to real world feedback&lt;/li&gt;
  &lt;li&gt;It is easier for new contributors to help out with core maintenance&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Monolithic kernels can in theory be much better optimized. However, due to the volunteer nature of open source, we only have finite resources for optimization.&lt;/p&gt;

&lt;p&gt;Due to these constraints, often you can either micro-optimize a &lt;em&gt;part&lt;/em&gt; of a monolithic kernel, or micro-optimize the &lt;em&gt;whole&lt;/em&gt; of a microkernel. The former can give you super high-performance in a few cases, while the latter can give you great performance across a wide range of complex cases.&lt;/p&gt;

&lt;p&gt;Of all the effect systems out there, the ZIO runtime is by far the smallest. As a reference implementation, Cats IO comes in second place, but its runtime is at least &lt;em&gt;twice&lt;/em&gt; the size of the ZIO runtime (maybe &lt;em&gt;three&lt;/em&gt; times, depending on how you count).&lt;/p&gt;

&lt;h1 id=&quot;11-beginner-friendly&quot;&gt;11. Beginner-Friendly&lt;/h1&gt;

&lt;p&gt;ZIO has made many decisions to increase usability for new users, without cutting corners or sacrificing principles for advanced users. For example:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Jargon-free naming. For example:
    &lt;ul&gt;
      &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ZIO.succeed&lt;/code&gt; instead of &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Applicative[F].pure&lt;/code&gt;&lt;/li&gt;
      &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;zip&lt;/code&gt; instead of &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Apply[F].product&lt;/code&gt;&lt;/li&gt;
      &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ZIO.foreach&lt;/code&gt; instead of &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Traverse[F].traverse&lt;/code&gt;&lt;/li&gt;
      &lt;li&gt;Etc.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;No use of higher-kinded types or type classes (Cats, Cats Effect, and Scalaz instances are available in optional modules)&lt;/li&gt;
  &lt;li&gt;No implicits that have to be imported or summoned (except for &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Runtime&lt;/code&gt;, which must be implicit for all Cats Effect projects, due to the current design of Cats Effect); implicits are a constant source of frustration for new Cats IO users&lt;/li&gt;
  &lt;li&gt;No required syntax classes&lt;/li&gt;
  &lt;li&gt;Auto-complete-friendly naming that groups similar methods by prefix. For example:
    &lt;ul&gt;
      &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;zip&lt;/code&gt; / &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;zipPar&lt;/code&gt;&lt;/li&gt;
      &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ZIO.foreach&lt;/code&gt; / &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ZIO.foreachPar&lt;/code&gt;&lt;/li&gt;
      &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ZIO.succeed&lt;/code&gt; / &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ZIO.succeedLazy&lt;/code&gt;&lt;/li&gt;
      &lt;li&gt;etc.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Concrete methods on concrete data types, which aids discoverability and traversability, and makes ZIO very usable in IDEs&lt;/li&gt;
  &lt;li&gt;Conversion from all Scala data types to the ZIO effect type
    &lt;ul&gt;
      &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ZIO.fromFuture&lt;/code&gt;&lt;/li&gt;
      &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ZIO.fromOption&lt;/code&gt;&lt;/li&gt;
      &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ZIO.fromEither&lt;/code&gt;&lt;/li&gt;
      &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ZIO.fromTry&lt;/code&gt;&lt;/li&gt;
      &lt;li&gt;etc.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Full, out-of-the-box type inference for all data types and methods&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Anecdotally, I have seen people with no prior background in functional Scala successfully build prototypes using ZIO without any external assistance, and before there was any good documentation—unaware that by using ZIO, they were writing purely functional code.&lt;/p&gt;

&lt;p&gt;Cats IO chose to delegate most functionality, names, and decisions around type-inference to Cats. This keeps the reference implementation small, but may increase ramp-up time for developers new to functional programming, and result in well-known usability problems around discoverability, naming, implicits, and type inference.&lt;/p&gt;

&lt;h1 id=&quot;12-batteries-included&quot;&gt;12. Batteries Included&lt;/h1&gt;

&lt;p&gt;In a small, cross-platform package, ZIO provides a highly-integrated toolbox for building principled asynchronous and concurrent applications.&lt;/p&gt;

&lt;p&gt;This toolbox includes the following:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;The most important concurrent data structures, including &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Ref&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Promise&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Queue&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Semaphore&lt;/code&gt;, and a small &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Stream&lt;/code&gt; for file / socket / data streaming&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.youtube.com/watch?list=PL8NC5lCgGs6MYG0hR_ZOhQLvtoyThURka&amp;amp;v=d6WWmia0BPM&quot;&gt;Software Transactional Memory&lt;/a&gt; (STM), which can be used to simply build composable, asynchronous, concurrent, and interruptible data structures&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Schedule&lt;/code&gt;, which offers composable retries and repetitions&lt;/li&gt;
  &lt;li&gt;Tiny and testable &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Clock&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Random&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Console&lt;/code&gt;, and &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;System&lt;/code&gt; services, which are used by nearly every application&lt;/li&gt;
  &lt;li&gt;Many helper methods on the effect type covering common use cases&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;As a reference implementation, Cats IO has none of these features. This decision makes Cats IO more lightweight, but at the cost of adding more third-party dependencies (where they are available), or having to write more user-land code.&lt;/p&gt;

&lt;h1 id=&quot;summary&quot;&gt;Summary&lt;/h1&gt;

&lt;p&gt;Cats Effect has done great things for the Scala ecosystem, providing a growing roster of libraries that all work together.&lt;/p&gt;

&lt;p&gt;Application developers who are using Cats Effect libraries now face the difficult decision of choosing which of the major effect types to use with Cats Effect libraries: Cats IO, Monix, or ZIO.&lt;/p&gt;

&lt;p&gt;While different people will make different choices that are uniquely suited for them, if you value some of the design decisions described in this post, then I hope you will find that together, ZIO and Cats Effect make a killer combination!&lt;/p&gt;

  &lt;p&gt;&lt;a href=&quot;https://degoes.net/articles/zio-cats-effect&quot;&gt;ZIO &amp; Cats Effect: A Match Made in Heaven&lt;/a&gt; was originally published by John A De Goes at &lt;a href=&quot;https://degoes.net&quot;&gt;John <em>A</em> <strong>De Goes</strong>&lt;/a&gt; on April 18, 2019.&lt;/p&gt;</content>
</entry>


<entry>
  <title type="html"><![CDATA[The Functional Scala Concurrency Challenge]]></title>
  <link rel="alternate" type="text/html" href="https://degoes.net/articles/zio-challenge" />
  <id>https://degoes.net/articles/zio-challenge</id>
  <published>2019-03-10T00:00:00-07:00</published>
  <updated>2019-03-10T00:00:00-07:00</updated>
  <author>
    <name>John A De Goes</name>
    <uri>https://degoes.net</uri>
    <email>john@degoes.net</email>
  </author>
  <content type="html">&lt;p&gt;Recently, while teaching my first-ever workshop for &lt;a href=&quot;https://github.com/scalaz/scalaz-zio&quot;&gt;ZIO&lt;/a&gt; with the great crew at &lt;a href=&quot;https://scalac.io&quot;&gt;Scalac&lt;/a&gt;, we had a chance to build a purely functional circuit breaker using ZIO’s &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Ref&lt;/code&gt;, which is a model of a mutable reference that can be updated atomically.&lt;/p&gt;

&lt;p&gt;A circuit breaker guards access to an external service, like a database, third-party API or microservice. Once too many requests to the service fail, the circuit breaker trips, and immediately fails all requests, until the circuit breaker has a chance to reset.&lt;/p&gt;

&lt;p&gt;Circuit breakers not only protect external services from overload (giving them a chance to recover after failure), but they help conserve local resources (such as sockets, threads, and the like) that would otherwise be wasted on a lost cost.&lt;/p&gt;

&lt;p&gt;As opposed to retry policies, which dictate how individual requests are retried, circuit breakers share global knowledge across a system, so different fibers can act more intelligently and in a coordinated fashion.&lt;/p&gt;

&lt;p&gt;Circuit breakers are often modeled as having three states: open, closed, and half-open. The circuit breaker logic (possibly aided by configuration parameters) is responsible for transitioning between the states based on inspecting the status of requests.&lt;/p&gt;

&lt;p&gt;At the ZIO workshop, exploring different possibilities for circuit breakers made me realize something: I &lt;em&gt;really&lt;/em&gt; don’t like circuit breakers. I find the arbitrary nature of the number of states and the switching conditions deeply disturbing.&lt;/p&gt;

&lt;p&gt;I think we can do better than circuit breakers, and have some fun while we’re at it! So in this post, I’m going to issue a challenge for all you fans of functional programming in Scala: build a better circuit breaker!&lt;/p&gt;

&lt;h2 id=&quot;the-challenge&quot;&gt;The Challenge&lt;/h2&gt;

&lt;p&gt;Instead of a circuit breaker, I want you to build a &lt;em&gt;tap&lt;/em&gt;, which adjusts the flow of requests continuously through the tap.&lt;/p&gt;

&lt;p&gt;The flow is adjusted based on observed failures that qualify (i.e. match some user-defined predicate).&lt;/p&gt;

&lt;p&gt;If you want to use ZIO to implement the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Tap&lt;/code&gt;, then your API should conform to the following interface:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-scala&quot; data-lang=&quot;scala&quot;&gt;&lt;span class=&quot;cm&quot;&gt;/**
 * A `Tap` adjusts the flow of tasks through 
 * an external service in response to observed
 * failures in the service, always trying to 
 * maximize flow while attempting to meet the 
 * user-defined upper bound on failures.
 */&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;trait&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Tap&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;-E1&lt;/span&gt;, &lt;span class=&quot;kt&quot;&gt;+E2&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;cm&quot;&gt;/**
   * Sends the task through the tap. The 
   * returned task may fail immediately with a
   * default error depending on the service 
   * being guarded by the tap.
   */&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;apply&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;R&lt;/span&gt;, &lt;span class=&quot;kt&quot;&gt;E&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;&amp;gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;E2&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;&amp;lt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;E1&lt;/span&gt;, &lt;span class=&quot;kt&quot;&gt;A&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;](&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;effect&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;ZIO&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;R&lt;/span&gt;, &lt;span class=&quot;kt&quot;&gt;E&lt;/span&gt;, &lt;span class=&quot;kt&quot;&gt;A&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;])&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;ZIO&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;R&lt;/span&gt;, &lt;span class=&quot;kt&quot;&gt;E&lt;/span&gt;, &lt;span class=&quot;kt&quot;&gt;A&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;object&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Tap&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;cm&quot;&gt;/**
   * Creates a tap that aims for the specified 
   * maximum error rate, using the specified 
   * function to qualify errors (unqualified 
   * errors are not treated as failures for 
   * purposes of the tap), and the specified 
   * default error used for rejecting tasks
   * submitted to the tap.
   */&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;make&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;E1&lt;/span&gt;, &lt;span class=&quot;kt&quot;&gt;E2&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;](&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;errBound&lt;/span&gt;  &lt;span class=&quot;k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Percentage&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;qualified&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;E1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Boolean&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; 
    &lt;span class=&quot;n&quot;&gt;rejected&lt;/span&gt;  &lt;span class=&quot;k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;E2&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;UIO&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;Tap&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;E1&lt;/span&gt;, &lt;span class=&quot;kt&quot;&gt;E2&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]]&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;???&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;If you want to use Cats IO or Monix to implement &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Tap&lt;/code&gt;, then your API should conform to the following interface (or its polymorphic equivalent):&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-scala&quot; data-lang=&quot;scala&quot;&gt;&lt;span class=&quot;k&quot;&gt;trait&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Tap&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;apply&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;A&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;](&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;effect&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Task&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;A&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;])&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Task&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;A&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;object&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Tap&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;make&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;errBound&lt;/span&gt;  &lt;span class=&quot;k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Percentage&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;qualified&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Throwable&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Boolean&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; 
    &lt;span class=&quot;n&quot;&gt;rejected&lt;/span&gt;  &lt;span class=&quot;k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Throwable&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Task&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;Tap&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;???&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Your implementation of &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Tap&lt;/code&gt; should satisfy the following requirement:&lt;/p&gt;

&lt;p&gt;&lt;em&gt;The tap must continuously adjust the percentage of tasks it lets through until it finds the maximum flow rate that satisfies the user-defined maximum error bound.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Thus, if you create a tap with a maximum error rate of &lt;em&gt;1%&lt;/em&gt;, and suddenly 50% of all tasks are failing, then the tap will decrease flow until the failure rate stabilizes at 1%.&lt;/p&gt;

&lt;p&gt;As the service is recovering, the failure rate will drop below 1%, which will cause the tap to increase flow and let more tasks through.&lt;/p&gt;

&lt;p&gt;Once the service has fully recovered, the failure rate will hit 0% (or within some distance of that target), at which point, the tap will let all tasks through.&lt;/p&gt;

&lt;p&gt;Your implementation must be purely functional and concurrent. Bonus points for demonstrating your knowledge of concurrency primitives, such as &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Ref&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Promise&lt;/code&gt; (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Deferred&lt;/code&gt;), and so forth.&lt;/p&gt;

&lt;h2 id=&quot;winners&quot;&gt;Winners&lt;/h2&gt;

&lt;p&gt;The main reason to work on this challenge is to explore solutions for concurrency in functional Scala. It’s a fun little project that will take you on a grand tour of modern, purely functional effect systems in Scala.&lt;/p&gt;

&lt;p&gt;That said, I want to give you a little extra motivation to work on this problem!&lt;/p&gt;

&lt;p&gt;If you post your code in a Gist so the whole world can learn from your solution, then I’ll both promote your solution, and buy you a drink next time we’re in the same city!&lt;/p&gt;

&lt;p&gt;Finally, if your solution is among the top 1-3 I receive over the next 2 weeks, I’ll connect with you on LinkedIn and write a short, honest endorsement of your skills in functional Scala.&lt;/p&gt;

&lt;p&gt;Ready? On your marks, get set, go!&lt;/p&gt;

  &lt;p&gt;&lt;a href=&quot;https://degoes.net/articles/zio-challenge&quot;&gt;The Functional Scala Concurrency Challenge&lt;/a&gt; was originally published by John A De Goes at &lt;a href=&quot;https://degoes.net&quot;&gt;John <em>A</em> <strong>De Goes</strong>&lt;/a&gt; on March 10, 2019.&lt;/p&gt;</content>
</entry>


<entry>
  <title type="html"><![CDATA[Testing Incrementally with ZIO Environment]]></title>
  <link rel="alternate" type="text/html" href="https://degoes.net/articles/testable-zio" />
  <id>https://degoes.net/articles/testable-zio</id>
  <published>2019-03-07T00:00:00-07:00</published>
  <updated>2019-03-07T00:00:00-07:00</updated>
  <author>
    <name>John A De Goes</name>
    <uri>https://degoes.net</uri>
    <email>john@degoes.net</email>
  </author>
  <content type="html">&lt;p&gt;In my &lt;a href=&quot;/articles/zio-environment&quot;&gt;last post&lt;/a&gt;, I introduced &lt;em&gt;ZIO Environment&lt;/em&gt;, which is a new feature in ZIO that bakes in a high-performance, type-safe, and fully-inferred reader effect into the ZIO data type.&lt;/p&gt;

&lt;p&gt;This capability leads to a way of describing and testing effects that I call &lt;em&gt;environmental effects&lt;/em&gt;. Unlike tagless-final, which is difficult to teach, difficult to abstract over, and does not infer, environmental effects are simple, abstract well, and infer completely.&lt;/p&gt;

&lt;p&gt;Moreover, while proponents of tagless-final argue that tagless-final &lt;em&gt;parametrically constrains&lt;/em&gt; effects, my &lt;a href=&quot;/articles/zio-environment&quot;&gt;last post&lt;/a&gt; demonstrated this is not quite correct: not only can you embed raw effects &lt;em&gt;anywhere&lt;/em&gt; in Scala, but even without leaving &lt;em&gt;Scalazzi&lt;/em&gt; (the purely functional subset of Scala), you can lift arbitrary effects into any &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Applicative&lt;/code&gt; functor.&lt;/p&gt;

&lt;p&gt;The inability of tagless-final to constrain effects is more than just theoretical:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;New Scala functional programmers use effect type classes like &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Sync&lt;/code&gt; everywhere (which are themselves lawless and serve only to embed effects), and they embed effects using lazy methods, like &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;defer&lt;/code&gt; or &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;point&lt;/code&gt;.&lt;/li&gt;
  &lt;li&gt;Even some experienced Scala functional programmers embed effects in pure methods (for example, exceptions in the functions they pass to &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;map&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;flatMap&lt;/code&gt;), and some effect types encourage this behavior.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Tagless-final can be used by a well-trained and highly-disciplined team to constrain effects, but the same can be said for many approaches, &lt;em&gt;including&lt;/em&gt; environmental effects.&lt;/p&gt;

&lt;p&gt;After professionally and pedagogically wrestling with these issues for several years now, I’ve come to the conclusion there are just two legitimately compelling reasons to use tagless-final:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Avoiding commitment to a specific effect type, which can be useful for library authors, but which is less useful for application developers (often it’s a hinderance!);&lt;/li&gt;
  &lt;li&gt;Writing testable functional code, which is fairly straightforward with tagless-final because you can just create test instances for different effect type classes.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;While testability is a compelling reason to &lt;em&gt;use&lt;/em&gt; tagless-final, it’s not necessarily a compelling reason to &lt;em&gt;choose&lt;/em&gt; tagless-final over other approaches—in particular, over environmental effects.&lt;/p&gt;

&lt;p&gt;In this post, I’m going to show you how to use environmental effects to achieve testability. I hope to demonstrate that environmental effects provide easier and more incremental testability—all without sacrificing teachability, abstraction, or type inference.&lt;/p&gt;

&lt;h2 id=&quot;a-web-app&quot;&gt;A Web App&lt;/h2&gt;

&lt;p&gt;Let’s say we are building a web application with ZIO. Suppose the application was originally written with &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Future&lt;/code&gt; or perhaps some version of &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;IO&lt;/code&gt; or &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Task&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Later, the application was ported to ZIO’s &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Task[A]&lt;/code&gt;, which is a type alias for &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ZIO[Any, Throwable, A]&lt;/code&gt;—representing an effect that requires no specific environment and that may fail with any &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Throwable&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Now let’s say one of the functions in our application, called &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;inviteFriends&lt;/code&gt;, invites the friends of a given user to the application by sending them emails:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-scala&quot; data-lang=&quot;scala&quot;&gt;&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;inviteFriends&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;userID&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;UserID&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Task&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;List&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;Send&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]]&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;=&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;user&lt;/span&gt;    &lt;span class=&quot;k&quot;&gt;&amp;lt;-&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;DB&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;py&quot;&gt;lookupUser&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;userID&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;friends&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;&amp;lt;-&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;Social&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;py&quot;&gt;getFriends&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;user&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;py&quot;&gt;facebookID&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;resp&lt;/span&gt;    &lt;span class=&quot;k&quot;&gt;&amp;lt;-&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;ZIO&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;py&quot;&gt;foreach&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;friends&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;friend&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;=&amp;gt;&lt;/span&gt;
                 &lt;span class=&quot;nv&quot;&gt;Email&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;py&quot;&gt;invite&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;user&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;friend&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;py&quot;&gt;email&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
               &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;yield&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;resp&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Portions of the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Social&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;DB&lt;/code&gt;, and &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Email&lt;/code&gt; objects are shown below:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-scala&quot; data-lang=&quot;scala&quot;&gt;&lt;span class=&quot;k&quot;&gt;object&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Social&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;...&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;getFriends&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;fid&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;FacebookID&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Task&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;List&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;FacebookProfile&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]]&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;???&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;...&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;object&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;DB&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;...&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;lookupUser&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;uid&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;UserID&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Task&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;UserProfile&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;???&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;...&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;object&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Email&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;...&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;invite&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;user&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;UserProfile&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;friend&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;FacebookProfile&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Task&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;Send&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;???&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;...&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;As currently written, our web application is not very testable. The function &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;inviteFriends&lt;/code&gt; makes direct calls to database functions, Facebook API functions, and email service functions.&lt;/p&gt;

&lt;p&gt;While we may have automated tests for our web service, because our application interacts directly with the real world, the tests are actually &lt;em&gt;system tests&lt;/em&gt;, not &lt;em&gt;unit tests&lt;/em&gt;. Such tests are very difficult to write, they run slowly, they randomly fail, and they test much more than our application logic.&lt;/p&gt;

&lt;p&gt;We do not have time to rewrite our application, and we cannot make it testable all at once. Instead, let’s try to remove dependency on the live database for the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;inviteFriends&lt;/code&gt; function.&lt;/p&gt;

&lt;p&gt;If we succeed in doing this, we will make our test code a &lt;em&gt;little better&lt;/em&gt;, and after we ship the new code, we can incrementally use the same technique to make the function &lt;em&gt;fully&lt;/em&gt; testable—fast, deterministic, and without any external dependencies.&lt;/p&gt;

&lt;h3 id=&quot;steps-toward-testability&quot;&gt;Steps Toward Testability&lt;/h3&gt;

&lt;p&gt;To incrementally refactor &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;inviteFriends&lt;/code&gt; to be more testable, we’re going to perform the following series of refactorings:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Introduce a type alias.&lt;/li&gt;
  &lt;li&gt;Introduce a module for the database.&lt;/li&gt;
  &lt;li&gt;Implement a production database module.&lt;/li&gt;
  &lt;li&gt;Integrate the production module.&lt;/li&gt;
  &lt;li&gt;Implement a test database module.&lt;/li&gt;
  &lt;li&gt;Test the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;inviteFriends&lt;/code&gt; function.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Each of these steps will be covered in the sections that follow.&lt;/p&gt;

&lt;h3 id=&quot;introduce-a-type-alias&quot;&gt;Introduce A Type Alias&lt;/h3&gt;

&lt;p&gt;To simplify the process of refactoring our application, we’re going to first introduce a simple type alias that we can use in the definition of &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;inviteFriends&lt;/code&gt; and the functions that call it:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-scala&quot; data-lang=&quot;scala&quot;&gt;&lt;span class=&quot;k&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Webapp&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;A&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Task&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;A&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Now we will mechanically update the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;lookupUser&lt;/code&gt; function and any functions that call it to use the type alias:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-scala&quot; data-lang=&quot;scala&quot;&gt;&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;inviteFriends&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;userID&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;UserID&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Webapp&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;List&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;Send&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]]&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;=&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;user&lt;/span&gt;    &lt;span class=&quot;k&quot;&gt;&amp;lt;-&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;DB&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;py&quot;&gt;lookupUser&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;userID&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;friends&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;&amp;lt;-&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;Social&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;py&quot;&gt;getFriends&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;user&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;py&quot;&gt;facebookID&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;resp&lt;/span&gt;    &lt;span class=&quot;k&quot;&gt;&amp;lt;-&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;ZIO&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;py&quot;&gt;foreach&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;friends&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;friend&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;=&amp;gt;&lt;/span&gt;
                 &lt;span class=&quot;nv&quot;&gt;Email&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;py&quot;&gt;invite&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;user&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;friend&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;py&quot;&gt;email&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
               &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;yield&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;resp&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;As an alternative to this technique, we could simply delete the return types entirely. However, it’s a good practice to place return types on top-level function signatures, so developers without IDEs can easily determine the return type of functions.&lt;/p&gt;

&lt;p&gt;After this step, we are ready to introduce a service for the database.&lt;/p&gt;

&lt;h3 id=&quot;introduce-a-database-module&quot;&gt;Introduce a Database Module&lt;/h3&gt;

&lt;p&gt;The database module will provide access to a database service.&lt;/p&gt;

&lt;p&gt;As discussed in my post on &lt;a href=&quot;/articles/zio-environment&quot;&gt;ZIO Environment&lt;/a&gt;, the database module is an ordinary interface with a single field, which contains the database service.&lt;/p&gt;

&lt;p&gt;We can define both the module and the service very simply:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-scala&quot; data-lang=&quot;scala&quot;&gt;&lt;span class=&quot;c1&quot;&gt;// The database module
&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;trait&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Database&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;database&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Database.Service&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;object&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Database&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;c1&quot;&gt;// The database service
&lt;/span&gt;  &lt;span class=&quot;k&quot;&gt;trait&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Service&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;lookupUser&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;uid&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;UserID&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Task&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;UserProfile&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Notice how we have decided to place just one method inside the database service: the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;lookupUser&lt;/code&gt; method. Although there may be many database methods, we don’t have time to make all of them testable, so we will focus on the one required by the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;inviteFriends&lt;/code&gt; method.&lt;/p&gt;

&lt;p&gt;We are now ready to implement a production version of the service.&lt;/p&gt;

&lt;h3 id=&quot;implement-production-module&quot;&gt;Implement Production Module&lt;/h3&gt;

&lt;p&gt;We will call the production database module &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;DatabaseLive&lt;/code&gt;. To implement the module, we need only copy and paste the implementation of &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Database.lookupUser&lt;/code&gt; into our implementation of the service interface:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-scala&quot; data-lang=&quot;scala&quot;&gt;&lt;span class=&quot;k&quot;&gt;trait&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;DatabaseLive&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;extends&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Database&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;database&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;=&lt;/span&gt; 
    &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;Database&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;py&quot;&gt;Service&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;c1&quot;&gt;// Implementation copy/pasted from
&lt;/span&gt;      &lt;span class=&quot;c1&quot;&gt;// DB.lookupUser:
&lt;/span&gt;      &lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;lookupUser&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;userID&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;UserID&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;=&lt;/span&gt; 
        &lt;span class=&quot;o&quot;&gt;...&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;object&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;DatabaseLive&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;extends&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;DatabaseLive&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;For maximum flexibility and convenience, we have defined both a &lt;em&gt;trait&lt;/em&gt; that implements the database module, which can be mixed into other traits, and an &lt;em&gt;object&lt;/em&gt; that extends the trait, which can be used standalone.&lt;/p&gt;

&lt;h3 id=&quot;integrate-production-module&quot;&gt;Integrate Production Module&lt;/h3&gt;

&lt;p&gt;We now have all the pieces we need to replace the original &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;DB.lookupUser&lt;/code&gt; method, whose actual implementation now resides inside our &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;DatabaseLive&lt;/code&gt; module:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-scala&quot; data-lang=&quot;scala&quot;&gt;&lt;span class=&quot;k&quot;&gt;object&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;DB&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;...&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;lookupUser&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;uid&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;UserID&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;ZIO&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;Database&lt;/span&gt;, &lt;span class=&quot;kt&quot;&gt;Throwable&lt;/span&gt;, &lt;span class=&quot;kt&quot;&gt;UserProfile&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;=&lt;/span&gt; 
    &lt;span class=&quot;nv&quot;&gt;ZIO&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;py&quot;&gt;accessM&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;_&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;py&quot;&gt;database&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;lookupUser&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;uid&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;...&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;The &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;lookupUser&lt;/code&gt; method merely delegates to the database module, by accessing the model through ZIO Environment (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ZIO.accessM&lt;/code&gt;).&lt;/p&gt;

&lt;p&gt;Here we don’t use the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Webapp&lt;/code&gt; type alias, because the functions in &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;DB&lt;/code&gt; will not necessarily have the same dependencies as our web application.&lt;/p&gt;

&lt;p&gt;However, after enough refactoring, we might introduce a new type alias in the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;DB&lt;/code&gt; object: &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;type DB[A] = ZIO[Database, Throwable, A]&lt;/code&gt;. Eventually, all methods in &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;DB&lt;/code&gt; might return effects of this type.&lt;/p&gt;

&lt;p&gt;At this point, our refactoring is nearly complete. But we have to take care of one last detail: we have to provide our database module to the production application.&lt;/p&gt;

&lt;p&gt;There are two main ways to provide the database module to our application. If it is inconvenient to propagate the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Webapp&lt;/code&gt; type signature to the top of our application, we can always supply the production module somewhere inside our application.&lt;/p&gt;

&lt;p&gt;In the worst case, if we are pressed for time and need to ship code today, maybe we choose to provide the production database wherever we call &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;inviteFriends&lt;/code&gt;.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-scala&quot; data-lang=&quot;scala&quot;&gt;&lt;span class=&quot;nf&quot;&gt;inviteFriends&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;userId&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;).&lt;/span&gt;&lt;span class=&quot;py&quot;&gt;provide&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;DatabaseLive&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;If we have a bit more time, we can push the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Webapp&lt;/code&gt; type synonym to the entry point of our purely functional application, which might be the main function, or it might be where our web framework calls into our code.&lt;/p&gt;

&lt;p&gt;In this case, instead of using the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;DefaultRuntime&lt;/code&gt; that ships with ZIO, we can define our own &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Runtime&lt;/code&gt;, which provides the production database module):&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-scala&quot; data-lang=&quot;scala&quot;&gt;&lt;span class=&quot;k&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;myRuntime&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;=&lt;/span&gt; 
  &lt;span class=&quot;nc&quot;&gt;Runtime&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;DatabaseLive&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;PlatformLive&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;The custom runtime can be used to run many different effects that all require the same environment, so we don’t have to call &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;provide&lt;/code&gt; on all of them before we run them.&lt;/p&gt;

&lt;p&gt;Once we have this custom runtime, we can run our top-level effect, which will supply its required environment:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-scala&quot; data-lang=&quot;scala&quot;&gt;&lt;span class=&quot;nv&quot;&gt;myRuntime&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;py&quot;&gt;unsafeRun&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;effect&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;At this point, we have not changed the behavior of our application at all—it will work exactly as it did before. We’ve just moved the code around a bit, so we can access a tiny effect through ZIO environment.&lt;/p&gt;

&lt;p&gt;Now it’s time to build a database module specifically for testing.&lt;/p&gt;

&lt;h3 id=&quot;implement-test-module&quot;&gt;Implement Test Module&lt;/h3&gt;

&lt;p&gt;We could implement the test database module using a mocking framework. However, to avoid all magic and use of reflection, in this post, we will build one from scratch.&lt;/p&gt;

&lt;p&gt;For maximum flexibility, our test database module will track all calls to &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;lookupUser&lt;/code&gt;, and supply responses using a &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Map&lt;/code&gt;, which can be dynamically changed by the test suite.&lt;/p&gt;

&lt;p&gt;To support this stateful behavior, we will need a &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Ref&lt;/code&gt;, which is a concurrent-safe ZIO data structure that models mutable references. We will also need a simple (immutable) data structure to hold the state of the test database module.&lt;/p&gt;

&lt;p&gt;We define the following test data structure, which is capable of tracking a list of &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;UserID&lt;/code&gt; values, and holding data that maps from &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;UserID&lt;/code&gt; to &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;UserProfile&lt;/code&gt;.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-scala&quot; data-lang=&quot;scala&quot;&gt;&lt;span class=&quot;k&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;case&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;TestDatabaseState&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;lookups&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;List&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;UserID&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;],&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;    &lt;span class=&quot;k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Map&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;UserID&lt;/span&gt;, &lt;span class=&quot;kt&quot;&gt;UserProfile&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;addLookup&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;uid&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;UserID&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;TestDatabaseState&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;copy&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;lookups&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;uid&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;::&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;lookups&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Now we can define the service of our test database module. The service will require a &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Ref[TestDatabaseState]&lt;/code&gt;, so it can not only use test data, but update the test state:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-scala&quot; data-lang=&quot;scala&quot;&gt;&lt;span class=&quot;k&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;case&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;TestDatabaseService&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ref&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Ref&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;TestDatabaseState&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;])&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;extends&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;Database&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;py&quot;&gt;Service&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;lookupUser&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;uid&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;UserID&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Task&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;UserProfile&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;=&lt;/span&gt; 
    &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;k&quot;&gt;_&lt;/span&gt;       &lt;span class=&quot;k&quot;&gt;&amp;lt;-&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;ref&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;py&quot;&gt;update&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;_&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;py&quot;&gt;addLookup&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;uid&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;    &lt;span class=&quot;k&quot;&gt;&amp;lt;-&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;ref&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;py&quot;&gt;get&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;py&quot;&gt;map&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;_&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;py&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;profile&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;&amp;lt;-&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;Task&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;py&quot;&gt;fromEither&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;py&quot;&gt;get&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;uid&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
                   &lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;py&quot;&gt;fold&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Left&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;DBErr&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;))(&lt;/span&gt;
                     &lt;span class=&quot;nc&quot;&gt;Right&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;_&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)))&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;yield&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;profile&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Notice how the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;lookupUser&lt;/code&gt; function stores the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;UserID&lt;/code&gt; of every call in the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;lookups&lt;/code&gt; field of the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;TestDatabaseState&lt;/code&gt;. In addition, the function retrieves test responses from the map. If there is no response in the map, the function fails, presumably in the same way the production database would fail.&lt;/p&gt;

&lt;p&gt;The test service must be placed in a module. In general, we should wait to create the module until the test suite, because then we will know the full set of dependencies for each test.&lt;/p&gt;

&lt;p&gt;However, at this stage, the database service is the only dependency in our application, so we can make a helper function to create the test database module:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-scala&quot; data-lang=&quot;scala&quot;&gt;&lt;span class=&quot;k&quot;&gt;object&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;TestDatabase&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;apply&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ref&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Ref&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;TestDatabaseState&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;])&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Database&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; 
    &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Database&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;k&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;database&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Database.Service&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; 
        &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;TestDatabaseService&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ref&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;We now have all the pieces necessary to write a test of the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;inviteFriends&lt;/code&gt; function, which will use our test database module.&lt;/p&gt;

&lt;h3 id=&quot;write-the-test&quot;&gt;Write the Test&lt;/h3&gt;

&lt;p&gt;To more easily test the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;lookupFriends&lt;/code&gt; function, we will define a helper function. Given test data and input to the function, the helper will return the final test state and the output of the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;lookupFriends&lt;/code&gt; function:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-scala&quot; data-lang=&quot;scala&quot;&gt;&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;runLookupFriends&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Map&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;UserID&lt;/span&gt;, &lt;span class=&quot;kt&quot;&gt;UserProfile&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;],&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;uid&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;UserID&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Task&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;TestDatabaseState&lt;/span&gt;, &lt;span class=&quot;kt&quot;&gt;List&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;Send&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;])]&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;=&lt;/span&gt; 
  &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;ref&lt;/span&gt;   &lt;span class=&quot;k&quot;&gt;&amp;lt;-&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;Ref&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;py&quot;&gt;make&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;TestDatabaseState&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Nil&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;))&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;resp&lt;/span&gt;  &lt;span class=&quot;k&quot;&gt;&amp;lt;-&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;lookupFriends&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;uid&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
               &lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;py&quot;&gt;provide&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;TestDatabase&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ref&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;))&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;state&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;&amp;lt;-&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;ref&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;py&quot;&gt;get&lt;/span&gt; 
  &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;yield&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;state&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;resp&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;The helper function creates a &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Ref&lt;/code&gt; with the initial test data, uses the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Ref&lt;/code&gt; to create the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;TestDatabase&lt;/code&gt; module, and then supplies the database module to the effect returned by &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;lookupFriends&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;With this helper function, writing a test becomes quite simple:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-scala&quot; data-lang=&quot;scala&quot;&gt;&lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;TestSuite&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;extends&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;DefaultRuntime&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;testLookupFriends&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;nf&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;state&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;resp&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;=&lt;/span&gt; 
      &lt;span class=&quot;n&quot;&gt;unsafeRun&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;nf&quot;&gt;runLookupFriends&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;
          &lt;span class=&quot;nc&quot;&gt;Map&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;TestUserID&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;TestUserProfile&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;),&lt;/span&gt;
          &lt;span class=&quot;nc&quot;&gt;TestUserID&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
      &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
    
    &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;state&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;py&quot;&gt;lookups&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;must_===&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;List&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;TestUserID&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;))&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;and&lt;/span&gt;
      &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;resp&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;must_===&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;TestResponse&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;This test for &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;inviteFriends&lt;/code&gt; is not perfect. It still interacts with a real Facebook API and a real email service. But compared to whatever tests already exist, at least this test does not interact with a real database.&lt;/p&gt;

&lt;p&gt;Moreover, we were able to make this change in a &lt;em&gt;minimally disruptive&lt;/em&gt; manner.&lt;/p&gt;

&lt;h3 id=&quot;a-glimpse-beyond&quot;&gt;A Glimpse Beyond&lt;/h3&gt;

&lt;p&gt;After a little more refactoring, of course, we would succeed in making &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;inviteFriends&lt;/code&gt; fully testable. Even after the full refactoring, the code for &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;lookupFriends&lt;/code&gt; would not change.&lt;/p&gt;

&lt;p&gt;Instead, our type alias for &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Webapp&lt;/code&gt; would expand to include new environmental effects:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-scala&quot; data-lang=&quot;scala&quot;&gt;&lt;span class=&quot;k&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;WebappFX&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; 
  &lt;span class=&quot;nc&quot;&gt;Database&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;with&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Social&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;with&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Email&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Webapp&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;A&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;ZIO&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;WebappFX&lt;/span&gt;, &lt;span class=&quot;kt&quot;&gt;Throwable&lt;/span&gt;, &lt;span class=&quot;kt&quot;&gt;A&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Now all the methods in the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;DB&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Social&lt;/code&gt;, and &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Email&lt;/code&gt; objects would simply delegate to their respective modules using &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ZIO.accessM&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Running our application would now look a little different:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-scala&quot; data-lang=&quot;scala&quot;&gt;&lt;span class=&quot;k&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;myRuntime&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;=&lt;/span&gt; 
  &lt;span class=&quot;nc&quot;&gt;Runtime&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt;  &lt;span class=&quot;nc&quot;&gt;DatabaseLive&lt;/span&gt; 
    &lt;span class=&quot;k&quot;&gt;with&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;SocialLive&lt;/span&gt; 
    &lt;span class=&quot;k&quot;&gt;with&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;EmailLive&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;PlatformLive&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;...&lt;/span&gt;
&lt;span class=&quot;nv&quot;&gt;myRuntime&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;py&quot;&gt;unsafeRun&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;effect&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Finally, testing &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;lookupFriends&lt;/code&gt; would be entirely fast, deterministic, and type-safe, without any dependencies on external systems, or use of any reflection.&lt;/p&gt;

&lt;h2 id=&quot;summary&quot;&gt;Summary&lt;/h2&gt;

&lt;p&gt;Environmental effects make it easy to test purely functional applications—significantly easier and with less ceremony than tagless-final, with full type inference, and without false promises.&lt;/p&gt;

&lt;p&gt;Morever, with environmental effects, we can make even just a &lt;em&gt;single function&lt;/em&gt; testable, by pushing that function into an environmental effect. This requires just a few small changes that can be done incrementally without major disruption to the application.&lt;/p&gt;

&lt;p&gt;This ability lets us make incremental progress towards better application architecture. We don’t have to solve all the problems in our code base at once. We can focus on making our application a little better each day.&lt;/p&gt;

&lt;p&gt;While this post focused on ZIO Environment, if you’re using &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Future&lt;/code&gt;, Monix, or Cats IO, you can still use this approach with a &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ReaderT&lt;/code&gt; monad transformer. With a monad transformer, you will lose type inference and some performance, but you will gain the other benefits in a more familiar package.&lt;/p&gt;

&lt;p&gt;If you’d like to give ZIO Environment a try, hop over to the &lt;a href=&quot;https://github.com/scalaz/scalaz-zio&quot;&gt;Github project page&lt;/a&gt;, and be sure to stop by the &lt;a href=&quot;https://gitter.im/scalaz/scalaz-zio&quot;&gt;Gitter channel&lt;/a&gt; and say hello.&lt;/p&gt;

&lt;p&gt;In future posts, I will cover how to provide partial dependencies, how to model services that require other services (the &lt;em&gt;graph problem&lt;/em&gt;), how to hide implementation details, and how this approach differs from the classic cake pattern. Stay tuned for more!&lt;/p&gt;

  &lt;p&gt;&lt;a href=&quot;https://degoes.net/articles/testable-zio&quot;&gt;Testing Incrementally with ZIO Environment&lt;/a&gt; was originally published by John A De Goes at &lt;a href=&quot;https://degoes.net&quot;&gt;John <em>A</em> <strong>De Goes</strong>&lt;/a&gt; on March 07, 2019.&lt;/p&gt;</content>
</entry>


<entry>
  <title type="html"><![CDATA[Beautiful, Simple, Testable Functional Effects for Scala]]></title>
  <link rel="alternate" type="text/html" href="https://degoes.net/articles/zio-environment" />
  <id>https://degoes.net/articles/zio-environment</id>
  <published>2019-02-26T00:00:00-07:00</published>
  <updated>2019-02-26T00:00:00-07:00</updated>
  <author>
    <name>John A De Goes</name>
    <uri>https://degoes.net</uri>
    <email>john@degoes.net</email>
  </author>
  <content type="html">&lt;p&gt;&lt;strong&gt;See my accompanying talk, &lt;a href=&quot;https://skillsmatter.com/skillscasts/13247-scala-matters&quot;&gt;The Death of Finally Tagless&lt;/a&gt;, which was released today and covers ZIO Environment.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Today’s functional effect systems for Scala, such as the &lt;a href=&quot;https://github.com/scalaz/scalaz-zio&quot;&gt;ZIO library&lt;/a&gt; that I work on, are &lt;em&gt;incredibly&lt;/em&gt; powerful.&lt;/p&gt;

&lt;p&gt;They provide an effect data type that unifies synchronous, asynchronous, concurrent, and resource effects, and support automatic error propagation across these boundaries.&lt;/p&gt;

&lt;p&gt;They’re way faster and more powerful than Scala’s &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Future&lt;/code&gt;, well-documented, reasonably easy to use, and sometimes come equipped with concurrent data structures, a fiber-based concurrency model, and compositional interruption and timeouts for efficient global computation.&lt;/p&gt;

&lt;p&gt;They’re also purely functional, and showcase the power of pure functional programming to solve modern business problems.&lt;/p&gt;

&lt;p&gt;Unfortunately, there’s a dark secret to these functional effect systems: out of the box, they don’t live up to the full promise of functional programming. Despite being referentially transparent, they’re not really testable.&lt;/p&gt;

&lt;h2 id=&quot;untestable-effects&quot;&gt;Untestable Effects&lt;/h2&gt;

&lt;p&gt;Functional programming ordinarily gives us the incredible ability to easily test our software.&lt;/p&gt;

&lt;p&gt;The reason for this is quite simple: in functional programming, all a function does is map its input to some output. Functions are total (they return an output for every input), deterministic (they return the same output for the same input), and free of side effects (they only compute the return value, and don’t interact with the outside world).&lt;/p&gt;

&lt;p&gt;Surprisingly to many, these properties also hold for functions that returns functional &lt;em&gt;effects&lt;/em&gt;. A functional effect, it turns out, is just an immutable data structure that &lt;em&gt;describes&lt;/em&gt; an effect, without actually executing it.&lt;/p&gt;

&lt;p&gt;Functional programs construct and compose these data structures together using operations like &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;map&lt;/code&gt; and &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;flatMap&lt;/code&gt;, resulting in a data structure that &lt;em&gt;models&lt;/em&gt; the entire effectful application. Then in the application’s main function, the data structure is translated, step-by-step, into the effectful operations that it describes.&lt;/p&gt;

&lt;p&gt;The simplest way to build a functional effect is to &lt;em&gt;describe&lt;/em&gt; an effect by using a data structure to store a &lt;em&gt;thunk&lt;/em&gt; (a &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Function0&lt;/code&gt; in Scala’s terminology) that holds an arbitrary hunk of effectful Scala code.&lt;/p&gt;

&lt;p&gt;Here’s a data type called &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;IO&lt;/code&gt; which does exactly this:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-scala&quot; data-lang=&quot;scala&quot;&gt;&lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;IO&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;+A&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;](&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;unsafeInterpret&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;A&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;s&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;=&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;map&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;B&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;](&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;A&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;B&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;flatMap&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;py&quot;&gt;andThen&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;IO&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;py&quot;&gt;effect&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;_&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)))&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;flatMap&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;B&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;](&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;A&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;IO&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;B&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;])&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;IO&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;B&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;=&lt;/span&gt;
    &lt;span class=&quot;nv&quot;&gt;IO&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;py&quot;&gt;effect&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;py&quot;&gt;unsafeInterpret&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()).&lt;/span&gt;&lt;span class=&quot;py&quot;&gt;unsafeInterpret&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;())&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;object&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;IO&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;effect&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;A&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;](&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;eff&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;A&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;IO&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(()&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;eff&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Now we can construct pure functions that return functional effects (&lt;em&gt;models&lt;/em&gt; of effects) quite simply:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-scala&quot; data-lang=&quot;scala&quot;&gt;&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;putStrLn&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;line&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;IO&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;Unit&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;=&lt;/span&gt; 
  &lt;span class=&quot;nv&quot;&gt;IO&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;py&quot;&gt;effect&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;line&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;))&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;getStrLn&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;IO&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;=&lt;/span&gt; 
  &lt;span class=&quot;nv&quot;&gt;IO&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;py&quot;&gt;effect&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;scala&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;py&quot;&gt;io&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;py&quot;&gt;StdIn&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;py&quot;&gt;readLine&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;())&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;These functions are total, deterministic, and free of side effects, because they don’t &lt;em&gt;do&lt;/em&gt; anything effectful, they merely build a data structure that &lt;em&gt;describes&lt;/em&gt; effectful operations.&lt;/p&gt;

&lt;p&gt;Using &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;map&lt;/code&gt; and &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;flatMap&lt;/code&gt;, we can build describes of whole effectful programs. For example, the following &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;IO&lt;/code&gt; program asks the user for some input and prints it back out to them:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-scala&quot; data-lang=&quot;scala&quot;&gt;&lt;span class=&quot;k&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;program&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;IO&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;=&lt;/span&gt; 
  &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;_&lt;/span&gt;    &lt;span class=&quot;k&quot;&gt;&amp;lt;-&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;putStrLn&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Good morning, what's your name?&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;name&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;&amp;lt;-&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;getStrLn&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;_&lt;/span&gt;    &lt;span class=&quot;k&quot;&gt;&amp;lt;-&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;putStrLn&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Great to meet you, $name&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;yield&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;name&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Now if you evaluate &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;program&lt;/code&gt; in the Scala REPL, you’ll find that it doesn’t actually &lt;em&gt;do&lt;/em&gt; anything except construct an &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;IO&lt;/code&gt; value, which is itself an immutable data structure.&lt;/p&gt;

&lt;p&gt;However, you can (non-functionally) interpret this program to the effects that it describes by calling the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;unsafeInterpret()&lt;/code&gt; function:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-scala&quot; data-lang=&quot;scala&quot;&gt;&lt;span class=&quot;nv&quot;&gt;program&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;py&quot;&gt;unsafeInterpret&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;In this way, while we can’t avoid doing something “non-functional” forever, we can at least make the vast majority of our code purely functional, and benefit from increased power of abstraction, refactoring, and testability.&lt;/p&gt;

&lt;p&gt;Well, &lt;em&gt;in theory&lt;/em&gt;. There’s a big problem with &lt;em&gt;testability&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;In our tests, we need to call functions and verify their outputs match our expectations. Unfortunately, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;IO&lt;/code&gt; values, like the above &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;program&lt;/code&gt; value, cannot be compared to other &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;IO&lt;/code&gt; values. The reason is that they embed arbitrary hunks of Scala code inside them (functions), and Scala functions cannot be compared for equality.&lt;/p&gt;

&lt;p&gt;Although Scala functions do have &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;equals&lt;/code&gt; and &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;hashCode&lt;/code&gt;, like all ojbects, these do not have meaningful implementations; they are not based on what the function does, but rather, based on the &lt;em&gt;reference&lt;/em&gt; of the constructed object.&lt;/p&gt;

&lt;p&gt;An easy way to see this is comparing the values of two &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;putStrLn&lt;/code&gt; values constructed with the same text output:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-scala&quot; data-lang=&quot;scala&quot;&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;putStrLn&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Hello&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;putStrLn&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Hello&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;false&lt;/span&gt; &lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Even though both of these &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;IO&lt;/code&gt; values represent the &lt;em&gt;same&lt;/em&gt; program, Scala cannot know that, because functions cannot be sensibly compared for equality. This is not just a limitation of Scala, but rather a fundamental limitation of computation: in Turing complete languages, we cannot know for sure if two functions are equal, even if we look at their implementations.&lt;/p&gt;

&lt;p&gt;This means that while functional effect systems &lt;em&gt;do&lt;/em&gt; provide us lots of concrete, tangible benefits (asynchronicity, concurrency, resource-safety, etc.), and while they &lt;em&gt;do&lt;/em&gt; give us increased powers of abstraction and refactoring, they don’t make it any easier to test effectful code.&lt;/p&gt;

&lt;p&gt;In part to solve this problem (and in part to gain a benefit called &lt;em&gt;parametric reasoning&lt;/em&gt;), some Scala functional programmers have used &lt;em&gt;tagless-final&lt;/em&gt;, a technique popularized in Haskell.&lt;/p&gt;

&lt;h2 id=&quot;tagless-final-101&quot;&gt;Tagless-Final 101&lt;/h2&gt;

&lt;p&gt;In tagless-final, we often use &lt;em&gt;type classes&lt;/em&gt; to model effects (although it’s &lt;em&gt;possible&lt;/em&gt; to use records, this approach seems not very popular in Scala).&lt;/p&gt;

&lt;p&gt;So instead of interacting with &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;putStrLn&lt;/code&gt; and &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;getStrLn&lt;/code&gt; directly, we define a type class to describe console capabilities. The type class is &lt;em&gt;parameterized&lt;/em&gt; over the effect type:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-scala&quot; data-lang=&quot;scala&quot;&gt;&lt;span class=&quot;k&quot;&gt;trait&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Console&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;F&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;_&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;putStrLn&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;line&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;F&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;Unit&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt;

  &lt;span class=&quot;k&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;getStrLn&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;F&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;object&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Console&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;apply&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;F&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;_&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]](&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;implicit&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;F&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Console&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;F&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;])&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Console&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;F&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;F&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Then we can define instances of this type class for &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;IO&lt;/code&gt;:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-scala&quot; data-lang=&quot;scala&quot;&gt;&lt;span class=&quot;k&quot;&gt;implicit&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;ConsoleIO&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Console&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;IO&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Console&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;IO&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;putStrLn&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;line&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;IO&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;Unit&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;=&lt;/span&gt; 
    &lt;span class=&quot;nv&quot;&gt;IO&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;py&quot;&gt;effect&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;line&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;))&lt;/span&gt;

  &lt;span class=&quot;k&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;getStrLn&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;IO&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;=&lt;/span&gt; 
    &lt;span class=&quot;nv&quot;&gt;IO&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;py&quot;&gt;effect&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;scala&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;py&quot;&gt;io&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;py&quot;&gt;StdIn&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;py&quot;&gt;readLine&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;())&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Now we write programs that are &lt;em&gt;polymorphic&lt;/em&gt; in the effect type, which express which capabilities they require from the effect by using type class constraints (commonly modeled using context bounds, which desugar to implicit parameter lists):&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-scala&quot; data-lang=&quot;scala&quot;&gt;&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;program&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;F&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;_&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Console:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Monad&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;F&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;=&lt;/span&gt; 
  &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;_&lt;/span&gt;    &lt;span class=&quot;k&quot;&gt;&amp;lt;-&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Console&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;F&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;].&lt;/span&gt;&lt;span class=&quot;py&quot;&gt;putStrLn&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Good morning, what's your name?&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;name&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;&amp;lt;-&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Console&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;F&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;].&lt;/span&gt;&lt;span class=&quot;py&quot;&gt;getStrLn&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;_&lt;/span&gt;    &lt;span class=&quot;k&quot;&gt;&amp;lt;-&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Console&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;F&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;].&lt;/span&gt;&lt;span class=&quot;py&quot;&gt;putStrLn&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Great to meet you, $name&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;yield&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;name&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Since this program is &lt;em&gt;polymorphic&lt;/em&gt; in the effect type, you can &lt;em&gt;instantiate&lt;/em&gt; it to any concrete data type (such as &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;IO&lt;/code&gt;) that supports its required capabilities. For example:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-scala&quot; data-lang=&quot;scala&quot;&gt;&lt;span class=&quot;k&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;programIO&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;IO&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;program&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;IO&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;(This assumes a suitable instance of some &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Monad&lt;/code&gt; type class has been defined for &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;IO&lt;/code&gt;, which is required because Scala’s &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;for&lt;/code&gt; comprehension desugars to &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;map&lt;/code&gt; and &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;flatMap&lt;/code&gt;.)&lt;/p&gt;

&lt;p&gt;Once all this machinery is in place, it becomes fairly straightforward to define a data type just for testing:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-scala&quot; data-lang=&quot;scala&quot;&gt;&lt;span class=&quot;k&quot;&gt;case&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;TestData&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;input&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;List&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;],&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;output&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;List&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;])&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;case&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;TestIO&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;A&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;](&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;run&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;TestData&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;TestData&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;A&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;))&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;s&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;=&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;map&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;B&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;](&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;A&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;B&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;TestIO&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;B&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;flatMap&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;TestIO&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;py&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)))&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;flatMap&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;B&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;](&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;A&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;TestIO&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;B&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;])&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;TestIO&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;B&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;=&lt;/span&gt; 
    &lt;span class=&quot;nc&quot;&gt;TestIO&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;d&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;=&amp;gt;&lt;/span&gt; 
      &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;s&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;run&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;d&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;match&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;case&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;d&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;run&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;d&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;})&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;object&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;TestIO&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;A&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;](&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;A&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;TestIO&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;A&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;TestIO&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;d&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;d&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;))&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;With this test data type, you can define an instance of the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Console&lt;/code&gt; type class that simply pulls lines of input from the test data, and writes lines of output to the test data (left as an exercise for the reader!).&lt;/p&gt;

&lt;p&gt;Once you define this and the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Monad&lt;/code&gt; instance, you can instantiate the polymorphic program to the test effect:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-scala&quot; data-lang=&quot;scala&quot;&gt;&lt;span class=&quot;k&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;programTest&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;TestIO&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;program&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;TestIO&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Finally, at long last testability has been regained: you can write fast, deterministic unit tests that thoroughly test your application logic. Your CI builds will complete quickly and you can refactor with confidence.&lt;/p&gt;

&lt;p&gt;Unfortunately, this benefit comes at considerable cost.&lt;/p&gt;

&lt;h2 id=&quot;the-dark-side-of-tagless-final&quot;&gt;The Dark Side of Tagless-Final&lt;/h2&gt;

&lt;p&gt;The tagless-final approach is robust, and many people are quite happy using the technique to build production business applications. However, the technique suffers from a number of drawbacks, each explored in the sections that follow.&lt;/p&gt;

&lt;h3 id=&quot;massive-ramp-up&quot;&gt;Massive Ramp-Up&lt;/h3&gt;

&lt;p&gt;As demonstrated in this article, the tagless-final technique is not for the faint of heart. It requires advanced knowledge of the Scala programming language, functional programming, and how we model some functional constructs in Scala.&lt;/p&gt;

&lt;p&gt;In particular, to competently use tagless-final in all common scenarios, you will have to understand:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Functional Effects.&lt;/li&gt;
  &lt;li&gt;Parametric Polymorphism.&lt;/li&gt;
  &lt;li&gt;Higher-kinded Types.&lt;/li&gt;
  &lt;li&gt;Type Classes &amp;amp; their Scala encoding.&lt;/li&gt;
  &lt;li&gt;Type Class Instances &amp;amp; their Scala encoding.&lt;/li&gt;
  &lt;li&gt;Partial Type Application (AKA &lt;em&gt;Type Lambdas&lt;/em&gt;).&lt;/li&gt;
  &lt;li&gt;The Monad Hierarchy.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;These are not topics that one co-worker can casually introduce to another co-worker over a lunch break. It’s not possible to sneak tagless-final into a code base. Some combination of training and / or mentorship are required.&lt;/p&gt;

&lt;h3 id=&quot;type-class-abuse&quot;&gt;Type Class Abuse&lt;/h3&gt;

&lt;p&gt;Although you don’t have to use type classes for tagless-final (indeed, the earliest encoding used ML, but type classes were used in the seminal &lt;em&gt;Finally Tagless&lt;/em&gt; paper), it’s overwhelmingly common to do so in the Scala community.&lt;/p&gt;

&lt;p&gt;The reason is that type classes give you nicer syntax and help you thread the (many) constraints throughout your application.&lt;/p&gt;

&lt;p&gt;Unfortunately, this is an abuse of the concept of a type class. A type class, fundamentally, is an &lt;em&gt;abstraction&lt;/em&gt;. It lets us talk about the ways in which data types are similar, by describing those similarities with &lt;em&gt;algebraic laws&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;These algebraic laws let us write generic code across many different data types that share a mathematically-precise definition of &lt;em&gt;similar structure&lt;/em&gt;, making our functional code principled in a way that ad hoc polymorphism is not.&lt;/p&gt;

&lt;p&gt;Tagless-final type classes do not, in general, have algebraic laws. Most have no laws at all. This represents a serious abuse of the construct of a type class and an impediment for teaching type classes to Scala developers.&lt;/p&gt;

&lt;h3 id=&quot;big-bang&quot;&gt;Big Bang&lt;/h3&gt;

&lt;p&gt;If we wish to use tagless-final to test a method deep inside our code base, a method which uses &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Future&lt;/code&gt; or maybe &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;IO&lt;/code&gt;, then we cannot make a small series of rote changes.&lt;/p&gt;

&lt;p&gt;Instead, we have to perform a “big bang” style refactoring, which involves a commitment to tagless-final and a lot of work to obtain testability for a single method.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Big bang&lt;/em&gt; refactoring can improve a code base, but it is often at odds with the needs of shipping software. It’s friendlier to the business if we can make changes incrementally and pay only for what we need today.&lt;/p&gt;

&lt;h3 id=&quot;tedious-repetition&quot;&gt;Tedious Repetition&lt;/h3&gt;

&lt;p&gt;Constraints on type classes are propagated with implicit parameter lists. Context bounds provide a more compact syntax for implicit parameter lists, but when a method that’s polymorphic in an effect requires a lot of different type classes, it can still be unwieldly:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-scala&quot; data-lang=&quot;scala&quot;&gt;&lt;span class=&quot;n&quot;&gt;ef&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;genFeed&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;F&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;_&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Monad:&lt;/span&gt; 
  &lt;span class=&quot;kt&quot;&gt;Logging:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;UserDatabase:&lt;/span&gt;         
  &lt;span class=&quot;kt&quot;&gt;ProfileDatabase:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;RedisCache:&lt;/span&gt; 
  &lt;span class=&quot;kt&quot;&gt;GeoIPService:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;AuthService:&lt;/span&gt; 
  &lt;span class=&quot;kt&quot;&gt;SessionManager:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Localization:&lt;/span&gt;   
  &lt;span class=&quot;kt&quot;&gt;Config:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;EventQueue:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Concurrent:&lt;/span&gt;   
  &lt;span class=&quot;kt&quot;&gt;Async:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;MetricsManager&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;F&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;Feed&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;???&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Unfortunately, if you are following functional programming best practices, and pushing dependencies to the edges, requiring as little as possible from every method, then you will find yourself engaging in tedious repetition of similar lists of context bounds:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-scala&quot; data-lang=&quot;scala&quot;&gt;&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;cacheFeed&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;F&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;_&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Monad:&lt;/span&gt; 
  &lt;span class=&quot;kt&quot;&gt;Logging:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;UserDatabase:&lt;/span&gt;         
  &lt;span class=&quot;kt&quot;&gt;ProfileDatabase:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;RedisCache:&lt;/span&gt;  
  &lt;span class=&quot;kt&quot;&gt;Config:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;EventQueue:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Concurrent:&lt;/span&gt;   
  &lt;span class=&quot;kt&quot;&gt;Async:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;MetricsManager&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;](&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;feed&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Feed&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;F&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;Unit&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;???&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Some developers try to work around this tedium by creating “module” classes that declare the same set of dependencies for every method inside the module—even if many methods require less than the full set of constraints across all methods.&lt;/p&gt;

&lt;p&gt;This technique makes it easier to deal with the tedium, but at the cost of overly constraining methods and making weakening so-called &lt;em&gt;parametric reasoning&lt;/em&gt;.&lt;/p&gt;

&lt;h3 id=&quot;stubborn-repetition&quot;&gt;Stubborn Repetition&lt;/h3&gt;

&lt;p&gt;Not only is there a lot of repetition in tagless-final programs, but this repetition proves stubborn to abstraction.&lt;/p&gt;

&lt;p&gt;Ideally, if we have two methods with the same set of type class constraints, we’d like to be able to create &lt;em&gt;something&lt;/em&gt; to represent that set of constraints, and then use it to remove the duplication across the two methods:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-scala&quot; data-lang=&quot;scala&quot;&gt;&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;method1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;F&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;_&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;AllConstraints&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;???&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;method2&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;F&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;_&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;AllConstraints&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;???&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Unfortunately, Scala does not have any mechanism to abstract across duplicated parameter lists.&lt;/p&gt;

&lt;p&gt;So not only is the repetition quite tedious, but it’s unavoidable, due to limitations in the Scala programming language.&lt;/p&gt;

&lt;h3 id=&quot;completely-uninferrable&quot;&gt;Completely Uninferrable&lt;/h3&gt;

&lt;p&gt;One of the reasons writing Haskell or PureScript is so exceedingly pleasant is the universal and flawless type inference. Scala has enough type inference to make it a joy compared to Java, but many types in Scala cannot be infered (full inference for a higher-kinded type system in the presence of subtyping is still research-grade).&lt;/p&gt;

&lt;p&gt;We would love to be able to take advantage of type inference for tagless-final programs, writing the equivalent of:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-scala&quot; data-lang=&quot;scala&quot;&gt;&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;genFeed&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;...&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Unfortunately, the type class constraints cannot be inferred, even in theory, because they are not actually type parameters, but values in an implicit parameter list (in a language in which anything can be implicit), and asking any compiler to infer arbitrary implicit parameter lists is unreasonable.&lt;/p&gt;

&lt;p&gt;Not only do we have to type out the full list of constraints every time, but if we get the constraints wrong, the error messages will fail with non-obvious “implicit not found” or “method not found” errors.&lt;/p&gt;

&lt;p&gt;The lack of full type inference for tagless-final programs makes writing them an exercise in discipline and self-control, and raises the knowledge and skill barrier for becoming proficient in writing programs in this style.&lt;/p&gt;

&lt;h3 id=&quot;fake-parametric-guarantees&quot;&gt;Fake Parametric Guarantees&lt;/h3&gt;

&lt;p&gt;An often-touted benefit of tagless-final is that it provides us with &lt;em&gt;parametric reasoning&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;This claim is not without merit. For example, if we look at the following method signature, we should be able to tell from its type that it works with any effect that provides &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Monad&lt;/code&gt;, and is therefore free of effects (it may only use &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Monad&lt;/code&gt; operations, such as &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;map&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;flatMap&lt;/code&gt;, and &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ap&lt;/code&gt;):&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-scala&quot; data-lang=&quot;scala&quot;&gt;&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;innocent&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;F&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;_&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Monad&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;F&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;Unit&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;???&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;However, since Scala does not restrict procedural effects, this means that we can embed them anywhere, even in supposedly pure code like this:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-scala&quot; data-lang=&quot;scala&quot;&gt;&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;innocent&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;F&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;_&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Monad&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;F&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;Unit&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;nf&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;What guarantees?&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;

  &lt;span class=&quot;nc&quot;&gt;Monad&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;F&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;].&lt;/span&gt;&lt;span class=&quot;py&quot;&gt;point&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(())&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Worse still, it is trivial to write a helper method that can embed &lt;em&gt;any&lt;/em&gt; effect into any &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Applicative&lt;/code&gt;, even an &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Applicative&lt;/code&gt; with a strict (non-lazy) version of &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;point&lt;/code&gt;:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-scala&quot; data-lang=&quot;scala&quot;&gt;&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;effect&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;F&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;_&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Applicative&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;](&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;A&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;F&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;A&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;=&lt;/span&gt; 
  &lt;span class=&quot;nc&quot;&gt;Applicative&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;F&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;].&lt;/span&gt;&lt;span class=&quot;py&quot;&gt;point&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(()).&lt;/span&gt;&lt;span class=&quot;py&quot;&gt;map&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;_&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;The &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;effect&lt;/code&gt; helper method itself violates neither Scalazzi (the pure functional subset of Scala), nor any &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Applicative&lt;/code&gt; laws.&lt;/p&gt;

&lt;p&gt;We may use this helper method to further contaminate the original definition of &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;innocent&lt;/code&gt;:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-scala&quot; data-lang=&quot;scala&quot;&gt;&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;innocent&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;F&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;_&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Monad&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;F&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;Unit&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;nf&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;What guarantees?&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;

  &lt;span class=&quot;nf&quot;&gt;effect&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;py&quot;&gt;exit&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;42&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;))&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;We’ve now trivially embedding a raw effect, which will be executed before the creation of &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;F[Unit]&lt;/code&gt;, and an effect inside the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Applicative&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;In a large code base, whatever &lt;em&gt;can&lt;/em&gt; happen, &lt;em&gt;will&lt;/em&gt; happen.&lt;/p&gt;

&lt;p&gt;As a testament to this fact, it is common practice among new users of effect systems to accidentally embed effects inside the functions they pass to &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;map&lt;/code&gt; and &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;flatMap&lt;/code&gt; (in fact, some effect monads &lt;em&gt;encourage&lt;/em&gt; this anti-pattern), as well as embed effects inside lazy versions of the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Monad&lt;/code&gt; &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;point&lt;/code&gt; operation.&lt;/p&gt;

&lt;p&gt;The benefits of &lt;em&gt;parametric reasoning&lt;/em&gt; do apply to tagless-final programs, but only &lt;em&gt;up to discipline&lt;/em&gt;. Yet, a lot of other techniques with fewer drawbacks &lt;em&gt;also&lt;/em&gt; provide reasoning benefits &lt;em&gt;up to discipline&lt;/em&gt;.&lt;/p&gt;

&lt;h3 id=&quot;summary-of-tagless-final&quot;&gt;Summary of Tagless-Final&lt;/h3&gt;

&lt;p&gt;Tagless-final does have benefits and experienced functional programmers have deployed many production-worthy applications using the technique.&lt;/p&gt;

&lt;p&gt;However, looking at all these drawbacks, it’s hard to recommend tagless-final for most Scala shops.&lt;/p&gt;

&lt;p&gt;In my opinion, the technique will never go mainstream, and because of all the machinery and ceremony involved, encouraging tagless-final may push more people away from functional programming in Scala than it lures in.&lt;/p&gt;

&lt;p&gt;As I have long argued, some techniques that work well in other programming languages (like monad transformers in Haskell), simply don’t work well in Scala. We can’t make them work, and nor do we need to, because we can find other techniques that give us similar benefits without the costs.&lt;/p&gt;

&lt;p&gt;In the next section, I present one such technique that I believe is exceptionally well-suited for Scala.&lt;/p&gt;

&lt;h2 id=&quot;discarding-the-extraneous&quot;&gt;Discarding the Extraneous&lt;/h2&gt;

&lt;p&gt;If testability is our primary concern, then it’s possible we can take a page from Java. If we want to write testable code in Java, then we use interfaces, and we provide different implementations for live and test scenarios.&lt;/p&gt;

&lt;p&gt;In the case of our preceding example, we can create a simple Scala trait to represent console capabilities:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-scala&quot; data-lang=&quot;scala&quot;&gt;&lt;span class=&quot;k&quot;&gt;trait&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Console&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;putStrLn&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;line&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;IO&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;Unit&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt;

  &lt;span class=&quot;k&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;getStrLn&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;IO&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;Unit&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;This is just an ordinary interface. The only difference is that the methods return functional effects. They don’t actually &lt;em&gt;do&lt;/em&gt;, they only &lt;em&gt;describe&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;It’s easy to teach this to Scala developers, because they probably have used interfaces in Scala and whatever programming languages they knew before Scala.&lt;/p&gt;

&lt;p&gt;Now our program, which requires console capabilities, can simply accept &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Console&lt;/code&gt; as a parameter:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-scala&quot; data-lang=&quot;scala&quot;&gt;&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;program&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Console&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;IO&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;Unit&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;=&lt;/span&gt; 
  &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;_&lt;/span&gt;    &lt;span class=&quot;k&quot;&gt;&amp;lt;-&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;py&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Good morning, &quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;
                      &lt;span class=&quot;s&quot;&gt;&quot;What is your name?&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;name&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;&amp;lt;-&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;py&quot;&gt;readLine&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;_&lt;/span&gt;    &lt;span class=&quot;k&quot;&gt;&amp;lt;-&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;py&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Good to meet you, $name!&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;yield&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;()&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;We can provide either test or production instances of &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Console&lt;/code&gt;, ensuring we can reliably test our program.&lt;/p&gt;

&lt;p&gt;This technique works reasonably well for tiny programs, but most programs will require more than one service. If you try to scale this technique up, it becomes quite unpleasant:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-scala&quot; data-lang=&quot;scala&quot;&gt;&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;program&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;s1&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Service1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;s2&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Service2&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;s3&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Service3&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;…&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sn&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;ServiceN&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;=&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;&amp;lt;-&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;foo&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;s1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;s9&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;s3&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;localhost&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;42&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;&amp;lt;-&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;bar&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sn&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;s19&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;s3&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1024&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;...&lt;/span&gt;
 &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;yield&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;z&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;The pain results from us having to thread &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;n&lt;/code&gt; services into our methods, and then manually pass subsets of these services into all of the methods that we call.&lt;/p&gt;

&lt;p&gt;Indeed, this is the pain that &lt;em&gt;dependency injection&lt;/em&gt; was invented to solve. It should not be surprising if we take a more object-oriented approach to solving the testability problem, we will end up in dependency injection territory.&lt;/p&gt;

&lt;p&gt;Fortunately, using the &lt;em&gt;module pattern&lt;/em&gt;, we can at least make steps toward something usable.&lt;/p&gt;

&lt;h3 id=&quot;the-module-pattern&quot;&gt;The Module Pattern&lt;/h3&gt;

&lt;p&gt;The module pattern involves placing our services inside a module trait to provide easier composition. Sometimes this pattern can be identified by the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;HasXYZ&lt;/code&gt; naming convention—for example, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;HasConsole&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;To use this pattern, you first define a module, which contains a single field with the appropriate service type:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-scala&quot; data-lang=&quot;scala&quot;&gt;&lt;span class=&quot;k&quot;&gt;trait&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;HasConsole&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;console&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;ConsoleService&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Then you define the service type as normal:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-scala&quot; data-lang=&quot;scala&quot;&gt;&lt;span class=&quot;k&quot;&gt;trait&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;ConsoleService&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;putStrLn&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;line&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;IO&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;Unit&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt;

  &lt;span class=&quot;k&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;getStrLn&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;IO&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;Unit&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Now personally, to avoid extraneous typing, I prefer to choose a simplified naming convention and organizational style: I use a shortname for the module, and put the service definition inside the companion object of the module.&lt;/p&gt;

&lt;p&gt;For example:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-scala&quot; data-lang=&quot;scala&quot;&gt;&lt;span class=&quot;k&quot;&gt;trait&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Console&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;console&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Console.Service&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;object&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Console&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;trait&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Service&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;putStrLn&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;line&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;IO&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;Unit&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;getStrLn&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;IO&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;Unit&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;In any case, with the module pattern, we are now able to take advantage of &lt;em&gt;intersection types&lt;/em&gt; to compose multiple modules into a single module.&lt;/p&gt;

&lt;h3 id=&quot;module-composition&quot;&gt;Module Composition&lt;/h3&gt;

&lt;p&gt;Scala 3 has first-class support for intersection types. But in the meantime, we can use the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;with&lt;/code&gt; operator, which provides pseudo-intersection types.&lt;/p&gt;

&lt;p&gt;The &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;with&lt;/code&gt; operator enables us to create a type that must satisfy multiple requirements. In our case, we can use it to create a module that contains many services.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-scala&quot; data-lang=&quot;scala&quot;&gt;&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;program&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Module1&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;with&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Module2&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;...&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;with&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;ModuleN&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;=&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;&amp;lt;-&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;foo&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;localhost&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;42&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;&amp;lt;-&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;bar&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1024&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;...&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;yield&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;z&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Notice the &lt;em&gt;dramatic&lt;/em&gt; reduction in the amount of work necessary to thread services throughout our application.&lt;/p&gt;

&lt;p&gt;Our method now takes a single service parameter, which, using intersection types, bundles together all of its module dependencies into a single module.&lt;/p&gt;

&lt;p&gt;Further, when we pass service dependencies down the stack, we can simply pass the bundle, because due to Scala’s support for subtyping, we are free to pass methods &lt;em&gt;more&lt;/em&gt; than they require (this is called &lt;em&gt;contravariance&lt;/em&gt;).&lt;/p&gt;

&lt;p&gt;While a satisfying improvement over the predecessor, there’s still the painful passing of a single parameter all the way from the top of our application to the bottom.&lt;/p&gt;

&lt;p&gt;Fortunately, functional programming provides an extremely simple and elegant solution to this problem.&lt;/p&gt;

&lt;h3 id=&quot;the-reader-monad&quot;&gt;The Reader Monad&lt;/h3&gt;

&lt;p&gt;The &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Reader&lt;/code&gt; monad is a monadic data structure that can be used to automated passing an environment from one level in the application down to lower levels.&lt;/p&gt;

&lt;p&gt;Every level of the application has access to the environment, and they can even do local modifications (the environment can vary at each level of the application, if so desired).&lt;/p&gt;

&lt;p&gt;The &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Reader&lt;/code&gt; monad is explained elsewhere, so I won’t go into depth on how it works, but I’ll present a simple reference implementation:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-scala&quot; data-lang=&quot;scala&quot;&gt;&lt;span class=&quot;k&quot;&gt;case&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Reader&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;-R&lt;/span&gt;, &lt;span class=&quot;kt&quot;&gt;+A&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;](&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;provide&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;R&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;A&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;self&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;=&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;map&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;B&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;](&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;A&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;B&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;flatMap&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;Reader&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;py&quot;&gt;point&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)))&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;flatMap&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;R1&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;&amp;lt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;R&lt;/span&gt;, &lt;span class=&quot;kt&quot;&gt;B&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;](&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;A&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Reader&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;R1&lt;/span&gt;, &lt;span class=&quot;kt&quot;&gt;B&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;])&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;=&lt;/span&gt;
    &lt;span class=&quot;nc&quot;&gt;Reader&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;R&lt;/span&gt;, &lt;span class=&quot;kt&quot;&gt;B&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;](&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;r&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;py&quot;&gt;provide&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;r&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)).&lt;/span&gt;&lt;span class=&quot;py&quot;&gt;provide&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;r&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;))&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;object&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Reader&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;point&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;A&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;](&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;A&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Reader&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;Any&lt;/span&gt;, &lt;span class=&quot;kt&quot;&gt;A&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Reader&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;_&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;environment&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;R&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Reader&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;R&lt;/span&gt;, &lt;span class=&quot;kt&quot;&gt;R&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Reader&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;identity&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;access&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;R&lt;/span&gt;, &lt;span class=&quot;kt&quot;&gt;A&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;](&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;R&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;A&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Reader&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;R&lt;/span&gt;, &lt;span class=&quot;kt&quot;&gt;A&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;=&lt;/span&gt; 
    &lt;span class=&quot;n&quot;&gt;environment&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;R&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;].&lt;/span&gt;&lt;span class=&quot;py&quot;&gt;map&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;A &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Reader[R, A]&lt;/code&gt; is an effect that requires environment &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;R&lt;/code&gt; and produces a value of type &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;A&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;So, for example, a &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Reader[Config, String]&lt;/code&gt; is an effect that requires a &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Config&lt;/code&gt; and produces a value of type &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;String&lt;/code&gt;. To extract the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;String&lt;/code&gt; from the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Reader&lt;/code&gt;, you first have to &lt;em&gt;provide&lt;/em&gt; the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Config&lt;/code&gt; that it requires:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-scala&quot; data-lang=&quot;scala&quot;&gt;&lt;span class=&quot;k&quot;&gt;case&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Config&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;serverName&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;port&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Int&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;serverName&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Reader&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;Config&lt;/span&gt;, &lt;span class=&quot;kt&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;=&lt;/span&gt; 
  &lt;span class=&quot;nv&quot;&gt;Reader&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;py&quot;&gt;access&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;Config&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;](&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;_&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;py&quot;&gt;serverName&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;name&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;serverName&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;py&quot;&gt;provide&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Config&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;localhost&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;43&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;))&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Now a &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Reader[Any, A]&lt;/code&gt; means that the effect can work with &lt;em&gt;any&lt;/em&gt; environment. This is equivalent to saying it requires &lt;em&gt;no&lt;/em&gt; environment. You can extract values from these type of effects by supplying any value at all (for example, unit):&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-scala&quot; data-lang=&quot;scala&quot;&gt;&lt;span class=&quot;k&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;tempFile&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Reader&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;Any&lt;/span&gt;, &lt;span class=&quot;kt&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;=&lt;/span&gt; 
  &lt;span class=&quot;nv&quot;&gt;Reader&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;py&quot;&gt;point&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;/tmp/tempfile.dat&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;file&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;tempFile&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;py&quot;&gt;provide&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(())&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Note that the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Reader&lt;/code&gt; definition above only models &lt;em&gt;reader&lt;/em&gt; effects, not effects like input / output, which were modeled by our previous &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;IO&lt;/code&gt; data type.&lt;/p&gt;

&lt;p&gt;However, if we ignore that fact, then if one squints hard enough, one can see a path forward to a final simplification of the module pattern, which uses the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Reader&lt;/code&gt; monad to pass modules:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-scala&quot; data-lang=&quot;scala&quot;&gt;&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;program&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Reader&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;Module1&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;with&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;...&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;with&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;ModuleN&lt;/span&gt;, &lt;span class=&quot;kt&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;=&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;&amp;lt;-&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;foo&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;localhost&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;42&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;&amp;lt;-&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;bar&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1024&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;...&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;yield&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;z&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;This step is not so far away. There is a &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Reader&lt;/code&gt; monad transformer that can add the reader effect to any base monad, including the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;IO&lt;/code&gt; monad. However, not only are monad transformers very slow in Scala (adding 2-4x overhead per layer), but they have clumsy ergonomics and bad type inference.&lt;/p&gt;

&lt;p&gt;So instead, using a technique called &lt;a href=&quot;/articles/rotating-effects&quot;&gt;effect rotation&lt;/a&gt;, we can bake the reader effect into the base effect monad, yielding a data type that is high-performance, and, if we are &lt;em&gt;very thoughtful&lt;/em&gt; in the design of the data type, opening the door to &lt;em&gt;delightful&lt;/em&gt; ergonomics and &lt;em&gt;flawless&lt;/em&gt; type inference.&lt;/p&gt;

&lt;p&gt;This is the approach taken by &lt;em&gt;ZIO Environment&lt;/em&gt;, a new feature in ZIO and quite possibly the most defining feature of the impending 1.0 release of the ZIO library.&lt;/p&gt;

&lt;h2 id=&quot;zio-environment&quot;&gt;ZIO Environment&lt;/h2&gt;

&lt;p&gt;ZIO Environment uses a functional effect data type with three type parameters:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-scala&quot; data-lang=&quot;scala&quot;&gt;&lt;span class=&quot;nc&quot;&gt;ZIO&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;R&lt;/span&gt;, &lt;span class=&quot;kt&quot;&gt;E&lt;/span&gt;, &lt;span class=&quot;kt&quot;&gt;A&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;The interpretation of these type parameters is as follows:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;R&lt;/code&gt;—This is the type of the environment required to run the effect, which can range from a bundle of modules, to just some configuration details, to &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Any&lt;/code&gt; (indicating no requirement).&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;E&lt;/code&gt;—This is the type of error the effect may fail with, which can range from &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Throwable&lt;/code&gt;, to a custom data type (which may or may not extend &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Throwable&lt;/code&gt; / &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Exception&lt;/code&gt;), to &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Nothing&lt;/code&gt; (indicating the effect cannot fail).&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;A&lt;/code&gt;—This is the type of value the effect may succeed with, which can be anything, but if the effect runs forever (or runs until error), it could also be &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Nothing&lt;/code&gt;.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Not everyone may be comfortable using the full ZIO data type, so the library defines three type synonyms for common cases:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-scala&quot; data-lang=&quot;scala&quot;&gt;&lt;span class=&quot;k&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;UIO&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;+A&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;ZIO&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;Any&lt;/span&gt;, &lt;span class=&quot;kt&quot;&gt;Nothing&lt;/span&gt;, &lt;span class=&quot;kt&quot;&gt;A&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Task&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;+A&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;ZIO&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;Any&lt;/span&gt;, &lt;span class=&quot;kt&quot;&gt;Throwable&lt;/span&gt;, &lt;span class=&quot;kt&quot;&gt;A&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;IO&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;+E&lt;/span&gt;, &lt;span class=&quot;kt&quot;&gt;+A&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;ZIO&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;Any&lt;/span&gt;, &lt;span class=&quot;kt&quot;&gt;E&lt;/span&gt;, &lt;span class=&quot;kt&quot;&gt;A&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;The meaning of these types is as follows:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;UIO&lt;/code&gt;—Unexceptional effect, which doesn’t require any specific environment and cannot fail.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Task&lt;/code&gt;—An effect that doesn’t require any specific environment and can fail with any &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Throwable&lt;/code&gt;.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;IO&lt;/code&gt;—An effect that can fail with an &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;E&lt;/code&gt;.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;All of these type aliases have companion objects, which can be used to construct values of these types. For example, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Task.succeed(42)&lt;/code&gt; constructs a &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Task[Int]&lt;/code&gt;, which of course is really a &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ZIO[Any, Throwable, Int]&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;This hierarchy of power allows users to start with &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Task&lt;/code&gt; and possibly &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;UIO&lt;/code&gt; (any type they handle errors, they’ll get something that has type &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;UIO&lt;/code&gt;), and then gradually migrate to either &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;IO&lt;/code&gt; or &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ZIO&lt;/code&gt;, or maybe their own type alias that uses offers a combination of types suited to their application.&lt;/p&gt;

&lt;p&gt;In this post, I won’t talk about the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;E&lt;/code&gt; and &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;A&lt;/code&gt; parameters, since you can find &lt;a href=&quot;/articles/bifunctor-io&quot;&gt;previous material&lt;/a&gt; on these, and &lt;a href=&quot;https://github.com/scalaz/scalaz-zio&quot;&gt;ZIO itself&lt;/a&gt;, including Scaladoc and the microsite, have extensive documentation on failure and success values.&lt;/p&gt;

&lt;p&gt;Rather, I’ll focus on a few methods that help you use the new &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;R&lt;/code&gt; type parameter, and then we’ll take a look at how we can use these methods to solve the testability problem.&lt;/p&gt;

&lt;h3 id=&quot;core-environment&quot;&gt;Core Environment&lt;/h3&gt;

&lt;p&gt;ZIO Environment just adds two new primitive functions (and then a couple helpers based on these):&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-scala&quot; data-lang=&quot;scala&quot;&gt;&lt;span class=&quot;k&quot;&gt;sealed&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;trait&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;ZIO&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;-R&lt;/span&gt;, &lt;span class=&quot;kt&quot;&gt;+E&lt;/span&gt;, &lt;span class=&quot;kt&quot;&gt;+A&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;...&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;provide&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;environment&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;R&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;ZIO&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;Any&lt;/span&gt;, &lt;span class=&quot;kt&quot;&gt;E&lt;/span&gt;, &lt;span class=&quot;kt&quot;&gt;A&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;...&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;...&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;object&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;ZIO&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;...&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;accessM&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;R&lt;/span&gt;, &lt;span class=&quot;kt&quot;&gt;E&lt;/span&gt;, &lt;span class=&quot;kt&quot;&gt;A&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;](&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;R&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;ZIO&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;R&lt;/span&gt;, &lt;span class=&quot;kt&quot;&gt;E&lt;/span&gt;, &lt;span class=&quot;kt&quot;&gt;A&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;])&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;ZIO&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;R&lt;/span&gt;, &lt;span class=&quot;kt&quot;&gt;E&lt;/span&gt;, &lt;span class=&quot;kt&quot;&gt;A&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;=&lt;/span&gt;  
    &lt;span class=&quot;o&quot;&gt;...&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;access&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;R&lt;/span&gt;, &lt;span class=&quot;kt&quot;&gt;E&lt;/span&gt;, &lt;span class=&quot;kt&quot;&gt;A&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;](&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;R&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;A&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;ZIO&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;R&lt;/span&gt;, &lt;span class=&quot;kt&quot;&gt;Nothing&lt;/span&gt;, &lt;span class=&quot;kt&quot;&gt;A&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;=&lt;/span&gt;
    &lt;span class=&quot;nf&quot;&gt;accessM&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;ZIO&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;py&quot;&gt;succeed&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;_&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;))&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;environment&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;R&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;ZIO&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;R&lt;/span&gt;, &lt;span class=&quot;kt&quot;&gt;Nothing&lt;/span&gt;, &lt;span class=&quot;kt&quot;&gt;R&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;access&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;identity&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;The core functions are &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ZIO#provide&lt;/code&gt;, which allows you to “feed” an &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;R&lt;/code&gt; to an effect that requires an &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;R&lt;/code&gt;, to eliminate its requirement; by changing the environment type parameter to &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Any&lt;/code&gt;); and &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ZIO.accessM&lt;/code&gt;, which allows you to effectfully access part of the environment.&lt;/p&gt;

&lt;p&gt;Just like a function whose input requires &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Any&lt;/code&gt; can be fed anything (including &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;()&lt;/code&gt;), and which therefore has no requirements, an effect whose environment is &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Any&lt;/code&gt; has no requirements (this is different than &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ZIO[Unit, E, A]&lt;/code&gt;, which is a type indicating the effect requires the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Unit&lt;/code&gt; value).&lt;/p&gt;

&lt;p&gt;The helper functions are &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ZIO.access&lt;/code&gt;, which allows you to (non-effectfully) access part of the environment, and &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ZIO.environment&lt;/code&gt;, which gives you the whole environment.&lt;/p&gt;

&lt;p&gt;To really understand how the core methods can help us solve the testability problem, let’s revisit the console example, this time using ZIO Environment.&lt;/p&gt;

&lt;h3 id=&quot;console-environment&quot;&gt;Console Environment&lt;/h3&gt;

&lt;p&gt;To make our console program testable, we’re going to start out defining a module and associated service class. We’ve seen these before, and there are no substantial changes this time around:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-scala&quot; data-lang=&quot;scala&quot;&gt;&lt;span class=&quot;k&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;scalaz.zio._&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;trait&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Console&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;console&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Console.Service&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;object&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Console&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;trait&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Service&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;line&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;UIO&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;Unit&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;readLine&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;IO&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;IOException&lt;/span&gt;, &lt;span class=&quot;kt&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;trait&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Live&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;extends&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;Console&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;py&quot;&gt;Service&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;scala.io.StdIn.readLine&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;line&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;=&lt;/span&gt; 
      &lt;span class=&quot;nv&quot;&gt;UIO&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;py&quot;&gt;effectTotal&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;scala&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;py&quot;&gt;io&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;py&quot;&gt;StdIn&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;py&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;line&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;))&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;readLine&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;=&lt;/span&gt; 
      &lt;span class=&quot;nv&quot;&gt;IO&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;py&quot;&gt;effect&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;readLine&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()).&lt;/span&gt;&lt;span class=&quot;py&quot;&gt;refineOrDie&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;JustIOExceptions&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;object&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Live&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;extends&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Live&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Note that in the console service, the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;println&lt;/code&gt; function returns a &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;UIO[Unit]&lt;/code&gt; (because it cannot fail), while the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;readLine&lt;/code&gt; function returns an &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;IO[IOException, String]&lt;/code&gt;, because it might fail because of an &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;IOException&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;If you wanted to be less precise, but also eliminate the need to think about the types, you could just use &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Task&lt;/code&gt; everywhere, which is more familiar to Scala developers who have used &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Future&lt;/code&gt; and don’t yet think about typed errors.&lt;/p&gt;

&lt;p&gt;The &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Console&lt;/code&gt; companion object holds an implementation of the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Live&lt;/code&gt; version, while a test implementation of the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Console.Service&lt;/code&gt; interface could live inside a test package.&lt;/p&gt;

&lt;p&gt;Notice how there are no polymorphic types, no higher-kinded types, no type classes, no type class instances, no implicits, and no monads. This is literally just an interface and implementation, where the methods return functional effects.&lt;/p&gt;

&lt;p&gt;The next step is to define a few helper functions, to make using the module easier. This step isn’t necessary, but it’s convenient, so I’ll show the technique:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-scala&quot; data-lang=&quot;scala&quot;&gt;&lt;span class=&quot;k&quot;&gt;package&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;object&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;console&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;line&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;ZIO&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;Console&lt;/span&gt;, &lt;span class=&quot;kt&quot;&gt;Nothing&lt;/span&gt;, &lt;span class=&quot;kt&quot;&gt;Unit&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;=&lt;/span&gt;
    &lt;span class=&quot;nv&quot;&gt;ZIO&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;py&quot;&gt;accessM&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;_&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;py&quot;&gt;console&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;println&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;line&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;

  &lt;span class=&quot;k&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;readLine&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;ZIO&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;Console&lt;/span&gt;, &lt;span class=&quot;kt&quot;&gt;IOException&lt;/span&gt;, &lt;span class=&quot;kt&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;=&lt;/span&gt;
    &lt;span class=&quot;nv&quot;&gt;ZIO&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;py&quot;&gt;accessM&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;_&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;py&quot;&gt;console&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;py&quot;&gt;readLine&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;This package object, which I called &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;console&lt;/code&gt;, defines &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;println&lt;/code&gt; and &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;readLine&lt;/code&gt; functions that return functional effects. These functional effects are defined by using &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ZIO.accessM&lt;/code&gt;, which gives us access to any set of modules we want. In this case, we just need the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Console&lt;/code&gt; module, which is reflected in the return types.&lt;/p&gt;

&lt;p&gt;Using these helper functions, we can now build our purely functional ZIO program:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-scala&quot; data-lang=&quot;scala&quot;&gt;&lt;span class=&quot;k&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;console._&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;program&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;ZIO&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;Console&lt;/span&gt;, &lt;span class=&quot;kt&quot;&gt;IOException&lt;/span&gt;, &lt;span class=&quot;kt&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;=&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;_&lt;/span&gt;    &lt;span class=&quot;k&quot;&gt;&amp;lt;-&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Good morning, what is your name?&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;name&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;&amp;lt;-&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;readLine&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;_&lt;/span&gt;    &lt;span class=&quot;k&quot;&gt;&amp;lt;-&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Good to meet you, $name!&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;yield&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;name&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Again notice the simplicity of this definition. Without any of the final tagless machinery, a basic understanding of functional effects and &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;for&lt;/code&gt; comprehensions is all that’s necessary to write code like this.&lt;/p&gt;

&lt;p&gt;Now when we need to unsafely interpret this data structure into the effect that it represents, we will generally first provide its required environment using the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ZIO#provide&lt;/code&gt; method. Since this effect only requires &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Console&lt;/code&gt;, and since we have already written an implementation in &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Console.Live&lt;/code&gt;, we can easily provide our program its production environment:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-scala&quot; data-lang=&quot;scala&quot;&gt;&lt;span class=&quot;k&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;programLive&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;IO&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;IOException&lt;/span&gt;, &lt;span class=&quot;kt&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;=&lt;/span&gt; 
  &lt;span class=&quot;nv&quot;&gt;program&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;py&quot;&gt;provide&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;Console&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;py&quot;&gt;Live&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Notice the use of the type synonym &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;IO[IOException, String]&lt;/code&gt;, which of course expands to &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ZIO[Any, IOException, String]&lt;/code&gt;, indicating our effect no longer requires any specific environment.&lt;/p&gt;

&lt;p&gt;We’re now ready to run our program, which we can do with the default runtime system in ZIO:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-scala&quot; data-lang=&quot;scala&quot;&gt;&lt;span class=&quot;nv&quot;&gt;DefaultRuntime&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;py&quot;&gt;unsafeRun&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;programLive&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;It’s nearly as easy to test our program. All we have to do is construct an implementation of the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Console.Service&lt;/code&gt; interface for testing:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-scala&quot; data-lang=&quot;scala&quot;&gt;&lt;span class=&quot;k&quot;&gt;object&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;TestConsole&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;extends&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Console&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;console&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Console.Service&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;...&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Now we can run the same program using our test service:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-scala&quot; data-lang=&quot;scala&quot;&gt;&lt;span class=&quot;k&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;programTest&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;program&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;py&quot;&gt;provide&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;TestConsole&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;nv&quot;&gt;DefaultRuntime&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;py&quot;&gt;unsafeRun&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;programTest&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;That’s all there is to ZIO Environment! With just two primitives (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;provide&lt;/code&gt; and &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;accessM&lt;/code&gt;), and an additional type parameter, we’re able to completely solve the testability problem in a way that requires only a tiny fraction of the knowledge and skills of tagless-final.&lt;/p&gt;

&lt;p&gt;But it gets even better than this!&lt;/p&gt;

&lt;h3 id=&quot;delightful-functional-effects&quot;&gt;Delightful Functional Effects&lt;/h3&gt;

&lt;p&gt;Tagless-final had a number of drawbacks beyond just a massive ramp up curve. In the next few sections, we’ll look at how ZIO Environment stacks up against tagless-final.&lt;/p&gt;

&lt;h4 id=&quot;composable&quot;&gt;Composable&lt;/h4&gt;

&lt;p&gt;Like tagless-final, ZIO Environment is composable: we can compose requirements horizontally, using the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;with&lt;/code&gt; operator for type intersection:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-scala&quot; data-lang=&quot;scala&quot;&gt;&lt;span class=&quot;k&quot;&gt;trait&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Console&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;console&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Console.Service&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;trait&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Logging&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;logging&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Logging.Service&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;trait&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Persistence&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;persistence&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Persistence.Service&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;...&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;program&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;ZIO&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;Console&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;with&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Logging&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;with&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Persistence&lt;/span&gt;,
                 &lt;span class=&quot;kt&quot;&gt;ProgramError&lt;/span&gt;, &lt;span class=&quot;kt&quot;&gt;Unit&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;...&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;h4 id=&quot;performant&quot;&gt;Performant&lt;/h4&gt;

&lt;p&gt;Like tagless-final, but to an even greater extent (because all ZIO methods are monomorphic), ZIO Environment is high-performance.&lt;/p&gt;

&lt;p&gt;If you tried to emulate the ZIO Environment technique in another effect type, using the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ReaderT&lt;/code&gt; monad transformer, then you would suffer as much as a 4x performance penalty. If you tried to emulate both ZIO Typed Errors as well, using an &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;EitherT&lt;/code&gt; monad transformer, you could suffer as much as an 8x performance penalty.&lt;/p&gt;

&lt;p&gt;Thanks to effect rotation, ZIO gives you the benefits of the reader and either monad transformers, without any of the cost, and with far better ergonomics and type inference.&lt;/p&gt;

&lt;h4 id=&quot;fully-inferable&quot;&gt;Fully Inferable&lt;/h4&gt;

&lt;p&gt;As an experienced functional programmer who has used and generally likes tagless-final, I personally find one of the most compelling benefits of ZIO Environment to be &lt;em&gt;type inference&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Thanks to a careful design and appropriate use of variance, ZIO is fully inferable (!). In fact, as far as I’m aware, it’s the &lt;em&gt;only&lt;/em&gt; approach to testable functional effects in Scala that’s demonstrated to be fully inferable.&lt;/p&gt;

&lt;p&gt;This means if you use many different modules, you can call functions from all the modules, and the Scala compiler will infer the proper environment.&lt;/p&gt;

&lt;p&gt;As an example:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-scala&quot; data-lang=&quot;scala&quot;&gt;&lt;span class=&quot;k&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;program&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;=&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;_&lt;/span&gt;    &lt;span class=&quot;k&quot;&gt;&amp;lt;-&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;putStrLn&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Good morning, what is your name?&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;name&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;&amp;lt;-&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;getStrLn&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;_&lt;/span&gt;    &lt;span class=&quot;k&quot;&gt;&amp;lt;-&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;savePreferences&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;_&lt;/span&gt;    &lt;span class=&quot;k&quot;&gt;&amp;lt;-&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;py&quot;&gt;debug&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Saved $name to configuration&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;_&lt;/span&gt;    &lt;span class=&quot;k&quot;&gt;&amp;lt;-&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;putStrLn&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Good to meet you, $name!&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;yield&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;()&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;In this case, Scala will infer the environment to be &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Console with Persistence with Logging&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Not only can Scala infer the type, but if you give an explicit type annotation, but it’s incorrect, the hints that Scala provides will eventually lead you to the correct type signature.&lt;/p&gt;

&lt;p&gt;Even if you believe in providing top-level type signatures, being able to infer local signatures, have your IDE insert the top-level signatures, or just ask Scala for the correct type (by intentionally inserting the wrong type) is a tremendous benefit to productivity and makes working with ZIO effects an extremely pleasant experience.&lt;/p&gt;

&lt;h4 id=&quot;concise&quot;&gt;Concise&lt;/h4&gt;

&lt;p&gt;With full inference, ZIO can be extremely concise. However, inference is actually not necessary for concision.&lt;/p&gt;

&lt;p&gt;Because ZIO Environment uses a type parameter, and because Scala has type aliases, this means we can eliminate all duplication in method signatures:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-scala&quot; data-lang=&quot;scala&quot;&gt;&lt;span class=&quot;k&quot;&gt;trait&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Console&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;console&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Console.Service&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;trait&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Logging&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;logging&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Logging.Service&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;trait&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Persistence&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;persistence&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Persistence.Service&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;...&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;ProgramEnv&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Console&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;with&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Logging&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;with&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Persistence&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;program1&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;ZIO&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;ProgramEnv&lt;/span&gt;, &lt;span class=&quot;kt&quot;&gt;AppError&lt;/span&gt;, &lt;span class=&quot;kt&quot;&gt;Unit&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;...&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;program2&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;ZIO&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;ProgramEnv&lt;/span&gt;, &lt;span class=&quot;kt&quot;&gt;AppError&lt;/span&gt;, &lt;span class=&quot;kt&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;...&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;In fact, if we want to create a custom effect type, with our own environment and error type, it’s easy to do that too:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-scala&quot; data-lang=&quot;scala&quot;&gt;&lt;span class=&quot;k&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Program&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;A&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;ZIO&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;Console&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;with&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Logging&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;with&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Persistence&lt;/span&gt;, 
                      &lt;span class=&quot;kt&quot;&gt;AppError&lt;/span&gt;, &lt;span class=&quot;kt&quot;&gt;A&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;program1&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Program&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;Unit&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;...&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;program2&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Program&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;...&lt;/span&gt; &lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Type synonyms like this, especially when combined with associated companion objects, can make it possible for beginners to rapidly become productive in a large code base. Further, they enable beginners and experts alike to avoid repeating themselves, which makes code maintenance easier, less costly, and more predictable.&lt;/p&gt;

&lt;h4 id=&quot;modular&quot;&gt;Modular&lt;/h4&gt;

&lt;p&gt;With ZIO Environment, there is no need to build up a monolithic environment. Rather, individual layers of the application can supply local environments to lower layers.&lt;/p&gt;

&lt;p&gt;An example of this technique is shown below:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-scala&quot; data-lang=&quot;scala&quot;&gt;&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;fn1&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;ZIO&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;R1&lt;/span&gt;, &lt;span class=&quot;kt&quot;&gt;E&lt;/span&gt;, &lt;span class=&quot;kt&quot;&gt;A&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;fn2&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;ZIO&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;R2&lt;/span&gt;, &lt;span class=&quot;kt&quot;&gt;E&lt;/span&gt;, &lt;span class=&quot;kt&quot;&gt;B&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;...&lt;/span&gt;

  &lt;span class=&quot;k&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;localEnvironment&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;R2&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;...&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;v1&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;fn2&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;py&quot;&gt;provide&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;localEnvironment&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;...&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;globalEnvironment&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;R1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;...&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;v2&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;fn1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;py&quot;&gt;provide&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;globalEnvironment&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;...&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;This is only one technique to provide vertical modularity. Over time, other techniques may emerge.&lt;/p&gt;

&lt;p&gt;Achieving modularity with tagless-final is possible, but quite difficult and hacky, relying on creating local type class instances. In comparison, modularity is something that other approaches like &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Free&lt;/code&gt; and MTL excel at.&lt;/p&gt;

&lt;h4 id=&quot;incremental&quot;&gt;Incremental&lt;/h4&gt;

&lt;p&gt;Unlike tagless-final, a code base that uses no abstraction, which is merely using some base functional effect like &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Task&lt;/code&gt;, can be modified every-so-slightly to allow testability of something deep in the stack.&lt;/p&gt;

&lt;p&gt;For example, let’s say we have a database call deeply embedded everywhere inside our program:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-scala&quot; data-lang=&quot;scala&quot;&gt;&lt;span class=&quot;c1&quot;&gt;// Deeply nested code:
&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;myCode&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Task&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;Unit&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;…&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;...&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;result&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;&amp;lt;-&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;database&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;py&quot;&gt;query&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;q&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;...&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;yield&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;()&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;We would like to be able to test application logic without connecting to a real database, because that will slow our tests down and may fail for unrelated reasons.&lt;/p&gt;

&lt;p&gt;In order to do this, we need merely refactor the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;database.query&lt;/code&gt; function to require a &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Database&lt;/code&gt; module. Then with simple introduction of a type synonym, we can leave the code unchanged:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-scala&quot; data-lang=&quot;scala&quot;&gt;&lt;span class=&quot;k&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;TaskDB&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;A&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;ZIO&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;Database&lt;/span&gt;, &lt;span class=&quot;kt&quot;&gt;Throwable&lt;/span&gt;, &lt;span class=&quot;kt&quot;&gt;A&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;...&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;myCodeV2&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;TaskDB&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;Unit&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;…&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;...&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;result&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;&amp;lt;-&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;database&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;py&quot;&gt;query&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;q&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;...&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;yield&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;()&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;All of the other code can stay exactly the same as it is. The only change we needed to make was the type synonym (which we could have called &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Task&lt;/code&gt;, if we didn’t want to update the type signatures at all), and the single method we wanted to make testable.&lt;/p&gt;

&lt;p&gt;In an ideal world, everything would always be 100% testable; and if we needed to make legacy code testable, we would have the resources necessary to make &lt;em&gt;all&lt;/em&gt; the effects testable.&lt;/p&gt;

&lt;p&gt;Yet in the real world, we often don’t have the time or luxury of making our greenfield code &lt;em&gt;fully&lt;/em&gt; testable from day one; &lt;em&gt;or&lt;/em&gt; of doing giant refactorings to legacy code.&lt;/p&gt;

&lt;p&gt;ZIO Environment lets us make &lt;em&gt;pinpoint&lt;/em&gt; changes, and pay for &lt;em&gt;only&lt;/em&gt; the cost of testing what we &lt;em&gt;need&lt;/em&gt; to test today. As a result, it helps us deal with real world code bases and meet the needs of the business.&lt;/p&gt;

&lt;h2 id=&quot;summary&quot;&gt;Summary&lt;/h2&gt;

&lt;p&gt;Functional effects can be enormously beneficial to solving modern business problems. Yet as we’ve seen in this approach, because of the way functional effects are implemented, we don’t gain all the benefits of pure functional code.&lt;/p&gt;

&lt;p&gt;While functional effects give us the ability to abstract over our programs and to refactor them without changing their meaning, we can’t easily test functional effects, because we don’t have a way to compare two effects for equality.&lt;/p&gt;

&lt;p&gt;Solutions like tagless-final help us re-introduce testability into our functional applications (along with other benefits, like parametric reasoning). However, they come with a massive ramp up curve, they don’t integrate well into Scala, and their ergonomics, boilerplate, and ceremony can be unpleasant and further alienating to developers.&lt;/p&gt;

&lt;p&gt;The new approach pioneered in ZIO Environment allows us to regain testability, but without any additional ramp up time (beyond the ramp up required for functional effects). It’s friendly to beginning functional programmers, and unlike tagless-final, the new approach is fully inferable, modular, and can be used incrementally, just where we need it.&lt;/p&gt;

&lt;p&gt;For the first time, it feels like Scala has an idiomatic solution for testable functional effects. Something that’s fast, fully inferable, with a low barrier to entry.&lt;/p&gt;

&lt;p&gt;If you’d like to give it a try, head over to the &lt;a href=&quot;https://github.com/scalaz/scalaz-zio&quot;&gt;ZIO project page&lt;/a&gt;, where you will find the &lt;a href=&quot;https://scalaz.github.io/scalaz-zio/&quot;&gt;ZIO microsite&lt;/a&gt; and the &lt;a href=&quot;https://gitter.im/scalaz/scalaz-zio&quot;&gt;Gitter chatroom&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;As of today, the first release candidate (RC) for ZIO 1.0 has been published, which means a (nearly) stable API and a focus on documentation, polish, and performance. It’s my hope that ZIO 1.0 will be released sometime in March, and that the 1.x line will enjoy at least a full year of backward-compatible tweaks, fine-tunings, and enhancements to the microsite.&lt;/p&gt;

&lt;p&gt;If you’re still using &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Future&lt;/code&gt; and on the fence about a functional effect system, now’s the perfect time to jump in and give ZIO (or one of the other functional effect systems) a try. You might just find you can’t live without one!&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;P.S.&lt;/strong&gt; A huge thanks to &lt;a href=&quot;https://twitter.com/wiemzin&quot;&gt;Wiem Zine Elabidine&lt;/a&gt; for her work on ZIO Environment, and to &lt;a href=&quot;https://twitter.com/itrvd&quot;&gt;Itamar Ravid&lt;/a&gt;, &lt;a href=&quot;https://twitter.com/regiskuckaertz&quot;&gt;Regis Kuckaertz&lt;/a&gt;, and &lt;a href=&quot;https://twitter.com/kaidaxofficial&quot;&gt;Kai&lt;/a&gt; for their early feedback on the ZIO Environment project, and to &lt;a href=&quot;https://twitter.com/skillsmatter&quot;&gt;SkillsMatter&lt;/a&gt; for the opportunity to present this work at Scala Matters, London.&lt;/p&gt;

  &lt;p&gt;&lt;a href=&quot;https://degoes.net/articles/zio-environment&quot;&gt;Beautiful, Simple, Testable Functional Effects for Scala&lt;/a&gt; was originally published by John A De Goes at &lt;a href=&quot;https://degoes.net&quot;&gt;John <em>A</em> <strong>De Goes</strong>&lt;/a&gt; on February 26, 2019.&lt;/p&gt;</content>
</entry>


<entry>
  <title type="html"><![CDATA[Thread Pool Best Practices with ZIO]]></title>
  <link rel="alternate" type="text/html" href="https://degoes.net/articles/zio-threads" />
  <id>https://degoes.net/articles/zio-threads</id>
  <published>2019-01-25T00:00:00-07:00</published>
  <updated>2019-01-25T00:00:00-07:00</updated>
  <author>
    <name>John A De Goes</name>
    <uri>https://degoes.net</uri>
    <email>john@degoes.net</email>
  </author>
  <content type="html">&lt;p&gt;High-performance application’s don’t &lt;em&gt;block&lt;/em&gt;. Blocking is when a thread synchronously waits for something to happen—for example, waits for a lock to be acquired, a result set to be returned from a database, a timer to elapse, or bytes to be read from a socket.&lt;/p&gt;

&lt;p&gt;Instead, high-performance applications are &lt;em&gt;asynchronous&lt;/em&gt;. Instead of synchronously waiting for something to happen, asynchronous applications register callbacks with handlers. Then, when something happens, the callbacks are invoked. This style of programming, which conserves threads (and their associated resources), is called &lt;em&gt;asynchronous programming&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Unfortunately, in 2019, sometimes we &lt;em&gt;must&lt;/em&gt; block on the JVM. Some legacy APIs, and even industry-standard APIs like JDBC, block threads. Given how much valuable blocking synchronous code is out there, we often have no choice but to use it.&lt;/p&gt;

&lt;p&gt;These days, asynchronous data types like &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Future&lt;/code&gt; (combined with &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Promise&lt;/code&gt;) or &lt;a href=&quot;https://github.com/scalaz/scalaz-zio&quot;&gt;ZIO&lt;/a&gt;’s &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;IO&lt;/code&gt; make it straightforward to write asynchronous applications. &lt;a href=&quot;https://github.com/scalaz/scalaz-zio&quot;&gt;ZIO&lt;/a&gt; goes further (like Monix &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Task&lt;/code&gt;) and makes it easy to write hybrid applications that are synchronous and asynchronous.&lt;/p&gt;

&lt;p&gt;The &lt;em&gt;real&lt;/em&gt; trouble starts when asynchronous code is combined with synchronous code.&lt;/p&gt;

&lt;h2 id=&quot;tricky-thread-management&quot;&gt;Tricky Thread Management&lt;/h2&gt;

&lt;p&gt;Asynchronous code executes useful work continuously until it registers its callbacks, and then it suspends until the callbacks are invoked. As soon as the callbacks are registered, the thread executing the asynchronous code is free to do more useful work for other tasks.&lt;/p&gt;

&lt;p&gt;Blocking synchronous code, on the other hand, might execute for a &lt;em&gt;really long time&lt;/em&gt;. A thread might have to wait around for tens or hundreds of milliseconds, or in extreme cases, minutes or hours—all the while, doing absolutely nothing.&lt;/p&gt;

&lt;p&gt;Because asynchronous and blocking code behave differently, we need to be very careful about how we run the different types of code.&lt;/p&gt;

&lt;p&gt;In all cases, we need to execute different tasks on different threads, but creating threads is slow. Instead of creating threads all the time, data types like &lt;a href=&quot;https://github.com/scalaz/scalaz-zio&quot;&gt;ZIO&lt;/a&gt;’s &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;IO&lt;/code&gt; and &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Future&lt;/code&gt; use &lt;em&gt;thread pools&lt;/em&gt;, which are collections of pre-allocated threads that wait around to execute any tasks &lt;em&gt;submitted&lt;/em&gt; to the thread pools.&lt;/p&gt;

&lt;p&gt;CPUs only have a certain number of &lt;em&gt;cores&lt;/em&gt;, each of which can execute tasks more or less independently of the other cores. If we create more threads than cores, then the operating system spends a lot of time switching between threads (&lt;em&gt;context switching&lt;/em&gt;), because the hardware can’t physically run them all at the same time. So &lt;em&gt;ideally&lt;/em&gt;, to be maximally efficient, we would only create as many threads as there are cores, to minimize context switching.&lt;/p&gt;

&lt;p&gt;This strategy works well for asynchronous code, because asynchronous code is constantly doing useful work until it suspends. However, it works poorly for blocking code (halting the application), because a thread pool cannot accept more work after all threads are busy—and for blocking code, they might stay busy (doing nothing!) for a very long time.&lt;/p&gt;

&lt;p&gt;As a result, well-designed applications actually have at least &lt;em&gt;two&lt;/em&gt; thread pools:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;One thread pool, designed for asynchronous code, has a &lt;em&gt;fixed&lt;/em&gt; number of threads, usually equal to the number of cores on the CPU.&lt;/li&gt;
  &lt;li&gt;Another thread pool, designed for blocking code, has a &lt;em&gt;dynamic&lt;/em&gt; number of threads (more threads will be added to the pool when necessary), which is inefficient (but what can you do!).&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Keeping the right tasks on the right thread pools has proven a &lt;em&gt;big mess&lt;/em&gt;, even in modern effect systems. Functional programs can pull in libraries like &lt;a href=&quot;https://twitter.com/davenpcm&quot;&gt;Christopher Davenport&lt;/a&gt;’s excellent &lt;a href=&quot;https://github.com/ChristopherDavenport/linebacker&quot;&gt;linebacker&lt;/a&gt; library.&lt;/p&gt;

&lt;p&gt;However, in preparation for the upcoming release of &lt;a href=&quot;https://github.com/scalaz/scalaz-zio&quot;&gt;ZIO&lt;/a&gt; 1.0, &lt;em&gt;no&lt;/em&gt; additional libraries are necessary for proper thread management, and you gain some &lt;em&gt;killer features&lt;/em&gt; not found in any other effect system.&lt;/p&gt;

&lt;h2 id=&quot;the-zio-trio&quot;&gt;The ZIO Trio&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/scalaz/scalaz-zio&quot;&gt;ZIO&lt;/a&gt; has three functions that make thread management a breeze:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;IO#lock(executor)&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;scalaz.zio.blocking.blocking(task)&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;scalaz.zio.blocking.effectBlocking(task)&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Internally, two of these functions benefit from the fact that the &lt;a href=&quot;https://github.com/scalaz/scalaz-zio&quot;&gt;ZIO&lt;/a&gt; runtime system has two primary thread pools, which are set by the user at the level of the main function. One of these thread pools is for asynchronous code, and one is for blocking code. These pools are configurable, of course, but the built-in defaults provide excellent performance for most applications.&lt;/p&gt;

&lt;p&gt;In order to avoid exhausting the asynchronous code, &lt;a href=&quot;https://github.com/scalaz/scalaz-zio&quot;&gt;ZIO&lt;/a&gt; not only provides thread management functions, but is capable of making long-running asynchronous tasks yield to other tasks, providing a tunable level of fairness, but vastly higher performance than Scala’s own &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Future&lt;/code&gt; (which yields on every operation of every asynchronous task).&lt;/p&gt;

&lt;p&gt;The sections that follow introduce each of the three thread management functions in some detail.&lt;/p&gt;

&lt;h3 id=&quot;lock&quot;&gt;Lock&lt;/h3&gt;

&lt;p&gt;The first method that &lt;a href=&quot;https://github.com/scalaz/scalaz-zio&quot;&gt;ZIO&lt;/a&gt; provides to support thread management is &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;IO#lock&lt;/code&gt;, which allows you to run a task on a given thread pool.&lt;/p&gt;

&lt;p&gt;The &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;lock&lt;/code&gt; function guarantees that the specified task will be executed with a given executor, which chooses the thread pool.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-scala&quot; data-lang=&quot;scala&quot;&gt;&lt;span class=&quot;nv&quot;&gt;task&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;py&quot;&gt;lock&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;executor&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;With other functional effect types, even though you can shift a task to another thread pool (via something like &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;shift&lt;/code&gt; or &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;evalOn&lt;/code&gt;), any asynchronous boundary in the task can shift it &lt;em&gt;off&lt;/em&gt; the thread pool.&lt;/p&gt;

&lt;p&gt;Because whether or not a task is composed of asynchronous boundaries is not visible in its type, it’s impossible to reason locally about &lt;em&gt;where&lt;/em&gt; a task will run using the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;shift&lt;/code&gt; and &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;evalOn&lt;/code&gt; primitives of other effect types. They have poorly-defined semantics.&lt;/p&gt;

&lt;p&gt;The unique guarantee that &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;lock&lt;/code&gt; provides is semantically well-defined and stronger than any other effect system in Scala: the specified task will &lt;em&gt;always&lt;/em&gt; execute on the given thread pool, even in the presence of asynchronous boundaries.&lt;/p&gt;

&lt;p&gt;The &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;lock&lt;/code&gt; function is the missing ingredient for principled task location in purely functional effect systems. It lets you trivially verify with local reasoning that, for example, blocking effects will always be executed on a blocking thread pool; that a client request will always happen in a client library’s thread pool; or that a UI task will always execute on the UI thread, even if composed with other tasks that may need to execute elsewhere.&lt;/p&gt;

&lt;h3 id=&quot;blocking&quot;&gt;Blocking&lt;/h3&gt;

&lt;p&gt;The second method that &lt;a href=&quot;https://github.com/scalaz/scalaz-zio&quot;&gt;ZIO&lt;/a&gt; provides to support thread management is &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;blocking&lt;/code&gt;, which allows you to lock a task on the blocking thread pool.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-scala&quot; data-lang=&quot;scala&quot;&gt;&lt;span class=&quot;k&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;scalaz.zio.blocking._&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;blockingTask&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;blocking&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;task&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;This function is not primitive (it’s implemented in terms of &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;lock&lt;/code&gt; and another function, which provides access to the two primary thread pools in &lt;a href=&quot;https://github.com/scalaz/scalaz-zio&quot;&gt;ZIO&lt;/a&gt;), but it’s one of the most common methods for thread pool management in &lt;a href=&quot;https://github.com/scalaz/scalaz-zio&quot;&gt;ZIO&lt;/a&gt;.&lt;/p&gt;

&lt;h3 id=&quot;blocking-1&quot;&gt;Blocking&lt;/h3&gt;

&lt;p&gt;The third method that &lt;a href=&quot;https://github.com/scalaz/scalaz-zio&quot;&gt;ZIO&lt;/a&gt; provides to support thread management is &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;effectBlocking&lt;/code&gt;, which allows suspending (or &lt;em&gt;importing&lt;/em&gt;) a blocking effect into a pure task.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-scala&quot; data-lang=&quot;scala&quot;&gt;&lt;span class=&quot;c1&quot;&gt;// def effectBlocking[A](effect: =&amp;gt; A): IO[Throwable, A] = ...
&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;scalaz.zio.blocking._&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;interruptibleSleep&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;=&lt;/span&gt;
  &lt;span class=&quot;nf&quot;&gt;effectBlocking&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;Thread&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;py&quot;&gt;sleep&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;Long&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;py&quot;&gt;MaxValue&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;))&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;The &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;effectBlocking&lt;/code&gt; function returns a task that has two important features:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;It executes the effect on the blocking thread pool using the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;blocking&lt;/code&gt; combinator.&lt;/li&gt;
  &lt;li&gt;It is interruptible (assuming the effect is blocking!), and any interruption will delegate to Java’s &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Thread.interrupt&lt;/code&gt;.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;The following code snippet will interrupt a really long &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Thread.sleep&lt;/code&gt; (which is a blocking function on the JVM):&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-scala&quot; data-lang=&quot;scala&quot;&gt;&lt;span class=&quot;k&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;scalaz.zio.blocking.effectBlocking&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;interruptedSleep&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;=&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;fiber&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;&amp;lt;-&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;effectBlocking&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;Thread&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;py&quot;&gt;sleep&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;Long&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;py&quot;&gt;MaxValue&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)).&lt;/span&gt;&lt;span class=&quot;py&quot;&gt;fork&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;_&lt;/span&gt;     &lt;span class=&quot;k&quot;&gt;&amp;lt;-&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;fiber&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;py&quot;&gt;interrupt&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;yield&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;()&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Like &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;lock&lt;/code&gt; and &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;blocking&lt;/code&gt;, this feature is a first for functional effect systems in Scala. Now runaway JDBC queries, thread sleeps, remote file downloads, and other blocking effects can be trivally interrupted in a composable fashion using ordinary &lt;a href=&quot;https://github.com/scalaz/scalaz-zio&quot;&gt;ZIO&lt;/a&gt; interruption.&lt;/p&gt;

&lt;h2 id=&quot;summary&quot;&gt;Summary&lt;/h2&gt;

&lt;p&gt;Proper thread management is essential for efficient applications. High-performance applications on the JVM should use at least two thread pools: a fixed one for asynchronous code, and a dynamic one for blocking code.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/scalaz/scalaz-zio&quot;&gt;ZIO&lt;/a&gt; bakes in these two primary thread pools so users don’t need to worry about them (although, of course, they can be configured as necessary and applications can use many more than just two thread pools).&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/scalaz/scalaz-zio&quot;&gt;ZIO&lt;/a&gt; uses its two primary thread pools to make thread management easy using three functions, which bring unique functionality to the functional effect systems in Scala:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;The &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;lock&lt;/code&gt; function locks a task to a given thread pool (even over asynchronous boundaries!), providing principled, well-defined semantics for locating tasks;&lt;/li&gt;
  &lt;li&gt;The &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;blocking&lt;/code&gt; function locks a task to &lt;a href=&quot;https://github.com/scalaz/scalaz-zio&quot;&gt;ZIO&lt;/a&gt;’s blocking thread pool;&lt;/li&gt;
  &lt;li&gt;The &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;effectBlocking&lt;/code&gt; function suspends a blocking effect into an interruptible &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;IO&lt;/code&gt;, by safely delegating to Java’s own thread interruption, allowing composable interruption of any blocking code.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Thanks to no implicit execution contexts, no implicit context shifts, no weird edge-cases (like asynchronous boundaries shifting a task to another thread pool), built-in asynchronous and blocking thread pools, fairness and performance, and well-defined semantics, &lt;a href=&quot;https://github.com/scalaz/scalaz-zio&quot;&gt;ZIO&lt;/a&gt; makes it easier than ever to build applications that follow best practices.&lt;/p&gt;

&lt;p&gt;Who said functional programming wasn’t practical?&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Thanks to &lt;a href=&quot;https://twitter.com/wiemzin&quot;&gt;Wiem Zine Elabidine&lt;/a&gt; for proofreading this post.&lt;/em&gt;&lt;/p&gt;

  &lt;p&gt;&lt;a href=&quot;https://degoes.net/articles/zio-threads&quot;&gt;Thread Pool Best Practices with ZIO&lt;/a&gt; was originally published by John A De Goes at &lt;a href=&quot;https://degoes.net&quot;&gt;John <em>A</em> <strong>De Goes</strong>&lt;/a&gt; on January 25, 2019.&lt;/p&gt;</content>
</entry>


<entry>
  <title type="html"><![CDATA[High-Performance Functional Programming Through Effect Rotation]]></title>
  <link rel="alternate" type="text/html" href="https://degoes.net/articles/rotating-effects" />
  <id>https://degoes.net/articles/rotating-effects</id>
  <published>2019-01-09T00:00:00-07:00</published>
  <updated>2019-01-09T00:00:00-07:00</updated>
  <author>
    <name>John A De Goes</name>
    <uri>https://degoes.net</uri>
    <email>john@degoes.net</email>
  </author>
  <content type="html">&lt;p&gt;As I covered in a &lt;a href=&quot;/articles/effects-without-transformers&quot;&gt;previous post&lt;/a&gt;, monad transformers have poor performance properties in languages and runtimes unequipped to deal with them—including the Scala programming language and the JRE.&lt;/p&gt;

&lt;p&gt;There’s a general technique to improving performance that involves something I call &lt;em&gt;effect rotation&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;In this post, I’ll talk about effect rotation and provide some examples in Scala and PureScript.&lt;/p&gt;

&lt;h2 id=&quot;vertical-effect-composition&quot;&gt;Vertical Effect Composition&lt;/h2&gt;

&lt;p&gt;Monad transformers are an example of &lt;em&gt;vertical&lt;/em&gt; effect composition. In vertical effect composition, we have layers of data stacked upon data, and layers of types stacked upon types:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-scala&quot; data-lang=&quot;scala&quot;&gt;&lt;span class=&quot;k&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;example&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;EitherT&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;OptionT&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;IO&lt;/span&gt;, &lt;span class=&quot;kt&quot;&gt;?&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt;, &lt;span class=&quot;kt&quot;&gt;Error&lt;/span&gt;, &lt;span class=&quot;kt&quot;&gt;Int&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;=&lt;/span&gt;
  &lt;span class=&quot;nv&quot;&gt;EitherT&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;py&quot;&gt;right&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;OptionT&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;py&quot;&gt;some&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;IO&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;py&quot;&gt;point&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;42&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)))&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-haskell&quot; data-lang=&quot;haskell&quot;&gt;&lt;span class=&quot;n&quot;&gt;example&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;::&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;EitherT&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;OptionT&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;IO&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Error&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Number&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;example&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pure&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pure&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pure&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;$&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;42&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Vertical effect composition has some very desirable properties:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;Effect Introduction&lt;/strong&gt;. A new effect can be dynamically introduced. For example, if you have a base effect &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;f&lt;/code&gt;, you can dynamically introduce state management by using &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;StateT s f&lt;/code&gt;.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Effect Elimination&lt;/strong&gt;. An existing effect can be dynamically eliminated. For example, if you have &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;StateT s f&lt;/code&gt;, you can eliminate the outer effect to yield &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;f&lt;/code&gt;.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Information Hiding&lt;/strong&gt;. In vertical effect composition, you can ignore lower levels of a stack, which results in better composition and more code reuse.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Unfortunately, in too many languages and runtimes, every layer of the effect stack introduces additional overhead. In languages like Scala, the overhead is severe and renders the technique impractical for performance and memory sensitive applications.&lt;/p&gt;

&lt;p&gt;To examine the cost of vertical effects, let’s look at one of the simplest of all monad transformers: &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;EitherT&lt;/code&gt;.&lt;/p&gt;

&lt;h2 id=&quot;the-cost-of-eithert&quot;&gt;The Cost of &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;EitherT&lt;/code&gt;&lt;/h2&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;EitherT&lt;/code&gt; adds the effect of &lt;em&gt;recoverable failure&lt;/em&gt; onto a base effect &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;f&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;We can define this transformer quite simply:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-scala&quot; data-lang=&quot;scala&quot;&gt;&lt;span class=&quot;k&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;case&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;EitherT&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;F&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;_&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;]&lt;/span&gt;, &lt;span class=&quot;kt&quot;&gt;E&lt;/span&gt;, &lt;span class=&quot;kt&quot;&gt;A&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;](&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;run&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;F&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;Either&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;E&lt;/span&gt;, &lt;span class=&quot;kt&quot;&gt;A&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]])&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-haskell&quot; data-lang=&quot;haskell&quot;&gt;&lt;span class=&quot;kr&quot;&gt;data&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;EitherT&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;e&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;m&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;EitherT&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;m&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;Either&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;e&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;I won’t prove this here, but when the base effect &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;f&lt;/code&gt; is a monad, then &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;EitherT e f&lt;/code&gt; is also a monad, for all &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;e&lt;/code&gt;. Essentially, if you stack &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;EitherT&lt;/code&gt; onto something that’s a monad, you get &lt;em&gt;back&lt;/em&gt; something that is also a monad.&lt;/p&gt;

&lt;p&gt;Notice the properties of this encoding:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;strong&gt;Effect Introduction&lt;/strong&gt;. We can introduce the effect of &lt;em&gt;recoverable errors&lt;/em&gt; atop any monad &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;f&lt;/code&gt; by lifting a &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;f&lt;/code&gt; into &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;EitherT e f&lt;/code&gt;.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Effect Elimination&lt;/strong&gt;. We can eliminate the effect of &lt;em&gt;recoverable errors&lt;/em&gt; by “running” the monad transformer, which gets us &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;f (Either e a)&lt;/code&gt;.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Information Hiding&lt;/strong&gt;. We can write polymorphic code that does not know what &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;f&lt;/code&gt; is, but which utilizes the effect of &lt;em&gt;recoverable errors&lt;/em&gt; atop the base monad.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;These properties, however, come at &lt;em&gt;severe performance cost&lt;/em&gt;.&lt;/p&gt;

&lt;h3 id=&quot;binding-vertical-effects&quot;&gt;Binding Vertical Effects&lt;/h3&gt;

&lt;p&gt;It’s easy to see from the structure of &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;EitherT&lt;/code&gt; that it wraps the underlying &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;f (Either e a)&lt;/code&gt;. Compared to &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;f a&lt;/code&gt;, there are actually two levels of wrapping: the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Either e a&lt;/code&gt;, which adds the error channel; and the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;EitherT&lt;/code&gt; structure itself.&lt;/p&gt;

&lt;p&gt;However, languages like Haskell, PureScript, and Scala can (with some care, in the case of Scala) eliminate the cost of the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;EitherT&lt;/code&gt; structure by using &quot;newtypes&quot;. So we’re left with one layer of &lt;em&gt;mandatory&lt;/em&gt; wrapping.&lt;/p&gt;

&lt;p&gt;Monads and monad transformers allow you to build expressions using &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;bind&lt;/code&gt; (AKA &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;flatMap&lt;/code&gt;), whose signature is roughly:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-scala&quot; data-lang=&quot;scala&quot;&gt;&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;bind&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;A&lt;/span&gt;, &lt;span class=&quot;kt&quot;&gt;B&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;](&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;fa&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;F&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;A&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;])(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;A&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;F&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;B&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;])&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;F&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;B&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-haskell&quot; data-lang=&quot;haskell&quot;&gt;&lt;span class=&quot;n&quot;&gt;bind&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;::&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;forall&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;f&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;f&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;f&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Because &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;bind&lt;/code&gt; is used so often for building monadic expressions, it dominates performance overhead.&lt;/p&gt;

&lt;p&gt;An analysis of the type signature of &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;bind&lt;/code&gt; suggests that using &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;EitherT&lt;/code&gt; will necessarily add both wrapping and unwrapping of the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Either&lt;/code&gt; data type, as well as additional function application.&lt;/p&gt;

&lt;p&gt;You can see this clearly in the implementation of &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;bind&lt;/code&gt; / &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;flatMap&lt;/code&gt; for &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;EitherT&lt;/code&gt;:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-scala&quot; data-lang=&quot;scala&quot;&gt;&lt;span class=&quot;k&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;case&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;EitherT&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;F&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;_&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;]&lt;/span&gt;, &lt;span class=&quot;kt&quot;&gt;E&lt;/span&gt;, &lt;span class=&quot;kt&quot;&gt;A&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;](&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;run&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;F&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;Either&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;E&lt;/span&gt;, &lt;span class=&quot;kt&quot;&gt;A&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]])&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;flatMap&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;B&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;](&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;A&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;EitherT&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;F&lt;/span&gt;, &lt;span class=&quot;kt&quot;&gt;E&lt;/span&gt;, &lt;span class=&quot;kt&quot;&gt;B&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;])(&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;implicit&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;F&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Monad&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;F&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;])&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;EitherT&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;F&lt;/span&gt;, &lt;span class=&quot;kt&quot;&gt;E&lt;/span&gt;, &lt;span class=&quot;kt&quot;&gt;B&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;=&lt;/span&gt;
      &lt;span class=&quot;nc&quot;&gt;EitherT&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;run&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;py&quot;&gt;flatMap&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;case&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Left&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;F&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;py&quot;&gt;point&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Left&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;))&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;case&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Right&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;).&lt;/span&gt;&lt;span class=&quot;py&quot;&gt;run&lt;/span&gt;
      &lt;span class=&quot;o&quot;&gt;})&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-haskell&quot; data-lang=&quot;haskell&quot;&gt;&lt;span class=&quot;kr&quot;&gt;instance&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;bindEitherT&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;::&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Monad&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;m&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Bind&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;EitherT&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;e&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;m&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;kr&quot;&gt;where&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;bind&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;EitherT&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;m&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;k&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;EitherT&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;m&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;either&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pure&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Left&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
                          &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;\&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;kr&quot;&gt;case&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;k&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;kr&quot;&gt;of&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;EitherT&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Compared with the raw overhead for &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;bind&lt;/code&gt; / &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;flatMap&lt;/code&gt; on the base monad &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;f&lt;/code&gt;, the implementation for &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;EitherT&lt;/code&gt; adds the following:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Deconstruction of the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Either&lt;/code&gt;.&lt;/li&gt;
  &lt;li&gt;Reconstruction of the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Either&lt;/code&gt;.&lt;/li&gt;
  &lt;li&gt;Construction of at least one additional lambda (even more in the PureScript version).&lt;/li&gt;
  &lt;li&gt;Many additional function applications.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;In an ideal world, this abstraction would be free. In the actual world, it has cost—for PureScript, and especially for Scala.&lt;/p&gt;

&lt;p&gt;The JVM does not perform well with constant allocation of short-lived objects, nor with function application, which has to go through an additional layer of indirection (or several, if type classes are involved).&lt;/p&gt;

&lt;p&gt;If you measure the performance of &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;EitherT&lt;/code&gt; compared to the base monad, you’ll find it’s at least 2x slower, with more than 2x greater heap churn—and this is for one of the simplest monad transformers imaginable, and even when the feature of &lt;em&gt;recoverable errors&lt;/em&gt; is not being used (the overhead of vertical effect composition applies &lt;em&gt;whether or not&lt;/em&gt; the effects are being used; if they’re in the type signature, there’s overhead!).&lt;/p&gt;

&lt;p&gt;In the absolute best case, a stack of 3 monad transformers on top of some base monad &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;f&lt;/code&gt; would be &lt;em&gt;at least&lt;/em&gt; 3 times slower, with &lt;em&gt;at least&lt;/em&gt; 3x greater heap churn, and depending on the transformers involved, could be far worse, perhaps 10x slower.&lt;/p&gt;

&lt;p&gt;Even Haskell fares poorly with deeply nested monad transformers. Haskell’s baseline performance for function application is &lt;em&gt;much&lt;/em&gt; higher, so it can get away with more layers before the performance impact becomes pathological.&lt;/p&gt;

&lt;p&gt;The solution to this problem is to &lt;em&gt;stop vertically stacking effects&lt;/em&gt;, and instead, to &lt;em&gt;rotate them horizontally&lt;/em&gt;.&lt;/p&gt;

&lt;h2 id=&quot;effect-rotation-101&quot;&gt;Effect Rotation 101&lt;/h2&gt;

&lt;p&gt;Effect rotation is a technique whereby &lt;em&gt;vertical effects&lt;/em&gt; are “rotated” to become horizontal.&lt;/p&gt;

&lt;p&gt;Let’s take the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;EitherT&lt;/code&gt; example, and we’ll generalize later.&lt;/p&gt;

&lt;p&gt;Instead of representing our effect as &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;f (Either e a)&lt;/code&gt;, we push the information content of the &lt;em&gt;recoverable errors&lt;/em&gt; effect onto a &lt;em&gt;new type parameter&lt;/em&gt; of &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;f&lt;/code&gt; itself. So our representation of the effect becomes &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;f e a&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;With &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;f e a&lt;/code&gt;, our concrete data type &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;f&lt;/code&gt; can directly provide all the features of &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;EitherT&lt;/code&gt; (the ability to introduce and recover from typed errors), as well as whatever other features are required for the effect.&lt;/p&gt;

&lt;p&gt;It may seem we’ve lost something, though: how do we represent &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;f&lt;/code&gt; values that don’t have errors? Thankfully, Scala and PureScript have uninhabited types (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Nothing&lt;/code&gt; and &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Void&lt;/code&gt;, respectively), so we can still represent &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;f&lt;/code&gt; values without errors, simply as &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;f Void a&lt;/code&gt; (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;F[Nothing, A]&lt;/code&gt;).&lt;/p&gt;

&lt;p&gt;This lets us (quite amazingly!) preserve all the properties that matter:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;strong&gt;Effect Introduction&lt;/strong&gt;. To introduce an error into &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;f Void a&lt;/code&gt;, we can use a function from &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;f Void a&lt;/code&gt; to &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;f e a'&lt;/code&gt; (a “fail” function, for example), thereby introducing the possibility of error into the type.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Effect Elimination&lt;/strong&gt;. To eliminate an error from &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;f e a&lt;/code&gt;, we can use a function from &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;f e a&lt;/code&gt; to &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;f Void a'&lt;/code&gt; (an error handling function, for example), thereby removing the possibility of error from the type.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Information Hiding&lt;/strong&gt;. We can make code polymorphic in one of the type parameters (like &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;e&lt;/code&gt;) so it doesn’t care about its presence or absence, and if we have suitable type classes, we can interact with &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;f&lt;/code&gt; solely through these type classes, hiding the concrete data type from our code and providing maximum polymorphism (even more than monad transformers).&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;By pushing the effect of &lt;em&gt;recoverable errors&lt;/em&gt; into the data type, we enable a “flat” but “wide” data type to provide the feature of the effect with little or no overhead. For example, the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;IO&lt;/code&gt; monad in &lt;a href=&quot;https://github.com/scalaz/scalaz-zio&quot;&gt;ZIO&lt;/a&gt; provides recoverable errors without any performance overhead, and is almost 3x faster than using &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;EitherT&lt;/code&gt; with other effect monads like Cats IO or Monix Task.&lt;/p&gt;

&lt;p&gt;This technique works for more than just &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;EitherT&lt;/code&gt;.&lt;/p&gt;

&lt;h2 id=&quot;generalizing-effect-rotation&quot;&gt;Generalizing Effect Rotation&lt;/h2&gt;

&lt;p&gt;For covariant effects like &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;EitherT&lt;/code&gt;, we can replicate the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;EitherT&lt;/code&gt; example, and add another type parameter, using &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Nothing&lt;/code&gt; (in Scala) or &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Void&lt;/code&gt; (in PureScript) to represent the absence of the covariant effect.&lt;/p&gt;

&lt;p&gt;For contravariant effects like &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Reader&lt;/code&gt; (which represents the effect of accessing context), we can add another type parameter &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;r&lt;/code&gt;, e.g. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;f r e a&lt;/code&gt; (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;F[R, E, A]&lt;/code&gt;), and use either &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Any&lt;/code&gt; (in Scala) or polymorphic &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;r&lt;/code&gt; (in PureScript) to represent the absence of the reader effect (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;forall r. f r e a&lt;/code&gt; / &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;F[Any, E, A]&lt;/code&gt;).&lt;/p&gt;

&lt;p&gt;For invariant effects like &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;State&lt;/code&gt; (which represents the effect of state management), we can add another type parameter &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;s&lt;/code&gt;, e.g. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;f s r e a&lt;/code&gt; (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;F[S, R, E, A]&lt;/code&gt;), and use unit &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Unit&lt;/code&gt; to represent the absence of the state effect (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;f Unit r e a&lt;/code&gt; / &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;F[Unit, R, E, A]&lt;/code&gt;).&lt;/p&gt;

&lt;p&gt;Similarly, if we wanted &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Writer&lt;/code&gt; (which is invariant and represents the effect of persistent logging), we can add yet another type parameter &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;w&lt;/code&gt;, e.g. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;f w s r e a&lt;/code&gt; (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;F[W, S, R, E, A]&lt;/code&gt;), again using unit &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Unit&lt;/code&gt; to represent the absence of the writer effect (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;f Unit s r e a&lt;/code&gt; / &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;F[Unit, S, R, E, A]&lt;/code&gt;).&lt;/p&gt;

&lt;p&gt;Thus all standard effects in functional programming, including recoverable errors, writer, reader, and state, can be rotated, while still preserving our ability to introduce them, eliminate them, and write (effect) polymorphic code.&lt;/p&gt;

&lt;p&gt;Moreover, we can use them in any combination we like. For example, if we want reader and state, but not error or writer, then our type signatures become &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;f Unit s r Void a&lt;/code&gt; / &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;F[Unit, S, R, Nothing, A]&lt;/code&gt;. This is the type of effects that provide state management and context, but don’t provide persistent logging or recoverable errors.&lt;/p&gt;

&lt;p&gt;Provided we’re willing to pay the cost of extra type parameters, we can have modular effects (introducing and eliminating them dynamically) without sacrificing on polymorphism, all without any performance or heap overhead beyond the base effect.&lt;/p&gt;

&lt;p&gt;This is as close as we come to having our cake and eating it too.&lt;/p&gt;

&lt;h2 id=&quot;summary&quot;&gt;Summary&lt;/h2&gt;

&lt;p&gt;Monad transformers rely on vertical composition to achieve modularity of effects. While they provide us the ability to dynamically introduce and eliminate effects (such as &lt;em&gt;recoverable errors&lt;/em&gt;), they introduce massive overhead that renders the technique impractical for most applications.&lt;/p&gt;

&lt;p&gt;Fortunately, we can take all standard effects in functional programming, and rotate them from vertical to horizontal. The technique involves adding new type parameters, baking the features of the effect into the base data type, and based on whether the effect is covariant, contravariant, or invariant, using the appropriate type to indicate the absence of the effect.&lt;/p&gt;

&lt;p&gt;The technique of effect rotation lets us have modular effects without runtime overhead, all for the cost of a few extra characters in our type signatures.&lt;/p&gt;

&lt;p&gt;Now as &lt;a href=&quot;https://twitter.com/snoyberg&quot;&gt;Michael Snoyman&lt;/a&gt; and others have discovered, not all functional programming effects are equal. Even if you need writer, state, reader, and recoverable errors, that doesn’t mean you need 5 type parameters, because some of these effects are powerful enough to express the others.&lt;/p&gt;

&lt;p&gt;In a later post, I’ll discuss a minimum basis to provide all standard effects in functional programming.&lt;/p&gt;

  &lt;p&gt;&lt;a href=&quot;https://degoes.net/articles/rotating-effects&quot;&gt;High-Performance Functional Programming Through Effect Rotation&lt;/a&gt; was originally published by John A De Goes at &lt;a href=&quot;https://degoes.net&quot;&gt;John <em>A</em> <strong>De Goes</strong>&lt;/a&gt; on January 09, 2019.&lt;/p&gt;</content>
</entry>


<entry>
  <title type="html"><![CDATA[Using ZIO with Tagless-Final]]></title>
  <link rel="alternate" type="text/html" href="https://degoes.net/articles/polymorphic-bifunctors" />
  <id>https://degoes.net/articles/polymorphic-bifunctors</id>
  <published>2018-08-07T00:00:00-06:00</published>
  <updated>2018-08-07T00:00:00-06:00</updated>
  <author>
    <name>John A De Goes</name>
    <uri>https://degoes.net</uri>
    <email>john@degoes.net</email>
  </author>
  <content type="html">&lt;p&gt;Since launching &lt;a href=&quot;https://github.com/scalaz/scalaz-zio/&quot;&gt;ZIO&lt;/a&gt; a few months ago (formerly known as the &lt;em&gt;Scalaz 8 IO monad&lt;/em&gt;), one of the most common questions I get is how to use its &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;IO&lt;/code&gt; type with &lt;a href=&quot;https://blog.scalac.io/exploring-tagless-final.html&quot;&gt;&lt;em&gt;tagless-final&lt;/em&gt;&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;In this post, I’ll explain how ZIO works with tagless-final, and when it makes sense to modify your type classes to take advantage of the new power provided by ZIO for modeling typed errors.&lt;/p&gt;

&lt;h2 id=&quot;zio-vs-other-effect-types&quot;&gt;ZIO vs Other Effect Types&lt;/h2&gt;

&lt;p&gt;In ZIO, a value of type &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;IO[E, A]&lt;/code&gt; is an immutable value that describes an effectful program. The program may fail with some error of type &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;E&lt;/code&gt;, or produce a value of type &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;A&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;As I’ve &lt;a href=&quot;https://degoes.net/articles/fpoop-vs-fp&quot;&gt;previously argued&lt;/a&gt;, this purely functional model has many practical benefits that make it &lt;a href=&quot;https://degoes.net/articles/fpoop-vs-fp&quot;&gt;extremely attractive&lt;/a&gt;, even for developers who don’t care about functional programming.&lt;/p&gt;

&lt;p&gt;Other popular Scala libraries like &lt;a href=&quot;https://github.com/monix/monix&quot;&gt;Monix&lt;/a&gt; also have effect types, but ZIO is the only one that provides &lt;a href=&quot;https://degoes.net/articles/bifunctor-io&quot;&gt;typed errors&lt;/a&gt;. The other effect types fix the error type to &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Throwable&lt;/code&gt;, which means it is not possible to constrain if and how effects may fail at compile-time, leading to bugs and poor reasoning properties.&lt;/p&gt;

&lt;p&gt;This difference in power means that the &lt;em&gt;kinds&lt;/em&gt; of &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;IO&lt;/code&gt; and other effect types differ:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;ZIO’s effect type has kind &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;(*, *) -&amp;gt; *&lt;/code&gt;, which means that the type constructor for &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;IO&lt;/code&gt; takes two type parameters: the type of errors, and the type of values.&lt;/li&gt;
  &lt;li&gt;Other effect types have kind &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;* -&amp;gt; *&lt;/code&gt;, which means their type constructors take one type parameter: the type of values.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Ordinarily, you don’t notice this difference, because ZIO is designed to have excellent type inference. Scala figures out the type parameters for both &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;E&lt;/code&gt; and &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;A&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;There’s one place, however, where you have to think more carefully about the difference between ZIO and older effect types: the tagless-final encoding of effects.&lt;/p&gt;

&lt;h2 id=&quot;tagless-final&quot;&gt;Tagless-Final&lt;/h2&gt;

&lt;p&gt;In the tagless-final pattern, you describe your effects using a type class, which typically takes a single type constructor &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;F[_]&lt;/code&gt; (with kind &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;* -&amp;gt; *&lt;/code&gt;). For example, we might have a type class that describes the effect of logging:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-scala&quot; data-lang=&quot;scala&quot;&gt;&lt;span class=&quot;k&quot;&gt;trait&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Logging&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;F&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;_&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;]]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;message&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;F&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;Unit&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;As demonstrated in a &lt;a href=&quot;https://www.youtube.com/watch?v=sxudIMiOo68&amp;amp;t=53s%C2%A0&amp;amp;app=desktop&quot;&gt;recent live-coding talk&lt;/a&gt; I did for &lt;em&gt;Fun(c)tional Programming Group&lt;/em&gt;, using effect type classes like these has several benefits:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;It allows us to see what effects functions use, so we can better understand our functions without having to drill down into their implementations, and find all the functions they call (which is error-prone and takes lots of time);&lt;/li&gt;
  &lt;li&gt;It allows us to reuse more code. For example, we can have different instances of the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Logging&lt;/code&gt; type class for different production environments. One can log remotely, one can log locally, and one can not log at all.&lt;/li&gt;
  &lt;li&gt;It allows us to easily mock effectful code without having to interact with the real world (so our tests can be fast and deterministic) and without having to rely on painful mocking libraries.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Yet because ZIO’s effect type takes two type parameters, and traditionally, in tagless-final, our effects only take one type parameter, many developers have had the question: how can we use ZIO with tagless-final?&lt;/p&gt;

&lt;p&gt;In the sections that follow, I’ll explore the two ways to use ZIO with tagless-final, and then give you some guidance on how to choose the best method for every situation.&lt;/p&gt;

&lt;h2 id=&quot;fixing-the-error-type&quot;&gt;Fixing the Error Type&lt;/h2&gt;

&lt;p&gt;Although we cannot make &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;IO&lt;/code&gt; implement a type class like &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Logging&lt;/code&gt; directly, because it has the wrong kind, if we partially apply &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;IO&lt;/code&gt; to its first type parameter (that is, if we &lt;em&gt;fix&lt;/em&gt; the error type), then we can create an instance for the partially applied type constructor.&lt;/p&gt;

&lt;p&gt;In the following example, I assume we have a function &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;def logIo(message: String): IO[Nothing, Unit]&lt;/code&gt;, which I use to implement the type class for any fixed error type &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;E&lt;/code&gt;:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-scala&quot; data-lang=&quot;scala&quot;&gt;&lt;span class=&quot;c1&quot;&gt;// NOTE: Uses the kind-projector compiler-plugin for
// easier syntax for partial type application:
&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;implicit&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;IOLogging&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;E&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Logging&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;IO&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;E&lt;/span&gt;, &lt;span class=&quot;kt&quot;&gt;?&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]]&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;=&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Logging&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;IO&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;E&lt;/span&gt;, &lt;span class=&quot;kt&quot;&gt;?&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;message&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;IO&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;E&lt;/span&gt;, &lt;span class=&quot;kt&quot;&gt;Unit&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;logIo&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;message&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;With this approach, we may now use the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Logging&lt;/code&gt; type class with the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;IO&lt;/code&gt; type. Let’s say we have some function &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;processData&lt;/code&gt; that requires logging:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-scala&quot; data-lang=&quot;scala&quot;&gt;&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;processData&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;F&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;_&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Logging:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Monad&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;F&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;Unit&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;=&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;???&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Then now we can call &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;processData&lt;/code&gt; with &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;IO[E, ?]&lt;/code&gt; for any error type &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;E&lt;/code&gt;, because our implicit function &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;IOLogging&lt;/code&gt; defines an entire &lt;em&gt;family&lt;/em&gt; of &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Logging&lt;/code&gt; instances across all type parameters &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;E&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Sometimes, we can’t provide instances for all error types. For example, if our logging function &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;logIo&lt;/code&gt; can throw &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;IOException&lt;/code&gt;, then we have to constrain the error type in our instance for the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;IO&lt;/code&gt; data type:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-scala&quot; data-lang=&quot;scala&quot;&gt;&lt;span class=&quot;k&quot;&gt;implicit&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;IOLogging&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Logging&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;IO&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;IOException&lt;/span&gt;, &lt;span class=&quot;kt&quot;&gt;?&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]]&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;=&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Logging&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;IO&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;IOException&lt;/span&gt;, &lt;span class=&quot;kt&quot;&gt;?&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;message&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;IO&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;IOException&lt;/span&gt;, &lt;span class=&quot;kt&quot;&gt;Unit&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;=&lt;/span&gt;
      &lt;span class=&quot;nf&quot;&gt;logIo&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;message&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;In this case, because we needed the ability to fail, we had to restrict the instance to a specific error type. This means we can no longer use &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Logging&lt;/code&gt; for just &lt;em&gt;any&lt;/em&gt; &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;IO&lt;/code&gt; type; it has to be one that can fail with an &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;IOException&lt;/code&gt; (or a supertype, like &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Exception&lt;/code&gt; or &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Throwable&lt;/code&gt;).&lt;/p&gt;

&lt;p&gt;In both cases, we were able to use the same type class we would use for other effect types. We didn’t need to change a thing.&lt;/p&gt;

&lt;h2 id=&quot;varying-the-error-type&quot;&gt;Varying the Error Type&lt;/h2&gt;

&lt;p&gt;The alternative to fixing error types is to let them vary, which requires that we change our tagless-final encoding.&lt;/p&gt;

&lt;p&gt;Let’s say we have the following type class, which allows us to execute some query locally or in a distributed fashion:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-scala&quot; data-lang=&quot;scala&quot;&gt;&lt;span class=&quot;k&quot;&gt;trait&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Analytics&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;F&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;_&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;]]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;local&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;query&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Query&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;A&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;])&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;F&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;A&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt;

  &lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;distributed&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;query&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Query&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;A&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;])&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;F&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;A&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Let’s say the local execution cannot fail, but the distributed execution can fail due to network errors. In this case, we would like to capture the distinction between these methods, so developers know by looking at the types what can happen.&lt;/p&gt;

&lt;p&gt;To do this, we could always use an &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Either&lt;/code&gt;, but since the capability is baked into ZIO, there’s no need to add additional runtime and cognitive overhead. Instead, we can just change the kind of our effect parameter from &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;* -&amp;gt; *&lt;/code&gt; to &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;(*, *) -&amp;gt; *&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;This lets us vary the error type for each method:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-scala&quot; data-lang=&quot;scala&quot;&gt;&lt;span class=&quot;k&quot;&gt;trait&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Analytics&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;F&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;_&lt;/span&gt;,&lt;span class=&quot;k&quot;&gt;_&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;local&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;query&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Query&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;A&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;])&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;F&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;Nothing&lt;/span&gt;, &lt;span class=&quot;kt&quot;&gt;A&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt;

  &lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;distributed&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;query&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Query&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;A&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;])&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;F&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;NetworkError&lt;/span&gt;, &lt;span class=&quot;kt&quot;&gt;A&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Now we can clearly see that &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;local&lt;/code&gt; queries cannot fail, but &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;distributed&lt;/code&gt; queries can fail due to network errors.&lt;/p&gt;

&lt;p&gt;This type class does not limit us to ZIO, either. For the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Task&lt;/code&gt; type in Monix, for example, while we cannot create an instance of &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Analytics&lt;/code&gt; for &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Task&lt;/code&gt; directly, we can create an instance for &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;EitherT[Task, ?, ?]&lt;/code&gt; (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;EitherT&lt;/code&gt; is a monad transformer that adds typed errors to a base monad).&lt;/p&gt;

&lt;p&gt;This means that when you parameterize your type classes over effects that take two type parameters, developers can choose whether to use ZIO or to use another effect monad and layer on typed errors with the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;EitherT&lt;/code&gt; monad transformer.&lt;/p&gt;

&lt;h2 id=&quot;choices-choices&quot;&gt;Choices, Choices&lt;/h2&gt;

&lt;p&gt;The choice about whether to use tagless-final with &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;F[_]&lt;/code&gt; or &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;F[_, _]&lt;/code&gt; is pretty straightforward:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;If the effects of your type class cannot fail, or can fail with only a single type of error across all methods, then you should parameterize your type classes with &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;F[_]&lt;/code&gt;. You can easily provide instances of this type for ZIO and other effect monads. No changes are required.&lt;/li&gt;
  &lt;li&gt;If the effects of your type class can fail in different ways, then you should parameterize your type classes with &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;F[_, _]&lt;/code&gt;, so you can precisely capture the different failure modes in the type class. You can easily provide instances of this type for ZIO. For other effect monads like &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Task&lt;/code&gt;, you can provide instances for &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;EitherT[Task, ?, ?]&lt;/code&gt;.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;It’s easy to combine the two styles in one code base. For example, a data processing function that requires &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;F[_, _]: Analytics&lt;/code&gt; can call a logging function that requires &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;F[_]: Logging&lt;/code&gt; by simply requiring &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;L: Logging[F[IOException, ?]]&lt;/code&gt;.&lt;/p&gt;

&lt;h2 id=&quot;summary&quot;&gt;Summary&lt;/h2&gt;

&lt;p&gt;In this post, we’ve seen that the effect type in ZIO allows us to precisely model if and how computations may fail. We’ve also seen that because of this power, the kind of ZIO’s &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;IO&lt;/code&gt; type differs from the kind of other effect types—it takes two type parameters, rather than one.&lt;/p&gt;

&lt;p&gt;Because of this difference, many developers wonder how to use ZIO with tagless-final. Fortunately, using tagless-final with ZIO is trivial. As long as all methods produce the same error type (or no error at all), then there’s no need to make any changes to the type classes.&lt;/p&gt;

&lt;p&gt;In some cases, if we want our type classes to describe effects that can fail in different ways, we are able to improve on classic tagless-final by varying the error type. In this case, our type classes become parameterized over &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;F[_, _]&lt;/code&gt;, allowing each method to specify its own error type. We can support other effect types by writing instances for &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;EitherT&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;In summary, ZIO is not only compatible with tagless-final, but also lets us take tagless-final to the next level of compile-time precision, while still preserving full compatibility with older dynamically-typed effect monads.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;If you like this blog post, don’t miss John A. De Goes’ &lt;a href=&quot;https://www.eventbrite.com/e/functional-scala-by-john-a-de-goes-tickets-48461417404&quot;&gt;upcoming 5 day training&lt;/a&gt; in Functional Scala, held remotely or on-site in the Scottish highlands.&lt;/em&gt;&lt;/p&gt;

  &lt;p&gt;&lt;a href=&quot;https://degoes.net/articles/polymorphic-bifunctors&quot;&gt;Using ZIO with Tagless-Final&lt;/a&gt; was originally published by John A De Goes at &lt;a href=&quot;https://degoes.net&quot;&gt;John <em>A</em> <strong>De Goes</strong>&lt;/a&gt; on August 07, 2018.&lt;/p&gt;</content>
</entry>


<entry>
  <title type="html"><![CDATA[Data Modeling in FP vs OOP]]></title>
  <link rel="alternate" type="text/html" href="https://degoes.net/articles/fp-vs-oop-part1" />
  <id>https://degoes.net/articles/fp-vs-oop-part1</id>
  <published>2018-08-07T00:00:00-06:00</published>
  <updated>2018-08-07T00:00:00-06:00</updated>
  <author>
    <name>John A De Goes</name>
    <uri>https://degoes.net</uri>
    <email>john@degoes.net</email>
  </author>
  <content type="html">&lt;p&gt;At &lt;a href=&quot;https://scalapeno2018.com/&quot;&gt;Scalapeño&lt;/a&gt; this year, I &lt;a href=&quot;https://www.youtube.com/watch?v=v8IQ-X2HkGE&quot;&gt;argued in my keynote&lt;/a&gt; that the best and most unique parts of Scala are the ones suited to functional programming—including traits (when used for type classes, modules, and sum types), case classes (when used for product types), higher-kinded types, dot method syntax (which is useful for method chaining and namespacing), and various features of Scala’s type system.&lt;/p&gt;

&lt;p&gt;In the &lt;a href=&quot;https://twitter.com/jdegoes&quot;&gt;Twitter&lt;/a&gt; aftermath that followed, I further argued that object-oriented programming—by which I mean inheritance hierarchies (typified by the Scala collections inheritance hierarchy) and subtyping (beyond its use for modeling sum types, modules, and type classes)—isn’t useful. That is, it doesn’t have any real world practical benefits over functional programming.&lt;/p&gt;

&lt;p&gt;Some &lt;a href=&quot;https://twitter.com/adriaanm/status/1017054795214020609&quot;&gt;claimed&lt;/a&gt; without supporting evidence that Scala’s embrace of object-oriented programming helps working programmers solve real problems. To settle the issue once and for all (at least for some people), I issued the following public challenge:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/fp-vs-oop-challenge.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;In a world of millions of object-oriented programmers, I received a grand total of 3 responses (!).&lt;/p&gt;

&lt;p&gt;In this blog post, I’ll look at one of the responses, and show how you can solve the same problem using standard techniques from functional programming. Then every reader can decide for themselves whether OOP adds anything of value to what I have defined as the &lt;em&gt;good parts&lt;/em&gt; of the Scala programming language.&lt;/p&gt;

&lt;h2 id=&quot;data-modeling&quot;&gt;Data Modeling&lt;/h2&gt;

&lt;p&gt;The first response to my challenge was a problem in &lt;a href=&quot;https://gist.github.com/huntc/65dafc5b737d4cc1fe0492d52379c2e3&quot;&gt;data modeling&lt;/a&gt; by &lt;a href=&quot;https://twitter.com/huntchr&quot;&gt;Christopher Hunt&lt;/a&gt;, a veteran of Lightbend:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-scala&quot; data-lang=&quot;scala&quot;&gt;&lt;span class=&quot;k&quot;&gt;sealed&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;abstract&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Event&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;id&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Int&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;case&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;CountersUpdated&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;override&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;id&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Int&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;counter&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Option&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;Int&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;])&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;extends&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Event&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;id&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;case&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;DeviceIdUpdated&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;override&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;id&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Int&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;deviceId&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Int&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;extends&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Event&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;id&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;This example uses inheritance not for type classes, modules, or sum type emulation, but to provide the following benefits:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;The compile-time guarantee that every event has an &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;id&lt;/code&gt; of type &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Int&lt;/code&gt;, which means the same thing across every event.&lt;/li&gt;
  &lt;li&gt;The flexibility for each event to have its own custom payload (for example, one has a &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;counter: Option[Int]&lt;/code&gt;, and another has a &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;deviceId: Int&lt;/code&gt;).&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Let’s take a look at how functional programming can provide us with these same benefits, without the use of inheritance.&lt;/p&gt;

&lt;h2 id=&quot;naive-solution&quot;&gt;Naive Solution&lt;/h2&gt;

&lt;p&gt;In functional programming, we might choose to naively model this problem with a single sum type:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-haskell&quot; data-lang=&quot;haskell&quot;&gt;&lt;span class=&quot;kr&quot;&gt;data&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Event&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;CountersUpdated&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Int&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;Maybe&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;DeviceIdUpdated&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Int&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Int&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-scala&quot; data-lang=&quot;scala&quot;&gt;&lt;span class=&quot;c1&quot;&gt;// In Scala 2.x:
&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;sealed&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;trait&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Event&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;case&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;CountersUpdated&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;id&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Int&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;counter&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Option&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;Int&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;])&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;extends&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Event&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;case&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;DeviceIdUpdated&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;id&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Int&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;deviceId&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Int&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;extends&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Event&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;// In Scala 3.x:
&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;enum&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Event&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;case&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;CountersUpdated&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;id&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Int&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;counter&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Option&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;Int&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;])&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;case&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;DeviceIdUpdated&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;id&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Int&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;deviceId&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Int&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;While this approach provides us with the ability to vary the payload for each type of event, we don’t have the compile time guarantee that each type of event has an event id.&lt;/p&gt;

&lt;p&gt;We could regain this guarantee with classy lenses, but we don’t need anything as fancy as that: we just need to take advantage of the full power of algebraic data types to remove the duplication in our current data model.&lt;/p&gt;

&lt;h2 id=&quot;idiomatic-solution&quot;&gt;Idiomatic Solution&lt;/h2&gt;

&lt;p&gt;In any case where we have a sum type, whose terms share a common piece of data, we can apply a refactoring: we can extract a new product type with the common data, and push the sum type deeper as another term of that product.&lt;/p&gt;

&lt;p&gt;In this case, our event id is the common piece of data, so we can extract a product type that includes both the id and a new sum type that captures differences between different events:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-haskell&quot; data-lang=&quot;haskell&quot;&gt;&lt;span class=&quot;kr&quot;&gt;data&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Event&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Event&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Int&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Payload&lt;/span&gt;
&lt;span class=&quot;kr&quot;&gt;data&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Payload&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;CountersUpdated&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;Maybe&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;DeviceIdUpdated&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Int&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-scala&quot; data-lang=&quot;scala&quot;&gt;&lt;span class=&quot;c1&quot;&gt;// In Scala 2.x:
&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;case&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Event&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;id&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Int&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;payload&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Payload&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;sealed&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;trait&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Payload&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;case&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;CountersUpdated&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;counter&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Option&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;Int&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;])&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;extends&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Payload&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;case&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;DeviceIdUpdated&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;deviceId&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Int&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;extends&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Payload&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;// In Scala 3.x:
&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;case&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Event&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;id&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Int&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;payload&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Payload&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;enum&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Payload&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;case&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;CountersUpdated&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;counter&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Option&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;Int&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;])&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;case&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;DeviceIdUpdated&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;deviceId&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Int&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;This simple refactoring now lets us not just vary the payload depending on the type of event, but also lets us have a compile-time guarantee that all events share common data.&lt;/p&gt;

&lt;p&gt;Compared with the object-oriented solution, the new data model is the same size (smaller in Scala 3.x!), has all the benefits of the object-oriented solution, and does not conflate &lt;em&gt;abstraction&lt;/em&gt; (the capability to extract an id from a type) with the data model.&lt;/p&gt;

&lt;p&gt;The new data model is squeaky clean, contains no logic (which is better reserved for type classes, because it’s far more flexible), and precisely models the problem domain!&lt;/p&gt;

&lt;p&gt;While developers can argue which approach they prefer, it’s clear the object-oriented solution has no benefits over the functional programming solution.&lt;/p&gt;

&lt;h2 id=&quot;summary&quot;&gt;Summary&lt;/h2&gt;

&lt;p&gt;In this post, I showed how functional programming compares to object-oriented programming. Rather than use a contrived example that might skew the results in favor of functional programming, I took my example from proponents of OOP.&lt;/p&gt;

&lt;p&gt;Stay tuned for other posts in this series, where I look at other challenges problems. And if you have some small, self-contained example, and wonder how to do the same thing in functional programming, please post it in the comments below!&lt;/p&gt;

  &lt;p&gt;&lt;a href=&quot;https://degoes.net/articles/fp-vs-oop-part1&quot;&gt;Data Modeling in FP vs OOP&lt;/a&gt; was originally published by John A De Goes at &lt;a href=&quot;https://degoes.net&quot;&gt;John <em>A</em> <strong>De Goes</strong>&lt;/a&gt; on August 07, 2018.&lt;/p&gt;</content>
</entry>


<entry>
  <title type="html"><![CDATA[Scala Wars: FP-OOP vs FP]]></title>
  <link rel="alternate" type="text/html" href="https://degoes.net/articles/fpoop-vs-fp" />
  <id>https://degoes.net/articles/fpoop-vs-fp</id>
  <published>2018-07-14T00:00:00-06:00</published>
  <updated>2018-07-14T00:00:00-06:00</updated>
  <author>
    <name>John A De Goes</name>
    <uri>https://degoes.net</uri>
    <email>john@degoes.net</email>
  </author>
  <content type="html">&lt;p&gt;I’m one of those crazy functional programming zealots and the architect of &lt;a href=&quot;https://github.com/scalaz/scalaz-zio&quot;&gt;ZIO&lt;/a&gt;, a purely-functional effect system for Scala.&lt;/p&gt;

&lt;p&gt;I use the purely-functional &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;IO&lt;/code&gt; in Scala to model &lt;em&gt;all&lt;/em&gt; my effects—not out of any ideological commitment to functional programming, but because it makes my life easier and makes my programs faster, clearer and better.&lt;/p&gt;

&lt;p&gt;In general, we functional programmers prefer to use &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;IO&lt;/code&gt; in Scala for all of the following reasons:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;strong&gt;Uniform Reasoning&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Uniform Purity&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Reified Programs&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Performance &amp;amp; Power&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Flexibility&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Industry Proven&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;In the sections that follow, I’ll explain each of these reasons.&lt;/p&gt;

&lt;h3 id=&quot;uniform-reasoning&quot;&gt;Uniform Reasoning&lt;/h3&gt;

&lt;p&gt;When you use immutable data structures like Scala’s collections, or when you rely on pattern matching and recursion to manipulate your own immutable data structures, you are able to rely on very powerful reasoning properties of functional code:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;strong&gt;Equational Reasoning&lt;/strong&gt;. When you see an expression like &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;list ++ list&lt;/code&gt;, you know the meaning of this expression by inlining the value of &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;list&lt;/code&gt;, and simplifying. More generally, in any functional code, you always know what an expression means through substitution and simplification. This makes it easier to understand what your programs do, and lets you refactor safely, without worrying that you’re changing the behavior of your programs.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Type-Directed Reasoning&lt;/strong&gt;. When you see a type like &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;List[A] =&amp;gt; (A =&amp;gt; B) =&amp;gt; List[B]&lt;/code&gt; in functional code, you have some idea of what this function can and cannot do, merely by looking at the type. In Java, a method like &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;(InetAddress, InetAddress) =&amp;gt; Boolean&lt;/code&gt; could perform network IO (and in fact, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;equals&lt;/code&gt; on &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;InetAddress&lt;/code&gt; does just this!), which means you need to thoroughly study implementations to understand what functions do.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Inversion of Control&lt;/strong&gt;. As a consequence of (1), when you see a functional expression like &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;list.map(f)&lt;/code&gt;, you know that the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;map&lt;/code&gt; method cannot modify the original &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;list&lt;/code&gt;. In functional code, the callee cannot change or do anything (only the caller), which means you don’t have to program defensively and you can push decisions higher in your code base, resulting in more flexible programs with less wiring.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Local Reasoning&lt;/strong&gt;. As a consequence of (1) and (2), it becomes possible to reason about quite a lot of code locally. Global understanding of the entire program is not necessary to verify local correctness, so it becomes faster and easier to make safe changes to the code.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;These reasoning properties only hold for functional code. You have to use different reasoning properties for non-functional code, which involve examining the implementation of methods (to see what they do, since the types don’t tell you!) and simulating their stateful execution in your head.&lt;/p&gt;

&lt;p&gt;Human brains aren’t particularly good at computation, and so many of us don’t like to study lots of code and simulate stateful execution in our heads just to make a small change.&lt;/p&gt;

&lt;p&gt;If you mix functional code and non-functional code, then you have to constantly change the way you reason about the code, depending on whether you are in a functional section, or a non-functional section. The process of constantly switching how you reason about the code is mentally exhausting and error-prone.&lt;/p&gt;

&lt;p&gt;Contrast this with &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;IO&lt;/code&gt;, which is just an ordinary immutable value, exactly like &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;List&lt;/code&gt;. All methods on &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;IO&lt;/code&gt; return new &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;IO&lt;/code&gt; values derived from the original. Because &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;IO&lt;/code&gt; is an immutable data structure, you can model effects while still benefiting from all the reasoning properties of functional code.&lt;/p&gt;

&lt;p&gt;The functional approach gives you a powerful tools to understand and safely change your code, and it eliminates the need to switch back and forth between functional and non-functional reasoning.&lt;/p&gt;

&lt;h3 id=&quot;uniform-purity&quot;&gt;Uniform Purity&lt;/h3&gt;

&lt;p&gt;It’s well-known that functional code mixes poorly with non-functional code. For example, if you’re using a functional data structure like &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Stream&lt;/code&gt;, and you map over the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Stream&lt;/code&gt;, it doesn’t actually do anything. If you place a &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;println&lt;/code&gt; in the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;map&lt;/code&gt; function, you’re not going to see anything.&lt;/p&gt;

&lt;p&gt;It’s not obvious from the types alone where you can insert side-effects in higher-order functional code, and have them do what you want them to do, when you want them to do it.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;IO&lt;/code&gt; lets you use effects anywhere and gives you the tools to reason about them at compile-time. If you map over a &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Stream[A]&lt;/code&gt; and convert each &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;A&lt;/code&gt; to &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;IO[B]&lt;/code&gt;, then you end up with a &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Stream[IO[B]]&lt;/code&gt;. This type tells you it’s now a stream of effects. In order to do anything, you have to pull those effects out and combine them together. One way to do that is to call &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;IO.sequence&lt;/code&gt;, which transforms &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Stream[IO[B]]&lt;/code&gt; into &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;IO[Stream[B]]&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;There are other ways, but no matter how you choose to transform the stream of effects into an effect, the types tell you what you must do in order to compose the effect together with the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;IO&lt;/code&gt; of your main program. You can’t do something that doesn’t make sense, because the compiler won’t let you.&lt;/p&gt;

&lt;p&gt;With &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;IO&lt;/code&gt;, you never have to worry mixing pure and impure code, because everything is uniformly pure.&lt;/p&gt;

&lt;h3 id=&quot;reified-programs&quot;&gt;Reified Programs&lt;/h3&gt;

&lt;p&gt;In languages like Scala, procedural programs are not first-class citizens. You can’t pass a bunch of statements around from one function to another. You can’t store them inside data structures. You can’t combine them in an expression-oriented way.&lt;/p&gt;

&lt;p&gt;Sometimes this limitation cripples the functionality of your programs. For example, an undo/redo manager requires the ability to model effects as values, so you can store them in a stack; user-interfaces are usefully modeled as infinite trees, where different user actions correspond to different paths down the tree; and so on.&lt;/p&gt;

&lt;p&gt;Other times, the lack of first-class programs means poor expressivity. Expressions, like &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;1 + 2 * 2&lt;/code&gt;, provide enormous power in a compact package, allowing us to easily build larger expressions from smaller ones. Yet, because procedural statements are not first-class values, we don’t have this same power with our programs.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;IO&lt;/code&gt; cleanly solves these issues by turning our programs into first-class values. We can pass these values around, we can store them in data structures, and we can combine them in an expression-oriented way to yield other programs.&lt;/p&gt;

&lt;p&gt;I’ll show you a few examples with &lt;a href=&quot;https://github.com/scalaz/scalaz-zio&quot;&gt;ZIO&lt;/a&gt; to demonstrate the power of this approach.&lt;/p&gt;

&lt;p&gt;Suppose we want to define a combinator which retries a program until it succeeds:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-scala&quot; data-lang=&quot;scala&quot;&gt;&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;retry&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;E&lt;/span&gt;, &lt;span class=&quot;kt&quot;&gt;A&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;](&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;io&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;IO&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;E&lt;/span&gt;, &lt;span class=&quot;kt&quot;&gt;A&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;])&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;IO&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;E&lt;/span&gt;, &lt;span class=&quot;kt&quot;&gt;A&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;io&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;orElse&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;retry&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;io&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Or suppose we want to define a combinator to run an action forever:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-scala&quot; data-lang=&quot;scala&quot;&gt;&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;forever&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;E&lt;/span&gt;, &lt;span class=&quot;kt&quot;&gt;A&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;](&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;io&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;IO&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;E&lt;/span&gt;, &lt;span class=&quot;kt&quot;&gt;A&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;])&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;IO&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;E&lt;/span&gt;, &lt;span class=&quot;kt&quot;&gt;Nothing&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;=&lt;/span&gt;
  &lt;span class=&quot;nv&quot;&gt;io&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;py&quot;&gt;flatMap&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;_&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;forever&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;io&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;))&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Or suppose we want to continuously take values from a queue and upload them to S3 (logging failures), in a separate thread:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-scala&quot; data-lang=&quot;scala&quot;&gt;&lt;span class=&quot;nv&quot;&gt;queue&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;py&quot;&gt;take&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;py&quot;&gt;flatMap&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;uploadToS3&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;orElse&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;logFailure&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;).&lt;/span&gt;&lt;span class=&quot;py&quot;&gt;forever&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;py&quot;&gt;fork&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Or suppose we want to spin up 1000 threads to load test a web server, adding a random delay before each worker starts, and timing out the whole load test after 60 seconds, cleanly shutting down each worker:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-scala&quot; data-lang=&quot;scala&quot;&gt;&lt;span class=&quot;nv&quot;&gt;IO&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;py&quot;&gt;parAll&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;List&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;py&quot;&gt;fill&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1000&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)(&lt;/span&gt;
  &lt;span class=&quot;nv&quot;&gt;randomTime&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;py&quot;&gt;flatMap&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;IO&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;py&quot;&gt;sleep&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;).&lt;/span&gt;
    &lt;span class=&quot;nf&quot;&gt;flatMap&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;_&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;=&amp;gt;&lt;/span&gt;  &lt;span class=&quot;n&quot;&gt;doLoadTest&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;))).&lt;/span&gt;&lt;span class=&quot;py&quot;&gt;timeout&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mf&quot;&gt;60.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;seconds&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Because we can define and use combinators on our programs, we can solve very complex problems with very little code. These solutions don’t have distracting clutter or irrelevant details; their structure cleanly reflects their intended semantics.&lt;/p&gt;

&lt;h3 id=&quot;performance--power&quot;&gt;Performance &amp;amp; Power&lt;/h3&gt;

&lt;p&gt;The final very attractive property of an effect monad like &lt;a href=&quot;https://github.com/scalaz/scalaz-zio&quot;&gt;ZIO&lt;/a&gt; (and similar ones like Monix &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Task&lt;/code&gt;) is that it can provide us with a level of performance and power that cannot be obtained elsewhere.&lt;/p&gt;

&lt;p&gt;For example, in a &lt;a href=&quot;https://github.com/scalaz/scalaz-zio/tree/master/benchmarks/src/main/scala/scalaz/zio&quot;&gt;variety of benchmarks&lt;/a&gt;, ZIO is 100x or more faster than Scala’s own &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Future&lt;/code&gt;. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Future&lt;/code&gt; is not functional code, and it has all the drawbacks of dysfunctional code, including a different reasoning model and poor interop with pure code.&lt;/p&gt;

&lt;p&gt;That’s not all, though. Programs written using ZIO can be maximally “lazy”, without effort, thanks to a feature of ZIO called &lt;em&gt;interruption&lt;/em&gt;. &lt;em&gt;Interruption&lt;/em&gt; allows the runtime system for ZIO to interrupt any “thread” immediately and safely release resources.&lt;/p&gt;

&lt;p&gt;This happens automatically in many places. For example, if a web response depends on some key piece of information that’s not available, then all the other computations running in parallel will be gracefully shut down, reducing latency, network bandwidth, and CPU overhead. Similarly, if you race a bunch of computations, then as soon as one of them succeeds, the others will be terminated immediately.&lt;/p&gt;

&lt;p&gt;ZIO models both synchronous and asynchronous effects in a uniform way. An &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;IO[A]&lt;/code&gt; represents an arbitrary composition of both synchronous and asynchronous effects. But as a user, you don’t have to care about this. If you don’t use &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;IO&lt;/code&gt;, then you need to structure your code quite differently, as a combination of both statements and callbacks—every bit of code is painfully aware of whether it’s synchronous or asynchronous.&lt;/p&gt;

&lt;p&gt;ZIO gives you other superpowers, too:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Concurrency using &lt;em&gt;fibers&lt;/em&gt; instead of threads, which are a user-land implementation of green threads, so you can have hundreds of thousands of them running at a time.&lt;/li&gt;
  &lt;li&gt;A &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;try&lt;/code&gt; / &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;finally&lt;/code&gt; construct called &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;bracket&lt;/code&gt;, which lets you perform resource acquisition and release safely, even across asynchronous boundaries, and even in the presence of interruption or catastrophic errors.&lt;/li&gt;
  &lt;li&gt;The ability to supervise child fibers spawned by a parent, so you can take action if they crash.&lt;/li&gt;
  &lt;li&gt;The ability to automatically terminate child fibers when the parent fiber finishes.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;All of these capabilities rely on the functional nature of ZIO. Because &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;IO&lt;/code&gt; is just an ordinary immutable value, your main function needs to call the runtime system to interpret the effectful program modeled by the data structure. This separate interpretation process allows the runtime to add very powerful features that you can’t get from a non-functional approach.&lt;/p&gt;

&lt;p&gt;Even if you &lt;em&gt;hate&lt;/em&gt; functional programming, the benefits of purely functional programming are so compelling, you might be tempted to use a full-featured &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;IO&lt;/code&gt; type anyway!&lt;/p&gt;

&lt;h3 id=&quot;flexibility&quot;&gt;Flexibility&lt;/h3&gt;

&lt;p&gt;Although I have mentioned using &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;IO&lt;/code&gt; data types, and you’ll hear functional programmers talk about writing &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;IO&lt;/code&gt; programs, it’s more common these days to define type classes to abstract over fine-grained effects, and to make programs polymorphic in the effect type, so long as they provide the required capabilities.&lt;/p&gt;

&lt;p&gt;This pattern, sometimes called &lt;em&gt;final tagless&lt;/em&gt; or &lt;em&gt;mtl-style&lt;/em&gt;, is very powerful. It lets you easily plug-in new implementations of type classes without changing any code.&lt;/p&gt;

&lt;p&gt;While there are many uses for this functionality, a powerful use case is testing systems thoroughly without having to rely on error-prone, type-unsafe mocking frameworks built on byte code rewriting and custom class-loading.&lt;/p&gt;

&lt;h3 id=&quot;industry-proven&quot;&gt;Industry Proven&lt;/h3&gt;

&lt;p&gt;Other proposed solutions for modeling effects in Scala are interesting research projects—worthy of exploration in labs, but they have not been proven in industry.&lt;/p&gt;

&lt;p&gt;For example, a Scala 3 proposal to use implicit function types for effect capabilities (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;CanIO&lt;/code&gt;) has a variety of drawbacks that render it Dead On Arrival:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;Strictly Synchronous&lt;/strong&gt;. Implicit function types are not powerful enough to model asynchronous effects, generators, or other effects that require continuations. If you combine them with continuations, then you now have two effect systems, when you really only need one (continuations are actually powerful enough to implement everything else!). The stitched-together creation adds complexity, confusion, and cognitive and runtime overhead.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Stack Suicide&lt;/strong&gt;. Functional programming relies on recursion to perform (possibly infinite) iteration, and while &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;IO&lt;/code&gt; types in Scala are built for unbounded, safe recursion, implicit function types will stack overflow on recursion, making them unsuitable for general-purpose programming.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Escaped Effects&lt;/strong&gt;. Implicit function types require a linear type system in order to guarantee that no capabilities are leaked. Because Scala does not have linear typing, it cannot guarantee that capabilities won’t leak. Monadic approaches are much simpler and don’t need linear types to avoid leaking capabilities. &lt;em&gt;Note: I saw an attempt to hack special case magic to the compiler to prevent leaking, but like all magic, it may interact poorly with other parts of Scala or have edge cases.&lt;/em&gt;&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Dysfunctional Drawbacks&lt;/strong&gt;. Implicit function types encourage you to write non-functional code, and therefore have all the drawbacks of dysfunctional code—you cannot reason about them in the same way, they mix poorly with pure code, they don’t reify effects as values, and so on.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Runaway Resources&lt;/strong&gt;. Implicit function types do not solve the fundamental problem of how to perform &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;try&lt;/code&gt; / &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;finally&lt;/code&gt; across asynchronous, synchronous, and concurrent sections of code (because this requires continuations), which means they will be prone to leaking resources in exceptional cases. Modern &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;IO&lt;/code&gt; types solve this easily.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Monstrous Monomorphism&lt;/strong&gt;. Unlike monadic approaches, which, via final tagless / mtl-style, permit you to write code that is polymorphic across different implementations (a mock implementation for testing, an asynchronous one for production, etc.), implicit function types are too monomorphic to achieve this degree of flexibility—unless you use them to wrap monads, in which case, what’s the point?&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Contrast an effect system based on implicit function types with monadic approaches based on &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;IO&lt;/code&gt;, which have had 30 years of active development and have seen significant use in industry (including at my &lt;a href=&quot;https://github.com/slamdata/quasar&quot;&gt;last company&lt;/a&gt;, where they were used to build large-scale analytics infrastructure).&lt;/p&gt;

&lt;p&gt;Indeed, monads have proven so successful at solving all of the above problems (and more!), you can now find monadic effect systems implemented in PureScript, Kotlin, Scala, Javascript, Java, C#, F#, and numerous other programming languages.&lt;/p&gt;

&lt;p&gt;If you want to get work done and write functional code &lt;em&gt;everywhere&lt;/em&gt; (and not everyone does!), then monads are the only general-purpose, industry-proven technique available.&lt;/p&gt;

&lt;h3 id=&quot;summary&quot;&gt;Summary&lt;/h3&gt;

&lt;p&gt;In summary, functional programmers like me don’t use &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;IO&lt;/code&gt; for ideological reasons. Instead, we use &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;IO&lt;/code&gt; for very practical, real-world benefits.&lt;/p&gt;

&lt;p&gt;A lot of these benefits are about making it easier for us to refactor our programs and to know what our programs mean and what they do, without having to study their implementations and simulate their runtime behavior in our head.&lt;/p&gt;

&lt;p&gt;Other benefits include uniform purity, so we don’t have to worry about mixing pure and impure code; and the ability to turn our programs into first-class values, so we can pass them around, store them in data structures, and combine them in expressions—giving us insane levels of expressivity.&lt;/p&gt;

&lt;p&gt;Beyond all this, there is a strong business case for using an &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;IO&lt;/code&gt; effect system like &lt;a href=&quot;https://github.com/scalaz/scalaz-zio&quot;&gt;ZIO&lt;/a&gt;, Monix &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Task&lt;/code&gt;, or equivalent. ZIO includes features like super fast performance, a uniform interface for synchronous and asynchronous effects, lazy evaluation (&lt;em&gt;interruption&lt;/em&gt;) that safely eliminates wasted resources (memory, network, CPU), parallelism, concurrency, scalability, and so much more.&lt;/p&gt;

&lt;p&gt;Unlike implicit function types and other academic curiosities, monadic effects are battle-tested and industry-proven. We know how they work, how they compose, and how they perform, and they are becoming pervasive across purely functional programming communities, regardless of language.&lt;/p&gt;

&lt;p&gt;Maybe these reasons aren’t compelling enough to get you to use &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;IO&lt;/code&gt; (which is fine!). But they should &lt;em&gt;at least&lt;/em&gt; be compelling enough to get you to &lt;em&gt;try&lt;/em&gt; &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;IO&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;In my experience, people are usually put off by &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;IO&lt;/code&gt; not because it’s more complex or doesn’t have obvious, tangible benefits, but because it’s &lt;em&gt;different&lt;/em&gt; and &lt;em&gt;unfamiliar&lt;/em&gt;. With practice, unfamiliarity turns into familiarity, and many fall in love with the many benefits described in this article.&lt;/p&gt;

&lt;p&gt;After all, the growing armies of developers across many different communities all using monadic effects to solve everyday problems can’t all be crazy! (Or can we?)&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Note: Post originally inspired by a &lt;a href=&quot;https://www.reddit.com/r/scala/comments/8ygjcq/can_someone_explain_to_me_the_benefits_of_io/&quot;&gt;Reddit thread&lt;/a&gt; on the benefits of IO.&lt;/em&gt;&lt;/p&gt;

  &lt;p&gt;&lt;a href=&quot;https://degoes.net/articles/fpoop-vs-fp&quot;&gt;Scala Wars: FP-OOP vs FP&lt;/a&gt; was originally published by John A De Goes at &lt;a href=&quot;https://degoes.net&quot;&gt;John <em>A</em> <strong>De Goes</strong>&lt;/a&gt; on July 14, 2018.&lt;/p&gt;</content>
</entry>


<entry>
  <title type="html"><![CDATA[Bifunctor IO: A Step Away from Dynamically-Typed Error Handling]]></title>
  <link rel="alternate" type="text/html" href="https://degoes.net/articles/bifunctor-io" />
  <id>https://degoes.net/articles/bifunctor-io</id>
  <published>2018-05-10T00:00:00-06:00</published>
  <updated>2018-05-10T00:00:00-06:00</updated>
  <author>
    <name>John A De Goes</name>
    <uri>https://degoes.net</uri>
    <email>john@degoes.net</email>
  </author>
  <content type="html">&lt;p&gt;&lt;em&gt;Bifunctor IO&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;The subject is currently one of the hottest topics in the Scala functional programming community, inspiring both fear and awe in equal measure, as well as a proliferation of tickets, pull requests, and blog posts.&lt;/p&gt;

&lt;p&gt;The occasion? Scalaz 8 IO has a new bifunctor design that challenges our assumptions about error handling in effect types, and functional programmers all over Scala’s community are trying to decide if and how this design helps us write better software.&lt;/p&gt;

&lt;p&gt;Scalaz 8’s greenfield design presents a unique opportunity to re-examine every assumption about functional programming in Scala. The bifunctor design joins other innovations in the effect system (such as fine-grained interruption, resource safety, and fiber concurrency), as well as a &lt;a href=&quot;https://www.slideshare.net/jdegoes/scalaz-8-a-whole-new-game&quot;&gt;growing number of novel features&lt;/a&gt; intended to radically improve FP in Scala.&lt;/p&gt;

&lt;p&gt;Fibers and interruption were hotly debated when I first introduced them at Scala IO and &lt;a href=&quot;https://www.youtube.com/watch?v=wi_vLNULh9Y&quot;&gt;Scale by the Bay&lt;/a&gt;, but now &lt;a href=&quot;https://github.com/typelevel/cats-effect&quot;&gt;even competitive libraries&lt;/a&gt; have moved in the direction of Scalaz 8 IO.&lt;/p&gt;

&lt;p&gt;What of bifunctor IO? Is this design going to change the way we manage errors in Scala effect types? Or will it be an interesting footnote in the history of functional programming in Scala?&lt;/p&gt;

&lt;p&gt;As a contributor, I’m certainly biased, but I do believe bifunctor IO, which introduces typed errors, is here to stay, and that it’s going to greatly improve our ability to reason about our software. Bifunctor IO helps us describe the properties of our code through the type system, which is what drove many of us to statically-typed FP.&lt;/p&gt;

&lt;p&gt;In this post, I’m going to give you an overview of the design and debunk some common myths. You can then decide for yourself if the increased precision is useful.&lt;/p&gt;

&lt;h2 id=&quot;what-is-io&quot;&gt;What is IO?&lt;/h2&gt;

&lt;p&gt;In many libraries, including Scalaz 7.2 and prior, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;IO[A]&lt;/code&gt; (or &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Task[A]&lt;/code&gt;) is an immutable data type that models an effectful program that runs forever, fails with a &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Throwable&lt;/code&gt;, or computes an &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;A&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Like everything else in purely functional programming, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;IO&lt;/code&gt; is referentially-transparent—and all of its methods, excepting &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;unsafePerformIO&lt;/code&gt; or its equivalent, are total, deterministic, and free of side effects.&lt;/p&gt;

&lt;p&gt;You can use &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;IO&lt;/code&gt; values to build other &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;IO&lt;/code&gt; values, in the same way you can use &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;String&lt;/code&gt; values to build other &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;String&lt;/code&gt; values. It’s very similar to programming with immutable lists, maps, and other data structures common in functional programming, except instead of modeling data structures, the type models IO operations (so-called &lt;em&gt;effects&lt;/em&gt;).&lt;/p&gt;

&lt;p&gt;Inside your application’s main function, you convert &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;IO&lt;/code&gt; into the effects that it models by &lt;em&gt;performing&lt;/em&gt; those operations. In Scala, this execution function ships with every effect system, so you can run effects as easily as &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;unsafePerformIO(myProgram)&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;While “running” an effect is not purely functional, for impure languages like Scala, it’s a necessary evil—at least (and ideally, at most) one place in your application.&lt;/p&gt;

&lt;p&gt;I mentioned earlier that &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;IO[A]&lt;/code&gt; can fail with a &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Throwable&lt;/code&gt; or produce an &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;A&lt;/code&gt;. This bifurcation should remind you of &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Either[E, A]&lt;/code&gt;, and indeed, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;IO&lt;/code&gt; data types are effectful versions of &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Either[E, A]&lt;/code&gt;, where the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;E&lt;/code&gt; type is either untyped or loosely typed.&lt;/p&gt;

&lt;p&gt;Effect types do not throw exceptions, of course. Their notion of failure is exactly like the notion of “failure” with &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Either[E, A]&lt;/code&gt;. Failure is a value and merely short-circuits the remainder of the computation unless the failure is handled. This behaves similar to an exception in all the ways that matter, but it’s just an ordinary value (semantically, anyway, if not always in the implementation).&lt;/p&gt;

&lt;p&gt;All effect types ship with equivalents of the following two error management functions:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-scala&quot; data-lang=&quot;scala&quot;&gt;&lt;span class=&quot;k&quot;&gt;object&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;IO&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;c1&quot;&gt;// A function defined on the `IO` companion object:
&lt;/span&gt;  &lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;fail&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;A&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;](&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;t&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Throwable&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;IO&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;A&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;???&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;trait&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;IO&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;A&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;...&lt;/span&gt;
  &lt;span class=&quot;c1&quot;&gt;// A method defined on the `IO` data type:
&lt;/span&gt;  &lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;attempt&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;IO&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;Throwable&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;\/&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;A&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;???&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;...&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;where &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;type \/[A, B] = Either[A, B]&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;These two functions allow you to produce a value that describes a failed computation (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;IO.fail&lt;/code&gt;), as well as handle a value that describes a failed computation (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;io.attempt&lt;/code&gt;). They satisfy the obvious properties (e.g. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;IO.fail(t).attempt === IO.point(\/.left(t))&lt;/code&gt;, where &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;IO.point&lt;/code&gt; lifts a pure &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;A&lt;/code&gt; into &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;IO[A]&lt;/code&gt;).&lt;/p&gt;

&lt;p&gt;General-purpose effect types like &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;IO&lt;/code&gt; are how we usually model effects in purely functional programs. Because &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;IO&lt;/code&gt; can represent any type of effect and has reasonably high performance, it tends to be the foundation that functional programs are built on. While FP programs may use other effect types, those types usually end up translated into &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;IO&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Lots of programming languages have &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;IO&lt;/code&gt;-like types, including of course Haskell (from which the Scala effect types are inspired!), PureScript, TypeScript, Kotlin, and many other languages.&lt;/p&gt;

&lt;p&gt;Interestingly, every &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;IO[A]&lt;/code&gt; data type in all of these languages has a bifurcated model of computation: either the effect fails with some (dynamically-typed) error, or it succeeds with some value of type &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;A&lt;/code&gt;.&lt;/p&gt;

&lt;h2 id=&quot;whats-bifunctor-io&quot;&gt;What’s Bifunctor IO?&lt;/h2&gt;

&lt;p&gt;I came up with a bifunctor design for IO in late 2017, and recently upgraded Scalaz 8 IO to support the new design. In this design, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;IO[E, A]&lt;/code&gt; is an immutable data type that models an effectful program that runs forever, fails with an &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;E&lt;/code&gt;, or computes an &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;A&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;IO[E, A]&lt;/code&gt; is a “bifunctor” because you can define an instance of the type class &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Bifunctor&lt;/code&gt; (defined &lt;a href=&quot;https://github.com/scalaz/scalaz/blob/series/7.3.x/core/src/main/scala/scalaz/Bifunctor.scala&quot;&gt;here&lt;/a&gt;), which lets you map over not just the value (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;A =&amp;gt; A2&lt;/code&gt;), but also over the error (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;E =&amp;gt; E2&lt;/code&gt;).&lt;/p&gt;

&lt;p&gt;This bifunctor capability of the data type is essential, as it allows you to “lift” programs that produce one class of errors into programs that produce another (typically larger) class of errors.&lt;/p&gt;

&lt;p&gt;In bifunctor IO, the two core error management functions are nearly unchanged, but become significantly more general:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-scala&quot; data-lang=&quot;scala&quot;&gt;&lt;span class=&quot;k&quot;&gt;object&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;IO&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;fail&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;E&lt;/span&gt;, &lt;span class=&quot;kt&quot;&gt;A&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;](&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;E&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;IO&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;E&lt;/span&gt;, &lt;span class=&quot;kt&quot;&gt;A&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;???&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;trait&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;IO&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;E&lt;/span&gt;, &lt;span class=&quot;kt&quot;&gt;A&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;...&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;attempt&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;E2&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;IO&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;E2&lt;/span&gt;, &lt;span class=&quot;kt&quot;&gt;E&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;\/&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;A&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;???&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;...&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Instead of being forced to fail an &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;IO&lt;/code&gt; with a poorly typed &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Throwable&lt;/code&gt;, you can create &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;IO&lt;/code&gt; values that model failure &lt;em&gt;for any error type at all&lt;/em&gt;, including strings, numbers, ADTs, or even type-level sets, all of which make sense in different circumstances.&lt;/p&gt;

&lt;p&gt;Most functional programs will mix and match many different types of errors at different levels of the application, varying them in response to the local needs of each part of the application.&lt;/p&gt;

&lt;p&gt;The &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;attempt&lt;/code&gt; function becomes polymorphic in the new error type, allowing you to choose any type of error. This represents a compile-time guarantee that the attempted &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;IO&lt;/code&gt; cannot fail, because there is no way it can summon a value of an arbitrary type &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;E2&lt;/code&gt; into existence. You can easily choose the error type of an attempted effect to be &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Nothing&lt;/code&gt; or equivalent (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Void&lt;/code&gt; in Scalaz, Haskell, PureScript, and others), thus proving that failure is impossible.&lt;/p&gt;

&lt;p&gt;The power of this approach can be demonstrated in the following snippet:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-scala&quot; data-lang=&quot;scala&quot;&gt;&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;right&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;A&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;](&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;v&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Void&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;\/&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;A&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;A&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;
  &lt;span class=&quot;nv&quot;&gt;v&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;py&quot;&gt;fold&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;_&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;py&quot;&gt;absurd&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;A&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;])(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;identity&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;io&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;IO&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;E&lt;/span&gt;, &lt;span class=&quot;kt&quot;&gt;A&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;???&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;attempt1&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;IO&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;Void&lt;/span&gt;, &lt;span class=&quot;kt&quot;&gt;E&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;\/&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;A&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;io&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;py&quot;&gt;attempt&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;Void&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;attempt2&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;IO&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;Void&lt;/span&gt;, &lt;span class=&quot;kt&quot;&gt;Void&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;\/&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;E&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;\/&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;A&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)]&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;attempt1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;py&quot;&gt;attempt&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;Void&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;attempt3&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;IO&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;Void&lt;/span&gt;, &lt;span class=&quot;kt&quot;&gt;E&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;\/&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;A&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;attempt2&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;py&quot;&gt;map&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;right&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;This snippet proves the intuitive fact that repeated attempts cannot fail. The fact that you can express this guarantee at compile-time, using types that communicate rich information to developers, is quite remarkable and powerful.&lt;/p&gt;

&lt;p&gt;While error management changes only in minor ways, the resulting ramifications to the error model are profound. Before I explore them, however, we must talk about the different types of errors.&lt;/p&gt;

&lt;h2 id=&quot;types-of-errors&quot;&gt;Types of Errors&lt;/h2&gt;

&lt;p&gt;There are two classes of errors in applications:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;strong&gt;Recoverable Errors&lt;/strong&gt;. Recoverable errors refer to the errors we expect to happen occasionally. For example, when we perform an https request, we expect that sometimes, it will not succeed because the server is down or there are network issues. Because we expect these errors to happen, we want to build our code in a way that acknowledges the failure scenarios. We want graceful fallbacks at some level of the application (perhaps not locally, but at the edges).&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Non-Recoverable Errors&lt;/strong&gt;. Non-recoverable errors refer to the errors we do not expect to happen. For example, if a user has configured the JRE with 10k of memory for the stack, then a lot of ordinary (non-recursive) code will stack overflow, producing a &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;StackOverflowError&lt;/code&gt;. This is not a normal error we expect to happen, nor is there a sane way to recover from it.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;In Java, the convention is to use &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Exception&lt;/code&gt; for recoverable errors, and &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Error&lt;/code&gt; for non-recoverable errors. Both of these are subclasses of &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Throwable&lt;/code&gt;, which is the only error type supported by the JVM.&lt;/p&gt;

&lt;p&gt;In languages like Erlang and C, recoverable errors are modeled with ordinary values, and non-recoverable errors do not have an explicit representation and resolve outside application logic (with a crash in Erlang, and with undefined behavior in C).&lt;/p&gt;

&lt;p&gt;The distinction between failure scenarios that we expect to happen and failure scenarios that we do not expect to happen is &lt;em&gt;extremely important&lt;/em&gt;:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Failure scenarios that we expect to happen can be recovered from in application code. In statically-typed functional programming, we have the ability to guarantee at compile-time that expected failures are handled, or at least tracked, so we know the consequences of interacting with such code.&lt;/li&gt;
  &lt;li&gt;Failure scenarios that we do &lt;em&gt;not&lt;/em&gt; expect to happen cannot be sanely recovered from, and the reason is precisely this: we did &lt;em&gt;not&lt;/em&gt; expect these errors, so we do not know &lt;em&gt;where&lt;/em&gt; they will occur, &lt;em&gt;what&lt;/em&gt; these errors will be, or whether it makes sense to continue, and if so, what remedial actions permit a well-defined recovery.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Attempting to recover from an unexpected error puts your program into an undefined state: it is undefined precisely because you do not know where the error occurred, which means you don’t know the state of the application or its external environment; and you do not know what the error is, which means you don’t know if and how to recover.&lt;/p&gt;

&lt;p&gt;Non-recoverable errors are almost always defects, but sometimes they occur for catastrophic reasons outside the direct control of the programmer (such as running out of memory). A C program may overwrite an arbitrary piece of memory (defect), a Java program may try to allocate more memory than reserved for the heap (catastrophic), or an Erlang actor may make a false assumption about data (defect).&lt;/p&gt;

&lt;p&gt;The distinction between recoverable and non-recoverable errors fully informs the design of the Scalaz 8 IO error model. In the next section, I’ll introduce this error model and talk about its implications.&lt;/p&gt;

&lt;h2 id=&quot;a-principled-error-model&quot;&gt;A Principled Error Model&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;/images/scalaz-8-error-model.png&quot; alt=&quot;Scalaz 8 Error Model&quot; /&gt;&lt;/p&gt;

&lt;p&gt;In the Scalaz 8 IO error model, the distinction between recoverable and non-recoverable errors is explicit. This distinction forms the foundation of the error model.&lt;/p&gt;

&lt;p&gt;Recoverable errors are statically-typed, and modeled by the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;E&lt;/code&gt; type parameter in &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;IO[E, A]&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Effects of type &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;IO[E, A]&lt;/code&gt; can fail for any &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;E&lt;/code&gt;, and can be recovered from to yield &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;IO[E2, E \/ A]&lt;/code&gt;, for any type &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;E2&lt;/code&gt;, including uninhabited types like &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Nothing&lt;/code&gt; or Scalaz’s &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Void&lt;/code&gt; type. The type system tells you &lt;em&gt;if&lt;/em&gt; and &lt;em&gt;how&lt;/em&gt; an effect can fail.&lt;/p&gt;

&lt;p&gt;Non-recoverable errors are &lt;em&gt;weakly typed&lt;/em&gt;, and include the full range of runtime errors on the JVM, which is any type that extends &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Throwable&lt;/code&gt;. Execution of any &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;IO[E, A]&lt;/code&gt; may fail due to some non-recoverable error—probably a defect, but possibly a catastrophic error outside the control of the program.&lt;/p&gt;

&lt;p&gt;Non-recoverable errors are, as their name suggests, not recoverable, which is the case in languages like C and Erlang. If one of these errors occurs, the fiber running the effect will be terminated.&lt;/p&gt;

&lt;p&gt;This error model implies that, aside from non-termination, there are exactly three possible outcomes from running an effect &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;IO[E, A]&lt;/code&gt;:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;The effect fails due to an unhandled &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;E&lt;/code&gt; created with &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;IO.fail&lt;/code&gt;.&lt;/li&gt;
  &lt;li&gt;The effect is terminated due to a non-recoverable &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Throwable&lt;/code&gt;.&lt;/li&gt;
  &lt;li&gt;The effect computes an &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;A&lt;/code&gt;.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;In the sections that follow, I’ll dive into specifics of the error model by covering some of the practical benefits to developers.&lt;/p&gt;

&lt;h3 id=&quot;benefit-1-no-dynamically-typed-errors&quot;&gt;Benefit 1: No Dynamically-Typed Errors&lt;/h3&gt;

&lt;p&gt;The most distinguishing feature of the error model is that it allows us to move away from dynamically-typed errors.&lt;/p&gt;

&lt;p&gt;Programming with &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;IO[A]&lt;/code&gt; provides no compile-time guarantees about failure. From the type alone, you must assume that all effects may fail for any reason at any time, even if you’ve already handled them or they can only fail in specific ways.&lt;/p&gt;

&lt;p&gt;With &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;IO[E, A]&lt;/code&gt;, you know all possible (recoverable) failure scenarios:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;If you handle some failure scenarios but not others, you can express this in the type by choosing a suitable sum type for &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;E&lt;/code&gt;.&lt;/li&gt;
  &lt;li&gt;If the effect cannot fail, you can express this with &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;IO[Void, A]&lt;/code&gt; or equivalent.&lt;/li&gt;
  &lt;li&gt;If the effect may truly fail for any reason, then you can express this with &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;IO[Throwable, E]&lt;/code&gt; (or even, heaven forbid, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;IO[AnyRef, E]&lt;/code&gt;).&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;For one practical application among many, suppose that you want your REST API to return errors in the JSON format. In this case, you can simply express the requirement in the type:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-scala&quot; data-lang=&quot;scala&quot;&gt;&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;serve&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;handler&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;HTTPRequest&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;IO&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;Void&lt;/span&gt;, &lt;span class=&quot;kt&quot;&gt;JSON&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;])&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;The type here demands that the handler you pass to the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;serve&lt;/code&gt; function handle all its own errors and encode them into JSON. Now you don’t have to worry about code forgetting to handle some error and then not knowing how to transcribe the error into the required JSON format.&lt;/p&gt;

&lt;p&gt;As another example, suppose we have an evaluator in a spreadsheet application for some domain-specific scripting language. In this case, we want to know precisely how evaluation may fail, because failure is expected and we must handle different failures in different ways.&lt;/p&gt;

&lt;p&gt;In this case, we can model the evaluator as follows:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-scala&quot; data-lang=&quot;scala&quot;&gt;&lt;span class=&quot;k&quot;&gt;sealed&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;trait&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;EvaluationError&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;case&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;ParseError&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;line&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Int&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;expected&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;List&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;Symbol&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;])&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;extends&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;EvaluationError&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;case&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;TypeError&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;expected&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Type&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;actual&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Type&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;extends&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;EvaluationError&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;case&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;RuntimeError&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;extends&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;EvaluationError&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;evaluate&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;script&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;IO&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;EvaluationError&lt;/span&gt;, &lt;span class=&quot;kt&quot;&gt;Unit&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;???&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Both statically-typed values &lt;em&gt;and&lt;/em&gt; statically-typed errors let us use the compiler to prove properties of our programs. In the case of statically-typed errors, we can prove that effects only fail in specific ways, or that they don’t fail at all.&lt;/p&gt;

&lt;p&gt;Further, we can vary our propositions in different parts of our program, because we have the flexibility to vary the type of error.&lt;/p&gt;

&lt;h3 id=&quot;feature-2-no-lost-errors&quot;&gt;Feature 2: No Lost Errors&lt;/h3&gt;

&lt;p&gt;Most programming languages have lossy error models. By lossy, I mean it is possible for exceptions to be swallowed.&lt;/p&gt;

&lt;p&gt;In the following snippet, two errors will be swallowed:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-scala&quot; data-lang=&quot;scala&quot;&gt;&lt;span class=&quot;k&quot;&gt;try&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;try&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;try&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Error&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;e1&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;finally&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Error&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;e2&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;finally&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Error&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;e3&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;catch&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;case&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;e&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Error&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Most Scala (or Java) developers don’t know which error will be caught and reported in the outermost &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;catch&lt;/code&gt; block, but one fact is clear from the structure: at most one exception will be reported. The other two will be lost forever.&lt;/p&gt;

&lt;p&gt;Scalaz 8 IO dramatically improves on this broken error model by &lt;em&gt;guaranteeing&lt;/em&gt; that no errors are lost, whether they are recoverable errors modeled with &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;E&lt;/code&gt;, or non-recoverable errors that result from defects or catastrophic runtime errors.&lt;/p&gt;

&lt;p&gt;This guarantee is provided with a &lt;em&gt;hierarchy of supervisors&lt;/em&gt;. A &lt;em&gt;supervisor&lt;/em&gt; is just a function &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Throwable =&amp;gt; IO[Void, Unit]&lt;/code&gt;, which will receive all unhandled errors from a fiber.&lt;/p&gt;

&lt;p&gt;The root fiber, which runs the application &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;main&lt;/code&gt; function, has a default supervisor, which can be overridden. The default supervisor prints the stack trace of the error to the console.&lt;/p&gt;

&lt;p&gt;Other supervisors are specified by the application when forking an effect. For example, if you want to run some work in a separate fiber, you call &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;fork0&lt;/code&gt; and specify the supervisor for the fiber:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-scala&quot; data-lang=&quot;scala&quot;&gt;&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;fiber&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;&amp;lt;-&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;work&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;py&quot;&gt;fork0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;t&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;logError&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;t&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;))&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;...&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;yield&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;()&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;In this example, the supervisor merely logs the error to a file, to ensure if there is a defect in our program, we know that it happened. Other sensible choices include logging to a remote server, restarting a fiber, or returning diagnostic information in an API.&lt;/p&gt;

&lt;p&gt;Supervisors are hierarchical. If you don’t specify a supervisor when forking an effect, then it will inherit the supervisor of the fiber that performed the forking.&lt;/p&gt;

&lt;p&gt;The supervisor hierarchy provides a modular way of dealing with unhandled errors. Lower levels of an application can decide how to supervise their children, or simply delegate to the parent.&lt;/p&gt;

&lt;h3 id=&quot;benefit-3-no-resource-leaks&quot;&gt;Benefit 3: No Resource Leaks&lt;/h3&gt;

&lt;p&gt;Scalaz 8 IO has a built-in primitive called &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;bracket&lt;/code&gt;, which is a more structured version of &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;try&lt;/code&gt; / &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;finally&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;The &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;bracket&lt;/code&gt; primitive allows you to acquire a resource in one effect, use the resource in another effect, and finally, close the resource in a different effect.&lt;/p&gt;

&lt;p&gt;Using this primitive is quite simple:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-scala&quot; data-lang=&quot;scala&quot;&gt;&lt;span class=&quot;nf&quot;&gt;openFile&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;data.csv&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;).&lt;/span&gt;&lt;span class=&quot;py&quot;&gt;bracket&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;closeFile&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;_&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;))&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;handle&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;=&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;c1&quot;&gt;// Use resource in here...
&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Resources acquired with &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;bracket&lt;/code&gt; will &lt;em&gt;always&lt;/em&gt; be released, even if the body fails due to an unhandled &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;E&lt;/code&gt;, a defect in the code, fiber interruption, or a catastrophic external error.&lt;/p&gt;

&lt;p&gt;Resource safety lets you build bullet-proof, long-lived applications that are resilient to failures, whether expected or unexpected.&lt;/p&gt;

&lt;h3 id=&quot;benefit-4-no-changes-needed&quot;&gt;Benefit 4: No Changes Needed&lt;/h3&gt;

&lt;p&gt;A remarkable property of the Scalaz 8 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;IO&lt;/code&gt; bifunctor design is that it generalizes over both the &lt;em&gt;existing&lt;/em&gt; dynamically-typed error effect types and so-called &lt;em&gt;non-exceptional&lt;/em&gt; effect types.&lt;/p&gt;

&lt;p&gt;Existing effect types may fail at any time, for any reason. To model this type of effect type, we can use the following type alias:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-scala&quot; data-lang=&quot;scala&quot;&gt;&lt;span class=&quot;k&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Task&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;A&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;IO&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;Throwable&lt;/span&gt;, &lt;span class=&quot;kt&quot;&gt;A&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;With one notable exception, there is &lt;em&gt;no difference&lt;/em&gt; between this definition of &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Task&lt;/code&gt; and other dynamically-typed error effects. This is the preferred migration option if you are moving to Scalaz 8 from Scalaz 7.2 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;IO&lt;/code&gt; or &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Task&lt;/code&gt;, Monix &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Task&lt;/code&gt;, or cats-effect &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;IO&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;The only difference relates to how &lt;em&gt;defects&lt;/em&gt; are handled. Older error models conflate recoverable errors with non-recoverable errors, which “works” because they fix the error type to &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Throwable&lt;/code&gt;. These types encourage users to write code like &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;IO.point(42).map(_ =&amp;gt; throw Error(&quot;Surprise!&quot;)).attempt&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;In Scalaz 8 IO, defects in your code cannot be “caught”, similar to Erlang, C, and many other real-world programming languages. Since we use values to represent failure in functional programming (in the case of &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;IO&lt;/code&gt;, values constructed with &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;IO.fail&lt;/code&gt;), throwing exceptions from pure code is considered a defect, and the fiber running the effect will be terminated.&lt;/p&gt;

&lt;p&gt;The cause for the termination will, of course, be passed to the fiber’s supervisor, so it can be logged or otherwise made visible. Or, depending on the context, you might decide to restart a fiber that fails due to a defect, similar to supervision in actor systems.&lt;/p&gt;

&lt;p&gt;Aside from this one difference, users who prefer only using &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Throwable&lt;/code&gt;, or who wish to introduce typed errors selectively, can simply use &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;IO[Throwable, A]&lt;/code&gt; as their default effect type.&lt;/p&gt;

&lt;p&gt;No changes to error handling are necessary, because the bifunctor design completely subsumes older designs.&lt;/p&gt;

&lt;h3 id=&quot;benefit-5-no-errors&quot;&gt;Benefit 5: No Errors&lt;/h3&gt;

&lt;p&gt;As discussed previously, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;IO&lt;/code&gt; can also model effects that cannot fail. The following snippet creates a type synonym to do just this:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-scala&quot; data-lang=&quot;scala&quot;&gt;&lt;span class=&quot;k&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Unexceptional&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;A&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;IO&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;Void&lt;/span&gt;, &lt;span class=&quot;kt&quot;&gt;A&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Effects of type &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Unexceptional[A]&lt;/code&gt; cannot (recoverably) fail, meaning if they fail, it’s because of a non-recoverable defect in your code or because of a catastrophic error like &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;OutOfMemoryError&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;As you can see, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;IO[E, A]&lt;/code&gt; generalizes over both non-exceptional effect types and dynamically-typed effect types. In other words, the bifunctor design of Scalaz 8 IO is &lt;em&gt;strictly more expressive&lt;/em&gt; than all other effect types. Other effect types fall out elegantly as special cases.&lt;/p&gt;

&lt;p&gt;Developers who complain about the bifunctor design are really complaining because they have &lt;em&gt;gained&lt;/em&gt; the ability to be more precise, not because they are &lt;em&gt;required&lt;/em&gt; to be more precise. This is rather like complaining about optional type annotations—if you don’t like them, don’t use them!&lt;/p&gt;

&lt;p&gt;The alternative to the bifunctor design is to introduce special-case types for non-exceptional or strongly-typed effect types. For example, cats-effect will probably get &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;UIO&lt;/code&gt;, which is a non-exceptional effect type, and may at some point get a bifunctor &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;BIO&lt;/code&gt;. Such proliferation of effect types (with massive redundancy in the implementations!) is unnecessary with the bifunctor design, because a single generalized type &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;IO[E, A]&lt;/code&gt; is capable of modeling everything.&lt;/p&gt;

&lt;h2 id=&quot;debunking-myths-of-bifunctor-io&quot;&gt;Debunking Myths of Bifunctor IO&lt;/h2&gt;

&lt;p&gt;The bifunctor design for the Scalaz 8 IO effect type is so new, there’s not much documentation on the subject. Up until recently, the main source of documentation has been the code itself! As a result, the design has been subject to a lot of speculation.&lt;/p&gt;

&lt;p&gt;In the next sections, I want to debunk what I perceive to be common myths around the bifunctor design. Arguably, some of these myths are instead &lt;em&gt;strong biases&lt;/em&gt; toward dynamically-typed error handling, but most of you who read this blog probably prefer static types, and will share my own bias in this regard.&lt;/p&gt;

&lt;h3 id=&quot;myth-1-composition-destroys-specific-error-types&quot;&gt;Myth 1: Composition Destroys Specific Error Types&lt;/h3&gt;

&lt;p&gt;This myth states that composing two effects &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;IO[E1, A]&lt;/code&gt; and &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;IO[E2, B]&lt;/code&gt; will result in an error type that erases the distinction between &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;E1&lt;/code&gt; and &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;E2&lt;/code&gt;. Stated simply, &lt;em&gt;composing effects leads to a loss of precise error types&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;This myth is false because users themselves define how error types compose, and they are not required to use &lt;em&gt;common supertype&lt;/em&gt; composition. For example, I can easily combine two effects &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;IO[E1, A]&lt;/code&gt; and &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;IO[E2, B]&lt;/code&gt; with different errors in a lossless way using a disjunction type, such as &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;E1 \/ E2&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;This technique is demonstrated in the following snippet:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-scala&quot; data-lang=&quot;scala&quot;&gt;&lt;span class=&quot;k&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;io&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;IO&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;E1&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;\/&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;E2&lt;/span&gt;, &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;A&lt;/span&gt;, &lt;span class=&quot;kt&quot;&gt;B&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;))&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;=&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;&amp;lt;-&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;op1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;py&quot;&gt;leftMap&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(\/.&lt;/span&gt;&lt;span class=&quot;py&quot;&gt;left&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;&amp;lt;-&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;op2&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;py&quot;&gt;leftMap&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(\/.&lt;/span&gt;&lt;span class=&quot;py&quot;&gt;right&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;yield&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;In general, error types always compose in a completely lossless way using sum types.&lt;/p&gt;

&lt;p&gt;In some cases, you may want a built-in sum type like &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;\/&lt;/code&gt; (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Either&lt;/code&gt;), as shown in the above snippet. In other cases, it is more convenient to define a custom sum type, such as the previously introduced &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;EvaluationError&lt;/code&gt;:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-scala&quot; data-lang=&quot;scala&quot;&gt;&lt;span class=&quot;k&quot;&gt;sealed&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;trait&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;EvaluationError&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;case&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;ParseError&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;line&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Int&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;expected&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;List&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;Symbol&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;])&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;extends&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;EvaluationError&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;case&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;TypeError&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;expected&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Type&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;actual&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Type&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;extends&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;EvaluationError&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;case&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;RuntimeError&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;extends&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;EvaluationError&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Others still may prefer to use type-level sets to represent errors, because this makes it very easy to add and subtract errors, while still providing the ability to handle some or all errors.&lt;/p&gt;

&lt;p&gt;The &lt;a href=&quot;https://twitter.com/propensive/status/993422307388424192&quot;&gt;Mitigation library&lt;/a&gt; by &lt;a href=&quot;https://twitter.com/propensive&quot;&gt;Jon Pretty&lt;/a&gt;, based on Totalitarian, provides a convenient and powerful solution for managing sets of errors. Look for &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;scalaz-mitigation&lt;/code&gt; in the near future! (Bug Jon and me about it until we do something!)&lt;/p&gt;

&lt;h3 id=&quot;myth-2-you-dont-recover-from-errors-often&quot;&gt;Myth 2: You Don’t Recover From Errors Often&lt;/h3&gt;

&lt;p&gt;This myth states that typed errors are not useful because most code doesn’t recover from most types of errors.&lt;/p&gt;

&lt;p&gt;This is only true when recoverable errors are conflated with non-recoverable errors. If an error is not expected, and therefore cannot be recovered from, then it will neither appear in any type signature, nor affect the development experience.&lt;/p&gt;

&lt;p&gt;For example, take the following snippet of code:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-scala&quot; data-lang=&quot;scala&quot;&gt;&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;r1&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;&amp;lt;-&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;op1&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;r2&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;&amp;lt;-&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;op2&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;r3&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;&amp;lt;-&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;op3&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;yield&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;r1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;r2&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;r3&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;If &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;op1&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;op2&lt;/code&gt;, and &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;op3&lt;/code&gt; do not fail in recoverable ways, then they will have type &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;IO[Void, A]&lt;/code&gt; (for some type &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;A&lt;/code&gt;), which means they compose with effects of any other error type, and we know from looking at the type signature that these operations do not fail.&lt;/p&gt;

&lt;p&gt;Only recoverable errors, which we expect to happen, and which we need to deal with in our programs, are reflected in the error type.&lt;/p&gt;

&lt;h3 id=&quot;myth-3-the-error-type-is-an-encapsulation-leak&quot;&gt;Myth 3: The Error Type is an Encapsulation Leak&lt;/h3&gt;

&lt;p&gt;This myth states that having statically-typed errors leaks implementation details. This is not true at all—in fact, it is poor API design that leaks implementation details.&lt;/p&gt;

&lt;p&gt;Let’s take the following API:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-scala&quot; data-lang=&quot;scala&quot;&gt;&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;read&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;id&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;IO&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;FileNotFoundException&lt;/span&gt;, &lt;span class=&quot;kt&quot;&gt;ByteVector&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;This API states that &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;read&lt;/code&gt; can fail with &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;FileNotFoundException&lt;/code&gt;. However, we may want to abstract over different ways of reading a resource (in-memory versus over https, for example). If we want to abstract over reading, then &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;FileNotFoundException&lt;/code&gt; is a poor way to represent failure. Instead, we should design the API as follows:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-scala&quot; data-lang=&quot;scala&quot;&gt;&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;read&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;id&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;IO&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;ResourceNotFound&lt;/span&gt;, &lt;span class=&quot;kt&quot;&gt;ByteVector&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Or possibly even more simply:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-scala&quot; data-lang=&quot;scala&quot;&gt;&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;read&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;id&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;IO&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;Void&lt;/span&gt;, &lt;span class=&quot;kt&quot;&gt;Option&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;ByteVector&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]]&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Whether or not an effect may fail in a recoverable way is part of an API’s public contract, and should be reflected clearly in the types.&lt;/p&gt;

&lt;p&gt;API design requires skill, and types alone cannot stop us from making bad design choices. Even without typed errors, we are free to design APIs that leak implementation details.&lt;/p&gt;

&lt;p&gt;For example, consider the following API:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-scala&quot; data-lang=&quot;scala&quot;&gt;&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;resolve&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;path&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Task&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;File&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;This API resolves a &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;path&lt;/code&gt; to a &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;File&lt;/code&gt; resource (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;java.util.File&lt;/code&gt;). However, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;File&lt;/code&gt; only represents local files, and could easily be generalized to &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;URI&lt;/code&gt; or something similar. If we must abstract over different resource locations, then &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;File&lt;/code&gt; is a poor choice.&lt;/p&gt;

&lt;p&gt;No one would suggest that because it is possible to return &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;File&lt;/code&gt;, and that &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;File&lt;/code&gt; leaks implementation details, we should therefore use &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;AnyRef&lt;/code&gt; for all return values so we can let implementations vary.&lt;/p&gt;

&lt;p&gt;In the same way, just because it is possible to leak implementation details in the type of an error channel, doesn’t mean we should use dynamically-typed errors.&lt;/p&gt;

&lt;p&gt;There is no connection whatsoever between typed errors and the leaking of implementation details. They are completely orthogonal.&lt;/p&gt;

&lt;h3 id=&quot;myth-4-it-pushes-complexity-to-the-user&quot;&gt;Myth 4: It Pushes Complexity to the User&lt;/h3&gt;

&lt;p&gt;This myth states that using typed errors pushes “complexity” to the user. The myth conflates &lt;em&gt;inherent complexity&lt;/em&gt; with &lt;em&gt;incidental complexity&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Inherent complexity&lt;/em&gt; is complexity that is inherent to the task of properly modeling a domain. For example, if we wish to precisely model the domain of JSON values, then we &lt;em&gt;must&lt;/em&gt; have a sum type that supports boolean, null, numbers, arrays, and objects. Further, our number type must support arbitrary precision.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-scala&quot; data-lang=&quot;scala&quot;&gt;&lt;span class=&quot;k&quot;&gt;sealed&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;trait&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;JSON&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;case&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;object&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;JNull&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;extends&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;JSON&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;case&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;JBool&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Boolean&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;extends&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;JSON&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;case&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;JNum&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;BigDecimal&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;extends&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;JSON&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;case&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;JArr&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;List&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;JSON&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;])&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;extends&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;JSON&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;case&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;JObj&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Map&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;String&lt;/span&gt;, &lt;span class=&quot;kt&quot;&gt;JSON&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;])&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;extends&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;JSON&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;This is complexity, but it is inherent complexity because it is intrinsic to the problem of precisely modeling JSON values.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Incidental complexity&lt;/em&gt; is complexity that arises not because of the problem domain, but because of implementation decisions that could have been otherwise without sacrificing correctness. For example, dependency injection frameworks have much &lt;em&gt;incidental complexity&lt;/em&gt;—they are a very complex way of passing arguments to functions.&lt;/p&gt;

&lt;p&gt;Precisely modeling data types always comes with some cost due to &lt;em&gt;inherent complexity&lt;/em&gt;. Stated differently, making illegal states unrepresentable requires work. If we want to precisely describe &lt;em&gt;if&lt;/em&gt; and &lt;em&gt;how&lt;/em&gt; our effects may fail, then this, too, will require work, but this complexity is inherent to precise error handling.&lt;/p&gt;

&lt;p&gt;A design like Scalaz 8 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;IO&lt;/code&gt; lets you choose how precise you want to be. It has the flexibility to describe infallible effects or effects that fail in only pre-defined ways, but you only need to use this flexibility when you decide the precision adds sufficient value.&lt;/p&gt;

&lt;p&gt;Legacy designs remove the choice from you, forcing you into a dynamically-typed error model that offers no ability to make illegal (error) states unrepresentable. They are antithetical to the goals that drive us to statically-typed functional programming.&lt;/p&gt;

&lt;h3 id=&quot;myth-5-the-bifunctor-io-doesnt-reflect-the-runtime&quot;&gt;Myth 5: The Bifunctor IO Doesn’t Reflect the Runtime&lt;/h3&gt;

&lt;p&gt;This myth states that any effect type should “reflect the runtime”, which is vague enough to warrant &lt;a href=&quot;https://twitter.com/djspiewak/status/983805298526699520&quot;&gt;sourcing the claim&lt;/a&gt;:&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;“IO needs to reflect and describe the capabilities of the runtime, for good or for bad. All it takes is an ‘innocent’ throw to turn it all into a lie, and you can’t prevent that.”&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;This is an argument to catch defects, such as exceptions thrown from pure code, so users can attempt recovery. It’s also an argument to fix the failure type to &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Throwable&lt;/code&gt;, because this is what the JVM does.&lt;/p&gt;

&lt;p&gt;The argument is incoherent, as can be seen by examining the implications of consistently “reflecting the runtime”.&lt;/p&gt;

&lt;p&gt;The JVM does not support parametric polymorphism, which means the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;A&lt;/code&gt; in &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;IO[A]&lt;/code&gt; is erased at runtime (equivalent to &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;IO[AnyRef]&lt;/code&gt;). Because of this type erasure and the lack of type safety in Scala, this means having a value of type &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;IO[A]&lt;/code&gt; is no guarantee the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;IO&lt;/code&gt; value will actually compute an &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;A&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;To “reflect the runtime” in the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;IO&lt;/code&gt; data type, it would be necessary to avoid using parametric polymorphism entirely, because this feature is not supported by the JVM, and it’s impossible to enforce that &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;IO[A]&lt;/code&gt; actually produces anything of type &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;A&lt;/code&gt;. After all, &lt;em&gt;reflecting the runtime&lt;/em&gt; would argue, it just takes one innocent, accidental coercion to turn &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;IO[A]&lt;/code&gt; into a lie, and you can’t prevent that!&lt;/p&gt;

&lt;p&gt;Additionally, the JVM uses &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;null&lt;/code&gt; for optionality, not &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Option&lt;/code&gt; or &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Maybe&lt;/code&gt;. &lt;em&gt;Reflecting the runtime&lt;/em&gt; would argue for embracing &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;null&lt;/code&gt; for optionality, and expecting &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;null&lt;/code&gt; everywhere in the interface to &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;IO&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Doing functional programming, &lt;a href=&quot;https://www.cse.chalmers.se/~nad/publications/danielsson-et-al-popl2006.pdf&quot;&gt;even in languages like Haskell&lt;/a&gt;, requires a set of assumptions. In Scala, these assumptions include no runtime reflection, no coercion, no exceptions, no side effects, no null, and so forth.&lt;/p&gt;

&lt;p&gt;Without these assumptions (often called the &lt;a href=&quot;https://www.lihaoyi.com/post/StrategicScalaStylePracticalTypeSafety.html#scalazzi-scala&quot;&gt;Scalazzi subset&lt;/a&gt; of Scala, after Scalaz), you would program fearfully, constantly checking the runtime class of every value, testing to make sure no values are null, obsessively try/catching, and fearing that a function like &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;def identity[A](a: A): A&lt;/code&gt; may generate a novel &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;A&lt;/code&gt; through runtime reflection.&lt;/p&gt;

&lt;p&gt;Principled development requires sane assumptions, and pragmatic development requires we know when these assumptions go wrong. The Scalaz 8 error model provides both in a single package, because even though the design assumes you work in Scalazzi, if you don’t, your defects will be captured and reported to supervisors.&lt;/p&gt;

&lt;h3 id=&quot;myth-6-bifunctor-io-doesnt-let-you-use-impure-code&quot;&gt;Myth 6: Bifunctor IO Doesn’t Let You Use Impure Code&lt;/h3&gt;

&lt;p&gt;This myth states that because the bifunctor design doesn’t automatically catch defects, you can’t use the effect type with Java code or impure Scala code.&lt;/p&gt;

&lt;p&gt;This is not true at all. All code, including exception throwing, impure code, can be trivially imported into &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;IO&lt;/code&gt;. In fact, there are three utility functions in Scalaz 8 that do just this:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;def syncThrowable[A](eff: =&amp;gt; A): IO[Throwable, A]&lt;/code&gt; — This function imports code that may throw &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Throwable&lt;/code&gt; values, properly translating them into &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;IO.fail&lt;/code&gt; values.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;def syncException[A](eff: =&amp;gt; A): IO[Exception, A]&lt;/code&gt; — This function imports code that may throw &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Exception&lt;/code&gt; values, properly translating them into &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;IO.fail&lt;/code&gt; values.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;def syncCatch[E, A](eff: =&amp;gt; A)(pf: PartialFunction[Throwable, E]): IO[E, A]&lt;/code&gt; — This function imports code that may throw a user-defined range of errors, properly translating them into &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;IO.fail&lt;/code&gt; values.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;These functions let you safely interact with dysfunctional code, which performs side-effects and throws exceptions. You can import this code into pure values, which can interface with your functional code.&lt;/p&gt;

&lt;p&gt;Wrapping unsafe code with &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Try&lt;/code&gt;, to safely convert exceptions into values, is something that many Scala developers are already doing. With Scalaz 8, the method you use changes, but not much else.&lt;/p&gt;

&lt;h3 id=&quot;myth-7-bifunctor-io-is-just-eithert&quot;&gt;Myth 7: Bifunctor IO Is Just EitherT&lt;/h3&gt;

&lt;p&gt;This myth states that bifunctor IO is unnecessary, since we can already achieve the same benefits by stacking the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;EitherT&lt;/code&gt; monad transformer on top of ordinary &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;IO&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;There are two flaws in this argument:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;For older effect types &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;F[_]&lt;/code&gt; (such as Monix &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Task&lt;/code&gt;, cats-effect &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;IO&lt;/code&gt;, and Scalaz 7.2 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;IO&lt;/code&gt; / &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Task&lt;/code&gt;), &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;EitherT[IO, E, ?]&lt;/code&gt; has two error channels, overlapping instances for &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;MonadError&lt;/code&gt; (one having an error type fixed to &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Throwable&lt;/code&gt;), two conflicting ways of failing, and two conflicting ways of recovering from failures. Contrast this to &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;IO[E, A]&lt;/code&gt;, which has a single error channel.&lt;/li&gt;
  &lt;li&gt;Scalaz 8 bifunctor IO is functionally equivalent to &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;EitherT[UIO, E, A]&lt;/code&gt; for some infallible effect type &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;UIO&lt;/code&gt;. Although Scalaz 8 IO could be redesigned to be infallible, this would mean as much as a &lt;em&gt;5x performance penalty&lt;/em&gt; for recapturing error handling using an &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;EitherT&lt;/code&gt; monad transformer. As discussed in my &lt;a href=&quot;https://degoes.net/articles/effects-without-transformers&quot;&gt;last blog post&lt;/a&gt;, monad transformers are not practical in Scala.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Scalaz 8 IO brings something genuinely new to the table over &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;EitherT&lt;/code&gt;: a clean, typed, single error channel, and high-performance, wrapped in a package that generalizes over all existing effect types.&lt;/p&gt;

&lt;h2 id=&quot;final-words&quot;&gt;Final Words&lt;/h2&gt;

&lt;p&gt;Like other changes in Scalaz 8, including the fiber concurrency model, fine-grained interruption, and resource safety, the bifunctor design of &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;IO&lt;/code&gt; requires rethinking assumptions.&lt;/p&gt;

&lt;p&gt;This new model doesn’t &lt;em&gt;require&lt;/em&gt; you to be more precise, since you’re free to stick with &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Throwable&lt;/code&gt; for all your errors. But it does &lt;em&gt;empower&lt;/em&gt; you to describe failure scenarios precisely, and vary &lt;em&gt;if&lt;/em&gt; and &lt;em&gt;how&lt;/em&gt; effects fail at different levels of your application.&lt;/p&gt;

&lt;p&gt;Benefits of the error model are many, and include being able to model infallible effects (non-exceptional &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;IO&lt;/code&gt;), use effects the way you’re familiar with (using &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Throwable&lt;/code&gt; everywhere) so you can gradually incorporate typed errors wherever useful, guarantee no resource leaks (even in the event of non-recoverable errors), never lose any errors (unlike other error models), and have strong, compile-time guarantees about &lt;em&gt;if&lt;/em&gt; and &lt;em&gt;how&lt;/em&gt; your effects can fail.&lt;/p&gt;

&lt;p&gt;While there are myths out there about the new bifunctor design, this is expected since there is a scarcity of documentation. Without good documentation, there will always be questions about how a new design works or what the tradeoffs are. Hopefully this blog post succeeds in making the bifunctor design more accessible.&lt;/p&gt;

&lt;p&gt;If I’ve convinced you the bifunctor design has value, vote with your feet: support projects like Scalaz 8 IO, encourage contributions like Luka Jacobowitz’s &lt;a href=&quot;https://github.com/LukaJCB/cats-bio&quot;&gt;bifunctor IO&lt;/a&gt;, and contribute issues and pull requests to your favorite effect type.&lt;/p&gt;

&lt;p&gt;Scalaz 8 IO may be the first one to adopt this design, but from the looks of things, it’s not the last. I greatly look forward to seeing others adopt and improve upon the design, to the benefit of the entire Scala functional programming community.&lt;/p&gt;

  &lt;p&gt;&lt;a href=&quot;https://degoes.net/articles/bifunctor-io&quot;&gt;Bifunctor IO: A Step Away from Dynamically-Typed Error Handling&lt;/a&gt; was originally published by John A De Goes at &lt;a href=&quot;https://degoes.net&quot;&gt;John <em>A</em> <strong>De Goes</strong>&lt;/a&gt; on May 10, 2018.&lt;/p&gt;</content>
</entry>


<entry>
  <title type="html"><![CDATA[No More Transformers: High-Performance Effects in Scalaz 8]]></title>
  <link rel="alternate" type="text/html" href="https://degoes.net/articles/effects-without-transformers" />
  <id>https://degoes.net/articles/effects-without-transformers</id>
  <published>2018-05-05T00:00:00-06:00</published>
  <updated>2018-05-05T00:00:00-06:00</updated>
  <author>
    <name>John A De Goes</name>
    <uri>https://degoes.net</uri>
    <email>john@degoes.net</email>
  </author>
  <content type="html">&lt;p&gt;Monad transformers just aren’t practical in Scala.&lt;/p&gt;

&lt;p&gt;They impose tremendous performance overhead that rapidly leads to CPU-bound, memory-hogging applications that give functional programming in Scala a reputation for being impractical.&lt;/p&gt;

&lt;p&gt;Fortunately, all hope is not lost! In this article, I’ll describe the alternative approach that is being championed by Scalaz 8, which offers many of the benefits of MTL, but without the high costs.&lt;/p&gt;

&lt;h2 id=&quot;the-trouble-with-transformers&quot;&gt;The Trouble with Transformers&lt;/h2&gt;

&lt;p&gt;Monad transformers rely on vertical composition to layer new effects onto other effects. For example, the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;EitherT&lt;/code&gt; monad transformer adds the effect of error management to some base effect &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;F[_]&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;In the following snippet, I have defined an &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;OptionT&lt;/code&gt; transformer that adds the effect of optionality to some base effect &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;F[_]&lt;/code&gt;:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-scala&quot; data-lang=&quot;scala&quot;&gt;&lt;span class=&quot;k&quot;&gt;case&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;OptionT&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;F&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;_&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt;, &lt;span class=&quot;kt&quot;&gt;A&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;](&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;run&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;F&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;Option&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;A&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]])&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;map&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;B&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;](&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;A&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;B&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;implicit&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;F&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Functor&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;F&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;])&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;OptionT&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;F&lt;/span&gt;, &lt;span class=&quot;kt&quot;&gt;B&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;=&lt;/span&gt;
    &lt;span class=&quot;nc&quot;&gt;OptionT&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;run&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;py&quot;&gt;map&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;_&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;py&quot;&gt;map&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)))&lt;/span&gt;

  &lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;flatMap&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;B&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;](&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;A&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;OptionT&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;F&lt;/span&gt;, &lt;span class=&quot;kt&quot;&gt;B&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;])(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;implicit&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;F&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Monad&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;F&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;])&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;OptionT&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;F&lt;/span&gt;, &lt;span class=&quot;kt&quot;&gt;B&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;=&lt;/span&gt;
    &lt;span class=&quot;nc&quot;&gt;OptionT&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;run&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;py&quot;&gt;flatMap&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;
      &lt;span class=&quot;nv&quot;&gt;_&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;py&quot;&gt;fold&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;Option&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;py&quot;&gt;empty&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;B&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;].&lt;/span&gt;&lt;span class=&quot;py&quot;&gt;point&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;F&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;])(&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;f&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;andThen&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;fa&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;OptionT&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;F&lt;/span&gt;, &lt;span class=&quot;kt&quot;&gt;B&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;])&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;fa&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;py&quot;&gt;run&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;))))&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;object&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;OptionT&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;point&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;F&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;_&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Applicative&lt;/span&gt;, &lt;span class=&quot;kt&quot;&gt;A&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;](&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;A&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;OptionT&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;F&lt;/span&gt;, &lt;span class=&quot;kt&quot;&gt;A&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;=&lt;/span&gt;
    &lt;span class=&quot;nc&quot;&gt;OptionT&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;py&quot;&gt;point&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;Option&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;].&lt;/span&gt;&lt;span class=&quot;py&quot;&gt;point&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;F&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;])&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;If you’ve ever written high-performance code on the JVM, even a quick glance at this definition of &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;OptionT&lt;/code&gt; should concern you. The transformer imposes additional indirection and heap usage for every usage of &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;point&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;map&lt;/code&gt;, and &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;flatMap&lt;/code&gt; operation in your application.&lt;/p&gt;

&lt;p&gt;While runtimes for languages like Haskell are reasonably efficient at executing this type of code, the JVM is not. We can see this very clearly by performing a line-by-line analysis of the transformer.&lt;/p&gt;

&lt;p&gt;The definition of the class introduces a wrapper &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;OptionT&lt;/code&gt;:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-scala&quot; data-lang=&quot;scala&quot;&gt;&lt;span class=&quot;k&quot;&gt;case&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;OptionT&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;F&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;_&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt;, &lt;span class=&quot;kt&quot;&gt;A&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;](&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;run&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;F&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;Option&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;A&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]])&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Compared to the original effect &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;F[_]&lt;/code&gt;, use of this wrapper will involve two additional allocations: an allocation for &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Option&lt;/code&gt;, and an allocation for &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;OptionT&lt;/code&gt;. In the worst case (for a simple &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;F[_]&lt;/code&gt;), this wrapper might &lt;em&gt;triple&lt;/em&gt; memory consumption of your application!&lt;/p&gt;

&lt;p&gt;The &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;map&lt;/code&gt; function is defined as follows:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-scala&quot; data-lang=&quot;scala&quot;&gt;  &lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;map&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;B&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;](&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;A&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;B&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;implicit&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;F&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Functor&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;F&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;])&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;OptionT&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;F&lt;/span&gt;, &lt;span class=&quot;kt&quot;&gt;B&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;=&lt;/span&gt;
    &lt;span class=&quot;nc&quot;&gt;OptionT&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;run&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;py&quot;&gt;map&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;_&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;py&quot;&gt;map&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)))&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;In the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;map&lt;/code&gt; of the original &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;F[_]&lt;/code&gt;, there is a minimum of one method call. While no allocations are required, it is likely the function passed to &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;map&lt;/code&gt; will be a lambda that closes over some local state, which means there will often be another allocation.&lt;/p&gt;

&lt;p&gt;In the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;map&lt;/code&gt; function of the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;OptionT&lt;/code&gt; transformer, there are an additional 3 method calls (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;OptionT.apply&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;run&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;map&lt;/code&gt;), and an additional two allocations (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;OptionT&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;_&lt;/code&gt;), one for the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;OptionT&lt;/code&gt; wrapper and one for the anonymous function.&lt;/p&gt;

&lt;p&gt;If the type class syntax is not free, like in the Cats library, then there will be even more allocations and method calls.&lt;/p&gt;

&lt;p&gt;This looks bad, but the actual situation is &lt;em&gt;far worse&lt;/em&gt; than it appears.&lt;/p&gt;

&lt;p&gt;Monad transformers can be stacked on top of any monad. This means they need to require monadic constraints on &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;F[_]&lt;/code&gt;, here represented by &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;implicit F: Functor[F]&lt;/code&gt; on the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;map&lt;/code&gt; function (for this operation, we don’t need to assume &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Monad&lt;/code&gt;, because all we need is &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Functor&lt;/code&gt;).&lt;/p&gt;

&lt;p&gt;We are interacting with the base monad through a JVM interface, which has many, many implementations across our code base. Most likely, the JVM will not be able to determine which concrete class we are interacting with, and if so, the method calls will become &lt;em&gt;megamorphic&lt;/em&gt;, which prevents many types of optimizations that can occur when calling methods on concrete classes.&lt;/p&gt;

&lt;p&gt;The story for &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;flatMap&lt;/code&gt; is similar:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-scala&quot; data-lang=&quot;scala&quot;&gt;  &lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;flatMap&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;B&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;](&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;A&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;OptionT&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;F&lt;/span&gt;, &lt;span class=&quot;kt&quot;&gt;B&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;])(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;implicit&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;F&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Monad&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;F&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;])&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;OptionT&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;F&lt;/span&gt;, &lt;span class=&quot;kt&quot;&gt;B&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;=&lt;/span&gt;
    &lt;span class=&quot;nc&quot;&gt;OptionT&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;run&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;py&quot;&gt;flatMap&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;
      &lt;span class=&quot;nv&quot;&gt;_&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;py&quot;&gt;fold&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;Option&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;py&quot;&gt;empty&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;B&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;].&lt;/span&gt;&lt;span class=&quot;py&quot;&gt;point&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;F&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;])(&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;f&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;andThen&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;fa&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;OptionT&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;F&lt;/span&gt;, &lt;span class=&quot;kt&quot;&gt;B&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;])&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;fa&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;py&quot;&gt;run&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;))))&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;This definition of &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;flatMap&lt;/code&gt; could be optimized, but even if completely optimized, there is even more overhead than &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;map&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Recently some benchmarks have compared the performance of Scalaz 8 IO (which has a bifunctor design for modeling errors) to its equivalent in &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;typelevel/cats&lt;/code&gt;, which is roughly &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;EitherT[cats.effect.IO, E, A]&lt;/code&gt; (modulo the additional failure case embedded into &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;IO&lt;/code&gt;).&lt;/p&gt;

&lt;p&gt;The difference in performance is &lt;em&gt;staggering&lt;/em&gt;: Scalaz 8 IO is nearly &lt;strong&gt;five times faster&lt;/strong&gt; than &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;EitherT[cats.effect.IO, E, A]&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Actual use in production could be faster or slower than these figures suggest, depending on the overhead of the base monad and how well the JRE optimizes the code. However, most applications that use monad transformers use many layers (not just a single &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;EitherT&lt;/code&gt; transformer), so the takeaway is clear: applications that use monad transformers will be tremendously slower and generate far more heap churn than applications that do not.&lt;/p&gt;

&lt;p&gt;Monad transformers just aren’t practical in Scala, a fact that Scalaz 8 is uniquely prepared to embrace.&lt;/p&gt;

&lt;h2 id=&quot;the-good-part-of-mtl&quot;&gt;The Good Part of MTL&lt;/h2&gt;

&lt;p&gt;Monad transformers aren’t all bad. In Haskell, the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;mtl&lt;/code&gt; library introduced &lt;em&gt;type classes&lt;/em&gt; for abstracting over data types that support the same effect.&lt;/p&gt;

&lt;p&gt;For example, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;MonadState&lt;/code&gt; abstracts over all data types that are capable of supporting getting and setting state (including, of course, the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;StateT&lt;/code&gt; monad transformer).&lt;/p&gt;

&lt;p&gt;In fact, these days &lt;strong&gt;MTL-style&lt;/strong&gt; does not refer to the use of monad transformers, per se, but to the use of the type classes that allow abstracting over the effects modeled by data structures.&lt;/p&gt;

&lt;p&gt;In Scala, this style has become known as &lt;em&gt;finally tagless&lt;/em&gt; for &lt;a href=&quot;https://okmij.org/ftp/tagless-final/index.html&quot;&gt;historical reasons&lt;/a&gt;. Most programmers doing functional programming in Scala recommend and use finally tagless-style, because it offers additional flexibility (for example, mocking out services for testing).&lt;/p&gt;

&lt;p&gt;It is not widely known in the Scala programming community that &lt;em&gt;finally tagless&lt;/em&gt; does not require monad transformers. In fact, there is absolutely no connection between finally tagless and monad transformers!&lt;/p&gt;

&lt;p&gt;In the next section, I will show how you can use &lt;em&gt;MTL-style&lt;/em&gt;, without specializing to concrete monad transformers.&lt;/p&gt;

&lt;h2 id=&quot;m-l-without-the-t&quot;&gt;M-L Without the T&lt;/h2&gt;

&lt;p&gt;Let’s say our application has some state type &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;AppState&lt;/code&gt;. Rather than use &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;StateT[F, S, A]&lt;/code&gt;, which is a monad transformer that adds state management to some base monad &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;F[_]&lt;/code&gt;, we will instead use the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;MonadState&lt;/code&gt; type class:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-scala&quot; data-lang=&quot;scala&quot;&gt;&lt;span class=&quot;k&quot;&gt;trait&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;MonadState&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;F&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;_&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt;, &lt;span class=&quot;kt&quot;&gt;S&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;extends&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Monad&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;F&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;self&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;=&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;get&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;F&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;S&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;put&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;S&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;F&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;Unit&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;We can then use &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;MonadState&lt;/code&gt; in our application like so:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-scala&quot; data-lang=&quot;scala&quot;&gt;&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;runApp&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;F&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;_&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]](&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;implicit&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;F&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;MonadState&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;F&lt;/span&gt;, &lt;span class=&quot;kt&quot;&gt;AppState&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;])&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;F&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;Unit&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;=&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;state&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;&amp;lt;-&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;F&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;py&quot;&gt;get&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;...&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;_&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;&amp;lt;-&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;F&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;py&quot;&gt;put&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;state&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;py&quot;&gt;copy&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(...))&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;...&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;yield&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;()&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Notice how this type class says &lt;em&gt;absolutely nothing&lt;/em&gt; about the data types &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;F[_]&lt;/code&gt; that can support state management.&lt;/p&gt;

&lt;p&gt;While we &lt;em&gt;can&lt;/em&gt; use our function &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;updateState&lt;/code&gt; with a &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;StateT&lt;/code&gt; monad transformer, there is no &lt;em&gt;requirement&lt;/em&gt; that we do so.&lt;/p&gt;

&lt;p&gt;The high-performance, industrial-strength approach embraced by Scalaz 8 involves defining instances for a newtype wrapper around the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;IO&lt;/code&gt; effect monad.&lt;/p&gt;

&lt;p&gt;I’ll show you how to do this in the next section.&lt;/p&gt;

&lt;h2 id=&quot;powered-by-scalaz-8-io&quot;&gt;Powered by Scalaz 8 IO™&lt;/h2&gt;

&lt;p&gt;The first step in the Scalaz 8 approach involves defining a newtype wrapper for &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;IO&lt;/code&gt;. The point of this wrapper is to create a unique type, which will allow us to define instances of type classes like &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;MonadState&lt;/code&gt; that are specific to the needs of our application.&lt;/p&gt;

&lt;p&gt;Although there are more reliable ways, one simple way to define a newtype is to declare a class that extends &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;AnyVal&lt;/code&gt; and stores a single value:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-scala&quot; data-lang=&quot;scala&quot;&gt;&lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;MyIO&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;A&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;](&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;run&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;IO&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;MyError&lt;/span&gt;, &lt;span class=&quot;kt&quot;&gt;A&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;])&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;extends&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;AnyVal&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Once we have define this newtype, then we need to create instances for all the type classes used by our application.&lt;/p&gt;

&lt;p&gt;There are several ways to create an instance of &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;MonadState&lt;/code&gt; for &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;MyIO&lt;/code&gt;. Since instances are first-class values in Scala, I prefer the following way, which uses an &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;IORef&lt;/code&gt; to manage the state:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-scala&quot; data-lang=&quot;scala&quot;&gt;&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;createMonadState&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;E&lt;/span&gt;, &lt;span class=&quot;kt&quot;&gt;S&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;](&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;initial&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;S&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;IO&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;E&lt;/span&gt;, &lt;span class=&quot;kt&quot;&gt;MonadState&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;MyIO&lt;/span&gt;, &lt;span class=&quot;kt&quot;&gt;S&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]]&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;=&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;ref&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;&amp;lt;-&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;IORef&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;initial&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;yield&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;MonadState&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;MyIO&lt;/span&gt;, &lt;span class=&quot;kt&quot;&gt;S&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;get&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;MyIO&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;S&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;MyIO&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;ref&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;py&quot;&gt;read&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;put&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;S&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;MyIO&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;Unit&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;MyIO&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;ref&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;py&quot;&gt;write&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;))&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;We can now use this function as follows inside our main function:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-scala&quot; data-lang=&quot;scala&quot;&gt;&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;args&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;IList&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;])&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;=&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;monadState&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;&amp;lt;-&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;createMonadState&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;AppState&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(...))&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;_&lt;/span&gt;          &lt;span class=&quot;k&quot;&gt;&amp;lt;-&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;runApp&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;monadState&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;yield&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;()&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Because &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;MyIO&lt;/code&gt; is nothing more than a newtype for &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;IO&lt;/code&gt;, there are no additional heap allocations or method calls associated with use of the data type. This means that you get as close to the raw performance of &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;IO&lt;/code&gt; as is possible in the finally tagless style.&lt;/p&gt;

&lt;p&gt;This approach works smoothly and efficiently for most common type classes, including &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;MonadReader&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;MonadWriter&lt;/code&gt;, and many others.&lt;/p&gt;

&lt;p&gt;Now you can have your cake and eat it, too: use type classes to precisely capture the minimal set of effects required by different parts of your application, and use instances of these type classes for your own newtype around &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;IO&lt;/code&gt;, giving you both abstraction and (relatively) high-performance.&lt;/p&gt;

&lt;h2 id=&quot;stack-safety&quot;&gt;Stack Safety&lt;/h2&gt;

&lt;p&gt;In Scala, many obvious monad transformers are stack unsafe. For example, the classic definition of &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;StateT&lt;/code&gt; is not stack safe. It can be modified to become stack safe, but the performance of an already slow data type becomes even slower, with many more method calls and allocations.&lt;/p&gt;

&lt;p&gt;The problem is not limited to transformers, either. It is common to use stack-safe monad transformers to implement base monads (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;State&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Writer&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Reader&lt;/code&gt;, and so on). For example, one can define a stack-safe base &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;State&lt;/code&gt; monad by using the type alias &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;type State[S, A] = StateT[F, S, A]&lt;/code&gt;, for some stack-safe &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;StateT&lt;/code&gt; and trampolined monad &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;F&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;While this approach (seen &lt;a href=&quot;https://github.com/typelevel/cats/blob/55e09026bd7e48f1cedf358cbe4f54666aca5460/core/src/main/scala/cats/data/package.scala#L48&quot;&gt;in the Cats library&lt;/a&gt;) creates stack safety for the base monad (by piggybacking on the safety of the transformer and the trampolined base monad), the resulting &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;State&lt;/code&gt; monad, which is powered by a slow &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;StateT&lt;/code&gt; transformer (made slower by stack safety!), becomes even slower due to trampolining.&lt;/p&gt;

&lt;p&gt;The technique presented in this post lets you eliminate base monads like &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;State&lt;/code&gt;, bypassing the massive performance overhead entailed by older approaches to stack safety.&lt;/p&gt;

&lt;h2 id=&quot;going-forward&quot;&gt;Going Forward&lt;/h2&gt;

&lt;p&gt;A decade of functional programming in Scala has taught us that while the abstraction afforded by MTL is extremely powerful and useful, transformers themselves just don’t work well in Scala—not today, and maybe not ever.&lt;/p&gt;

&lt;p&gt;Fortunately, we can take advantage of MTL-style without sacrificing performance, merely by defining instances for cost-free wrappers around &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;IO&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;As outlined in this post, there is a small amount of ceremony associated with this style, especially if you want to use localized effects. In addition, the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;AnyVal&lt;/code&gt; approach to creating newtypes is fraught with problems and doesn’t have the guarantees we need.&lt;/p&gt;

&lt;p&gt;In Scalaz 8, we should be able to address these issues in a way that makes it simple for users to use the right approach.&lt;/p&gt;

&lt;p&gt;Watch this space for more coverage of how recent innovations are making functional programming in Scala practical—suitable for mainstream use even for demanding technical requirements.&lt;/p&gt;

  &lt;p&gt;&lt;a href=&quot;https://degoes.net/articles/effects-without-transformers&quot;&gt;No More Transformers: High-Performance Effects in Scalaz 8&lt;/a&gt; was originally published by John A De Goes at &lt;a href=&quot;https://degoes.net&quot;&gt;John <em>A</em> <strong>De Goes</strong>&lt;/a&gt; on May 05, 2018.&lt;/p&gt;</content>
</entry>


<entry>
  <title type="html"><![CDATA[Will The Real Blockchain Stack Please Stand Up?]]></title>
  <link rel="alternate" type="text/html" href="https://degoes.net/articles/blockchain-stack" />
  <id>https://degoes.net/articles/blockchain-stack</id>
  <published>2018-02-16T00:00:00-07:00</published>
  <updated>2018-02-16T00:00:00-07:00</updated>
  <author>
    <name>John A De Goes</name>
    <uri>https://degoes.net</uri>
    <email>john@degoes.net</email>
  </author>
  <content type="html">&lt;p&gt;In my recent post on &lt;a href=&quot;/articles/blockchain-myths&quot;&gt;blockchain myths&lt;/a&gt;, I argued that successful blockchain applications will &lt;em&gt;not&lt;/em&gt; be built on blockchain platforms (Myth 4).&lt;/p&gt;

&lt;p&gt;In this followup post, I want to talk about why I believe this is &lt;em&gt;necessarily&lt;/em&gt; the case, and what it means for the future of blockchain development stacks.&lt;/p&gt;

&lt;h2 id=&quot;levels-of-blockchain&quot;&gt;Levels of Blockchain&lt;/h2&gt;

&lt;p&gt;Historically, tech has divided software into horizontal layers, stratified according to their distance from end-users:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;strong&gt;Infrastructure&lt;/strong&gt;. The infrastructure layer sits at the base of all other software, providing low-level functionality, including storage, compute, and network.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Platform&lt;/strong&gt;. The platform layer sits on top of infrastructure, providing middleware functionality in the form of frameworks or services.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Application&lt;/strong&gt;. The application layer sits on top of platform, providing tailored &lt;em&gt;applications&lt;/em&gt; that end-users use to solve specific problems.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;As cloud computing emerged to become the dominant model for software development and deployment, cloud analogues of these strata have materialized—IaaS, PaaS, and SaaS. Most SaaS applications are built on top of PaaS, which are in turn built on top of IaaS, replicating the familiar stack from before the days of cloud computing.&lt;/p&gt;

&lt;p&gt;The dominant vision for blockchain applications pictures a similar stack emerging over time:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;strong&gt;Infrastructure&lt;/strong&gt;. This layer would include the low-level software building blocks on top of which platforms are developed.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Platform&lt;/strong&gt;. This layer would include Ethereum, Filecoin, TiesDB, and other similar platforms, which are blockchain-based technologies that offer middleware functionality useful to building applications.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Application&lt;/strong&gt;. This layer would include end-user applications like CryptoKitties, Ethercraft, Akasha, and so forth.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;In the future, many would have you believe, successful blockchain applications—be they social media networks, contact relationship management applications, or ride-sharing applications—will be built on blockchain platforms.&lt;/p&gt;

&lt;p&gt;This is a very natural, intuitive vision of the future. Unfortunately, it’s also completely wrong.&lt;/p&gt;

&lt;h2 id=&quot;the-profile-of-success&quot;&gt;The Profile of Success&lt;/h2&gt;

&lt;p&gt;As of 2009, SalesForce hosted its CRM software on 1,000 nodes, while Blizzard utilized 20,000 nodes to provide hosted game services.&lt;/p&gt;

&lt;p&gt;In general, successful SaaS software is hosted on anywhere from hundreds to thousands (and in many cases, tens of thousands!) of nodes.&lt;/p&gt;

&lt;p&gt;That’s a crap load of computing power.&lt;/p&gt;

&lt;p&gt;The crypto space requires dramatically more compute power, because of the overhead of untrusted decentralization. Ethereum runs on 25,000 nodes, and Bitcoin runs on 7,000 nodes (many heavily specialized, with massive raw processing power).&lt;/p&gt;

&lt;p&gt;Despite this incredible compute power, all nodes in these blockchains are running more or less the same computations, which is an extraordinarily high cost to pay for untrusted decentralization—and one that has real implications on the network size of successful blockchain applications.&lt;/p&gt;

&lt;h2 id=&quot;success-on-the-blockchain&quot;&gt;Success on the Blockchain&lt;/h2&gt;

&lt;p&gt;If we take a modern-day SaaS application that requires hundreds of nodes, and port it to blockchain technology, it’s clear the number of nodes it requires will increase tremendously. If we naively assumed that one non-blockchain node can be emulated by 7,000 blockchain nodes (Bitcoin), then we’re looking at 7 million nodes to power a decentralized CRM application!&lt;/p&gt;

&lt;p&gt;Now clearly, innovations like sharding, proof-of-stake, variable trust topologies, and so forth, can improve efficiency by orders of magnitude. But even in the most optimistic scenarios, we are still looking at tens of thousands of nodes required to run a decentralized CRM application.&lt;/p&gt;

&lt;p&gt;In other words, a successful blockchain application, using next-generation blockchain technology that hasn’t even been invented yet, will require as many (or more) nodes as all of the massive Ethereum or Bitcoin networks!&lt;/p&gt;

&lt;p&gt;If successful blockchain applications will be as large (or potentially much larger) than current day networks, then they will necessarily possess the capability to run their &lt;em&gt;own&lt;/em&gt; blockchains.&lt;/p&gt;

&lt;p&gt;If successful blockchain applications have the capability to run their own blockchains, then any decentralized service they require—currently provided by platforms like Ethereum, Filecoin, or TiesDB—can be layered into those blockchains. In fact, the code for all these platforms is open source, so they could just fork and use the same code!&lt;/p&gt;

&lt;p&gt;Manifestly, the value of a blockchain is not the &lt;em&gt;software&lt;/em&gt; that runs the protocol, but the &lt;em&gt;size of the network&lt;/em&gt; that participates in the protocol. Successful blockchain applications will already possess &lt;em&gt;massive networks&lt;/em&gt; due to their raw requirements for compute and storage.&lt;/p&gt;

&lt;p&gt;In a market in which there exists two blockchain applications, and one of them pays transaction fees to numerous third-party blockchain platforms (each of which must pay for compute and storage and also make miners a profit), and one of them runs its own blockchain without any dependencies, the latter one will always win, because it will be cheaper, with fewer points of failure, lower latency, and full feature parity (since it could even use the same code as the blockchain platforms).&lt;/p&gt;

&lt;p&gt;The implications of this line of reasoning are dramatic. It means successful blockchain applications will &lt;em&gt;not&lt;/em&gt; be built on blockchain platforms—although they could very well be built on the &lt;em&gt;source code&lt;/em&gt; powering blockchain platforms.&lt;/p&gt;

&lt;h2 id=&quot;death-of-platforms&quot;&gt;Death of Platforms?&lt;/h2&gt;

&lt;p&gt;Just because successful blockchain applications will run their own stack of distributed services doesn’t mean blockchain platforms are going away.&lt;/p&gt;

&lt;p&gt;In fact, &lt;em&gt;unsuccessful&lt;/em&gt; blockchain applications—which might better be termed &lt;em&gt;niche&lt;/em&gt; blockchain applications—will need &lt;em&gt;somewhere&lt;/em&gt; to run, and blockchain platforms can pool together the needs of these niche applications to generate networks of significant size and value.&lt;/p&gt;

&lt;p&gt;In addition, Ethereum, Filecoin and some other platforms are more than &lt;em&gt;just&lt;/em&gt; platforms—they are &lt;em&gt;applications&lt;/em&gt; in and of themselves. Filecoin can be used to store your photos or movies. Ethereum can be used to run smart contracts between untrusted parties.&lt;/p&gt;

&lt;p&gt;Blockchain platforms like Ethereum and Filecoin can be very large and offer significant value. Most blockchain platforms, however, will be dwarfed by the most successful blockchain applications.&lt;/p&gt;

&lt;h2 id=&quot;the-real-stack&quot;&gt;The Real Stack&lt;/h2&gt;

&lt;p&gt;In my opinion, the real stack for successful blockchain applications &lt;em&gt;isn’t&lt;/em&gt; blockchain platforms, but rather, ordinary &lt;em&gt;FLOSS&lt;/em&gt; (free/libre open source software).&lt;/p&gt;

&lt;p&gt;I predict the rise of very modular frameworks (similar to &lt;a href=&quot;https://github.com/scorexfoundation/scorex&quot;&gt;Scorex&lt;/a&gt;), which allow trivial composition of the different services required by blockchain applications (file storage, messaging, identity management, smart contracts, etc). These frameworks will allow developers to quickly create purpose-built decentralized applications that run on their own blockchain.&lt;/p&gt;

&lt;p&gt;This means, among other things, a proliferation of digital currencies. Every successful blockchain application will have its own token type. This means exchanges become extraordinarily important, because there will be hundreds of thousands of different token types!&lt;/p&gt;

&lt;p&gt;Modular frameworks will probably accelerate standardization, which will have many benefits. Dedicated miners (AKA &lt;em&gt;cloud infrastructure providers 2.0&lt;/em&gt;) will eventually use blockchain container technology to allow them to dynamically shift mining power to the most profitable decentralized applications.&lt;/p&gt;

&lt;h2 id=&quot;funding-the-stack&quot;&gt;Funding the Stack&lt;/h2&gt;

&lt;p&gt;If modular, open source frameworks are the future of successful blockchain applications, a natural question is &lt;em&gt;who’s going to pay for them&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;It’s possible the answer to this question is &lt;em&gt;no one&lt;/em&gt;, like most open source software is developed today. But I actually think blockchains open up remarkable new pathways for funding open source software.&lt;/p&gt;

&lt;p&gt;In the context of blockchain frameworks, I’ll mention two possibilities that might be viable:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;strong&gt;Insurance&lt;/strong&gt;. If you build your application on a framework that is insecure, you risk complete destruction of your market. Developers of a framework might offer insurance against this possibility, which helps fund development of the framework, similar to how some open source software is monetized with commercial SLAs.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Taxes&lt;/strong&gt;. A framework can embed a small tax into every transaction, payable to the developers of the framework, in the “currency” of the application. Framework developers could offer dedicated support only to applications that do not disable taxation. In addition, a framework could provide a common set of cross-application services (such as seeding, name resolution, or authentication) in exchange for the tax.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Of these two options, I think taxation may be more likely, because it aligns incentives and doesn’t require upfront investment for application developers.&lt;/p&gt;

&lt;p&gt;If developers of a framework tax applications too heavily, the taxes will be disabled or the project forked by other developers with lower taxation.&lt;/p&gt;

&lt;p&gt;It’s like government taxation, only exit has no cost.&lt;/p&gt;

&lt;h2 id=&quot;summary&quot;&gt;Summary&lt;/h2&gt;

&lt;p&gt;In this post, I’ve tried to argue that the software and cloud models do not apply to the blockchain space, at least not in the way many think.&lt;/p&gt;

&lt;p&gt;Successful blockchain applications will require networks so large, they can provide all their own services on their own blockchain. This doesn’t imply blockchain platforms can’t be large and provide significant value, but it does have significant implications for the development of blockchain stacks.&lt;/p&gt;

&lt;p&gt;In particular, blockchain stacks are likely to emerge in the FLOSS world, and allow developers to modularly snap together the services required to implement a decentralized application running on its own blockchain. This will lead to a proliferation of token types and make exchanges even more crucial.&lt;/p&gt;

&lt;p&gt;Modular blockchain stacks may well emerge organically, possibly as forks of blockchain platforms, or they may be engineered and funded with novel blockchain-centric methods, like insurance or taxation.&lt;/p&gt;

&lt;p&gt;If this thesis is correct, it has implications for near-term funding and development of blockchain technology—some of which should be obvious, and others of which are more subtle. I hope to elaborate in future posts.&lt;/p&gt;

&lt;p&gt;If you have your own thoughts on what blockchain stacks of the future will look like, please share them in the comments section below!&lt;/p&gt;

  &lt;p&gt;&lt;a href=&quot;https://degoes.net/articles/blockchain-stack&quot;&gt;Will The Real Blockchain Stack Please Stand Up?&lt;/a&gt; was originally published by John A De Goes at &lt;a href=&quot;https://degoes.net&quot;&gt;John <em>A</em> <strong>De Goes</strong>&lt;/a&gt; on February 16, 2018.&lt;/p&gt;</content>
</entry>


<entry>
  <title type="html"><![CDATA[FCOP Nears 1.0 Release]]></title>
  <link rel="alternate" type="text/html" href="https://degoes.net/articles/coc-review" />
  <id>https://degoes.net/articles/coc-review</id>
  <published>2018-02-14T00:00:00-07:00</published>
  <updated>2018-02-14T00:00:00-07:00</updated>
  <author>
    <name>John A De Goes</name>
    <uri>https://degoes.net</uri>
    <email>john@degoes.net</email>
  </author>
  <content type="html">&lt;p&gt;Every community makes decisions about for whom to allow participation and about what types of behavior they permit. Codes of conduct (COCs) attempt to codify these decisions so that participants have a better understanding of what communities expect from them—and guarantee to them—and so community members can hold leadership accountable to their commitments.&lt;/p&gt;

&lt;p&gt;I’m delighted to announce that after nearly two years in development, &lt;a href=&quot;https://github.com/fantasylandinst/fcop&quot;&gt;FCOP&lt;/a&gt;, the code of conduct for professional communities, is nearing a 1.0 release!&lt;/p&gt;

&lt;p&gt;FCOP attempts to set very clear boundaries for ad hoc professional communities, such as technical meetups, open source projects, educational events, and industry conferences. Of course, no code of conduct replaces the need for trust, but FCOP helps make sure that everyone is on the same page.&lt;/p&gt;

&lt;p&gt;In my biased opinion, and specifically for ad hoc professional communities, FCOP is better in every possible way to the other available choices. FCOP is far more precise, and offers better guarantees and protections for members of a community, as well as realistic obligations and sensible protections for leaders of a community.&lt;/p&gt;

&lt;p&gt;In this post, I’ll compare &lt;a href=&quot;https://github.com/fantasylandinst/fcop&quot;&gt;FCOP&lt;/a&gt; with &lt;a href=&quot;https://citizencodeofconduct.org&quot;&gt;Citizen COC&lt;/a&gt; and &lt;a href=&quot;https://www.contributor-covenant.org/version/1/4/code-of-conduct.html&quot;&gt;Contributor Covenant&lt;/a&gt;, two other options for those looking for a COC.&lt;/p&gt;

&lt;h2 id=&quot;broad-provisions&quot;&gt;Broad Provisions&lt;/h2&gt;

&lt;p&gt;There are many dimensions on which COCs can be compared. I’ve highlighted a few of the most important ones below:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;Anti-Harassment&lt;/strong&gt;. The COC explicitly does not allow harassment.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Anti-Insulting&lt;/strong&gt;. The COC explicitly does not allow insulting communication, such as personal insults and ad hominem, or disparaging remarks about race, gender, body size, or sexual-orientation.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Anti-Doxxing&lt;/strong&gt;. The COC explicitly does not allow doxxing (publishing personal details about someone, such as their phone number or real name).&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Leader Discretion&lt;/strong&gt;. The COC does not mandate any particular consequences for specific COC violations, but leaves this decision to those who are tasked with investigating and resolving the incident.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;No Legal Overlap&lt;/strong&gt;. The COC explicitly does not try to supplant the legal system. Some COCs attempt to prohibit behavior that is already illegal or deal with illegal behavior outside the legal system.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Community Isolation&lt;/strong&gt;. The COC explicitly does not consider behavior that occurs outside the community, drawing a clear line between the personal and professional lives of members, and removing incentives for malicious individuals to dig through the personal lives of members.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Glossary&lt;/strong&gt;. The COC explicitly defines the terms that it uses for clarity and precision. COCs that do not define their terms are often vague and open to arbitrary interpretation, defeating the point of a COC.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Objective Criteria&lt;/strong&gt;. The COC explicitly requires objective criteria for COC violations. The alternative is defining violations in terms of how someone emotionally responds to an event, which makes it impossible for members to know how to behave, because to know how to behave, they have to predict people’s internal emotional reaction to every possible event.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Limited Liability&lt;/strong&gt;. The COC explicitly limits liability for the leaders of a community, to protect them in the event they are sued. Organizations may choose not to deploy COCs without limits on liability, or may require the COCs be reviewed and approved by their legal departments.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Anti-Retaliation&lt;/strong&gt;. The COC explicitly does not allow retaliation in response to reporting or resolving COC violations.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Anti-Sabotage&lt;/strong&gt;. The COC explicitly does not allow members to maliciously hurt each other’s careers (including taking credit for other people’s work) or maliciously damage the community itself.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Anti-Prying&lt;/strong&gt;. The COC explicitly does not allow members to spy on each other (private channels, phone conversations, etc.).&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Anti-Criminal&lt;/strong&gt;. The COC explicitly does not allow people to participate if they are likely to engage in criminal behavior.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Rightfully Accused&lt;/strong&gt;. The COC explicitly tries to protect people who are innocent, even if they have been falsely accused of a COC violation.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;No Tone Policing&lt;/strong&gt;. The COC explicitly does not engage in tone policing. A common alternative is to mandate empathic and emotionally sensitive communication, which is highly subjective, and not even possible for many with intellectual disabilities.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Symmetry&lt;/strong&gt;. The COC explicitly does not show favoritism to anyone, but uniformly requires professional behavior from everyone.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Reasonable Effort&lt;/strong&gt;. The COC explicitly limits the amount of work that leaders of a community are expected to perform. This provision is especially important for volunteer-run communities, like most open source projects and many conferences.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Customizable&lt;/strong&gt;. The COC explicitly has provisions for arbitrary amendments so the COC can be customized for each community.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Against these dimensions, the following table shows how the different codes of conduct stack up against one another.&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: left&quot;&gt; &lt;/th&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;FCOP&lt;/th&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;Citizen COC&lt;/th&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;Contributor COC&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;Anti-Harassment&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;✔&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;✔&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;✔&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;Anti-Insulting&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;✔&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;✔&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;✔&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;Anti-Doxxing&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;✔&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;✔&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;✔&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;Leader Discretion&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;✔&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;✔&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;✔&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;No Legal Overlap&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;✔&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;𐄂&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;✔&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;Community Isolation&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;✔&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;𐄂&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;✔&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;Glossary&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;✔&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;𐄂&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;𐄂&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;Objective Criteria&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;✔&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;𐄂&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;𐄂&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;Limited Liability&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;✔&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;𐄂&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;𐄂&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;Anti-Retaliation&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;✔&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;𐄂&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;𐄂&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;Anti-Sabotage&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;✔&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;𐄂&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;𐄂&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;Anti-Prying&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;✔&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;𐄂&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;𐄂&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;Anti-Criminal&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;✔&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;𐄂&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;𐄂&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;Rightfully Accused&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;✔&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;𐄂&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;𐄂&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;No Tone Policing&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;✔&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;𐄂&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;𐄂&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;Symmetry&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;✔&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;𐄂&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;𐄂&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;Reasonable Effort&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;✔&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;𐄂&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;𐄂&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;Customizable&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;✔&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;𐄂&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;𐄂&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;As this table shows, FCOP has broader protections for members than either Citizen COC or Contributor COC. Additionally, FCOP has provisions that appeal specifically to organizations and community leaders, who in nearly all cases wish to limit both legal liability and enforcement costs.&lt;/p&gt;

&lt;p&gt;Often in cases where all COCs share the same broad provision, FCOP has a stronger version. For example, the anti-harassment clause in FCOP states you may only interact with people if they want you to interact with them, and only in a professional way. This common-sense clause is by far the strongest anti-harassment clause of any of the COCs.&lt;/p&gt;

&lt;h2 id=&quot;inclusivity&quot;&gt;Inclusivity&lt;/h2&gt;

&lt;p&gt;Since COCs are often designed to signal inclusivity, many specifically mention common demographic dimensions, such as race, gender, and sexual-orientation. At the very least, a COC that explicitly refers to a demographic is signaling that leaders are intent on making the community welcoming to its members.&lt;/p&gt;

&lt;p&gt;The following table shows what types of demographic dimensions are explicitly mentioned in each of the three COCs.&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: left&quot;&gt; &lt;/th&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;FCOP&lt;/th&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;Citizen COC&lt;/th&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;Contributor COC&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;Race&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;✔&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;✔&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;✔&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;Gender&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;✔&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;✔&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;✔&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;Ethnicity&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;✔&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;✔&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;✔&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;Sexual Orientation&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;✔&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;✔&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;✔&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;Disability&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;✔&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;✔&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;✔&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;Religion&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;✔&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;✔&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;✔&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;Socioeconomic Status&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;✔&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;✔&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;✔&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;Sexual Identity&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;✔&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;𐄂&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;✔&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;Gender Expression&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;✔&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;𐄂&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;✔&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;Appearance&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;✔&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;𐄂&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;✔&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;Experience&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;✔&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;𐄂&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;✔&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;Education&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;✔&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;𐄂&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;✔&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;Nationality&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;✔&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;𐄂&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;✔&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;Body Size&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;✔&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;𐄂&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;✔&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;Age&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;✔&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;𐄂&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;✔&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;Politics&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;✔&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;𐄂&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;𐄂&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;Body Mods&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;✔&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;𐄂&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;𐄂&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;BDSM/Kink&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;✔&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;𐄂&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;𐄂&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;Personality&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;✔&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;𐄂&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;𐄂&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;Past Professions&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;✔&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;𐄂&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;𐄂&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;FCOP has more comprehensive coverage than Citizen COC or Contributor COC, including coverage of politics and BDSM/kink. In these areas specifically, members of various communities (&lt;a href=&quot;https://medium.com/@marlene.jaeckel/the-empress-has-no-clothes-the-dark-underbelly-of-women-who-code-and-google-women-techmakers-723be27a45df&quot;&gt;Atlanta Tech&lt;/a&gt;, &lt;a href=&quot;https://reason.com/blog/2017/04/18/drupal-developer-ousted-over-kink#slide1&quot;&gt;Drupal&lt;/a&gt;) have faced harassment, insulting communication, doxxing, threatening behavior, and even career sabotage, as a result of personal attributes that were completely irrelevant to their membership in these communities.&lt;/p&gt;

&lt;p&gt;Disturbingly, it’s clear from historical records that Contributor COC is &lt;a href=&quot;https://github.com/ContributorCovenant/contributor_covenant/issues/73&quot;&gt;explicitly designed to not protect political views&lt;/a&gt;, potentially increasing legal liability in jurisdictions that forbid discrimination on political grounds.&lt;/p&gt;

&lt;h2 id=&quot;best-coc&quot;&gt;Best COC?&lt;/h2&gt;

&lt;p&gt;FCOP has broad coverage, strong inclusivity, legal protections, and bounded enforcement costs for leaders, but that doesn’t make it the right choice for every community. For support groups, for example, which are focused on social or personal goals, some provisions in FCOP are not relevant.&lt;/p&gt;

&lt;p&gt;Because not all communities are exclusively focused on professional goals, there is no one COC that is best for every community. Different communities can and should make the choice that’s right for them.&lt;/p&gt;

&lt;p&gt;For communities exclusively focused on professional goals, which are committed to having a COC, FCOP offers a compelling package.&lt;/p&gt;

&lt;h2 id=&quot;special-thanks&quot;&gt;Special Thanks&lt;/h2&gt;

&lt;p&gt;A special thanks to all the people who helped author or submit revisions to FCOP, including Ankush N., Matthew G., Rachel H., and Morgan P.; and to all those whose critique of FCOP directly contributed to the current design, including Marlene J., Matthew G., Adrienne L., Christie K., Sophia D., Courtney D., and Matthew D..&lt;/p&gt;

&lt;p&gt;Through their contributions and critiques, all these people and many others have helped make FCOP the most thoroughly analyzed, precise, and comprehensive COC available today for professional communities.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/fantasylandinst/fcop&quot;&gt;Take a look&lt;/a&gt; at the results for yourself, and if you see a way to improve FCOP, please submit issues or pull requests!&lt;/p&gt;

  &lt;p&gt;&lt;a href=&quot;https://degoes.net/articles/coc-review&quot;&gt;FCOP Nears 1.0 Release&lt;/a&gt; was originally published by John A De Goes at &lt;a href=&quot;https://degoes.net&quot;&gt;John <em>A</em> <strong>De Goes</strong>&lt;/a&gt; on February 14, 2018.&lt;/p&gt;</content>
</entry>

</feed>
